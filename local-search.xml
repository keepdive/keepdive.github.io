<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>macOS M1芯片centos8容器下Solr的安装教程(单机版)</title>
    <link href="/2022/03/24/macOS-M1%E8%8A%AF%E7%89%87centos8%E5%AE%B9%E5%99%A8%E4%B8%8BSolr%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2022/03/24/macOS-M1%E8%8A%AF%E7%89%87centos8%E5%AE%B9%E5%99%A8%E4%B8%8BSolr%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、<strong>环境</strong></h3><h4 id="1-1-相关信息"><a href="#1-1-相关信息" class="headerlink" title="1.1 相关信息"></a>1.1 相关信息</h4><p><strong>电脑信息</strong>：M1芯片，MacOS  Monterey 12.2.1</p><p><strong>Docker信息</strong>：Docker DeskTop 4.6.0</p><p><strong>容器镜像信息</strong>：centos:latest</p><p><strong>系统环境</strong>：centos 8.4 ARM架构</p><p><strong>JDK 版本</strong>：jdk-8u321-linux-aarch64</p><p><strong>Solr 版本</strong>：solr-8.11.1.tgz</p><p><strong>Zookeeper版本</strong>：使用solr自带3.6.2版本。</p><h5 id="2-2-安装solr需要的软件"><a href="#2-2-安装solr需要的软件" class="headerlink" title="2.2 安装solr需要的软件"></a>2.2 安装solr需要的软件</h5><table><thead><tr><th><strong>软件</strong></th><th><strong>版本</strong></th><th><strong>下载地址</strong></th></tr></thead><tbody><tr><td><strong>solr</strong></td><td>solr-8.11.1.tgz</td><td><a href="https://dlcdn.apache.org/lucene/solr/8.11.1/solr-8.11.1.tgz">https://dlcdn.apache.org/lucene/solr/8.11.1/solr-8.11.1.tgz</a></td></tr><tr><td><strong>JDK</strong></td><td>jdk-8u321-linux-aarch64.tar.gz</td><td><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></td></tr><tr><td><strong>Zookeeper</strong></td><td>3.6.2</td><td>使用Solr自带的zk</td></tr></tbody></table><h3 id="二、-下载安装"><a href="#二、-下载安装" class="headerlink" title="二、 下载安装"></a>二、 下载安装</h3><h4 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h4><p>在<a href="https://solr.apache.org/guide/8_11/solr-tutorial.html">官网</a> 下载所需版本的 Solr，这里我下载的版本为<a href="https://dlcdn.apache.org/lucene/solr/8.11.1/solr-8.11.1.tgz">Solr-8.11.1</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Linux</tag>
      
      <tag>CentOS</tag>
      
      <tag>M1芯片</tag>
      
      <tag>macOS</tag>
      
      <tag>ARM架构</tag>
      
      <tag>Solr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS M1芯片centos8容器下JDK的安装</title>
    <link href="/2022/03/24/macOS-M1%E8%8A%AF%E7%89%87centos8%E5%AE%B9%E5%99%A8%E4%B8%8BJDK%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2022/03/24/macOS-M1%E8%8A%AF%E7%89%87centos8%E5%AE%B9%E5%99%A8%E4%B8%8BJDK%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、<strong>环境</strong></h3><h4 id="1-1-相关信息"><a href="#1-1-相关信息" class="headerlink" title="1.1 相关信息"></a>1.1 相关信息</h4><p><strong>电脑信息</strong>：M1芯片，MacOS  Monterey 12.2.1</p><p><strong>Docker信息</strong>：Docker DeskTop 4.6.0</p><p><strong>容器镜像信息</strong>：centos:latest</p><p><strong>系统环境</strong>：centos 8.4 ARM架构</p><p><strong>JDK 版本</strong>：jdk-8u321-linux-aarch64</p><h3 id="二、-下载安装"><a href="#二、-下载安装" class="headerlink" title="二、 下载安装"></a>二、 下载安装</h3><h4 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h4><p>在<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">官网</a> 下载所需版本的 JDK，这里我下载的版本为<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 1.8</a> ；</p><h4 id="2-2-上传物料到容器"><a href="#2-2-上传物料到容器" class="headerlink" title="2.2 上传物料到容器"></a>2.2 上传物料到容器</h4><p>使用finalshell登陆服务器后，进入/usr/local目录，把物料上传到此目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入/usr/local目录</span><br><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324111101720.png" alt="image-20220324111101720"></p><h4 id="2-3-解压JDK物料包"><a href="#2-3-解压JDK物料包" class="headerlink" title="2.3 解压JDK物料包"></a>2.3 解压JDK物料包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf jdk-8u321-linux-aarch64.tar.gz <br></code></pre></td></tr></table></figure><p>命令解释：</p><p>-z：有gzip属性的</p><p>-x：代表extract（解包）</p><p>-v：代表verbose（显示所有过程）</p><p>-f：代表filename（文件名）所以f后面必须接文件名。</p><h3 id="三、设置环境变量"><a href="#三、设置环境变量" class="headerlink" title="三、设置环境变量"></a>三、设置环境变量</h3><h4 id="3-1-修改-etc-profile文件"><a href="#3-1-修改-etc-profile文件" class="headerlink" title="3.1 修改/etc/profile文件"></a>3.1 修改/etc/profile文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在/etc/profile文件追加Java相关信息</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;export JAVA_HOME=/usr/local/jdk1.8.0_321&quot;</span> &gt;&gt; /etc/profile<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;export PATH=/usr/local/jdk1.8.0_321/bin:<span class="hljs-variable">$PATH</span>&quot;</span> &gt;&gt; /etc/profile<br><span class="hljs-comment">#使用source命令，使配置生效（如果没有生效，断开服务器连接，重新连接）</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324112730663.png" alt="image-20220324112730663"></p><h4 id="3-2-检查配置是否生效"><a href="#3-2-检查配置是否生效" class="headerlink" title="3.2 检查配置是否生效"></a>3.2 检查配置是否生效</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br></code></pre></td></tr></table></figure><p>显示出对应的版本信息则代表配置生效。<img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324113004860.png" alt="image-20220324113004860"></p><h3 id="四、使用脚本安装"><a href="#四、使用脚本安装" class="headerlink" title="四、使用脚本安装"></a>四、使用脚本安装</h3><p>可以把以上步骤写成脚本，更加方便。</p><h4 id="4-1-创建脚本"><a href="#4-1-创建脚本" class="headerlink" title="4.1 创建脚本"></a>4.1 创建脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建脚本</span><br>vim install-java.sh<br><span class="hljs-comment">#赋予执行权限</span><br>chmod +x install-java.sh<br></code></pre></td></tr></table></figure><p>install-java.sh脚本详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">接收安装路径参数</span><br>install_path=$1<br><span class="hljs-meta">#</span><span class="bash">删除安装目录</span><br>rm $&#123;install_path&#125; -rf<br><span class="hljs-meta">#</span><span class="bash">创建安装目录</span><br>mkdir -p $&#123;install_path&#125;<br><span class="hljs-meta">#</span><span class="bash">解压jdk物料</span><br>tar -zxvf /usr/local/jdk-8u321-linux-aarch64.tar.gz -C $&#123;install_path&#125;<br><span class="hljs-meta">#</span><span class="bash">在/etc/profile文件追加Java相关信息</span><br>echo -e &quot;export JAVA_HOME=$&#123;install_path&#125;jdk1.8.0_321&quot; &gt;&gt; /etc/profile<br>echo -e &quot;export PATH=$&#123;install_path&#125;jdk1.8.0_321/bin:$PATH&quot; &gt;&gt; /etc/profile<br><span class="hljs-meta">#</span><span class="bash">使用<span class="hljs-built_in">source</span>命令，使配置生效</span><br>source /etc/profile<br><span class="hljs-meta">#</span><span class="bash">查看java版本</span><br>java -version<br>echo $?<br></code></pre></td></tr></table></figure><h4 id="4-2-执行脚本"><a href="#4-2-执行脚本" class="headerlink" title="4.2 执行脚本"></a>4.2 执行脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh install-java.sh /usr/local/jdk8/<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324141512715.png" alt="image-20220324141512715"></p><h4 id="4-3-检查java版本"><a href="#4-3-检查java版本" class="headerlink" title="4.3 检查java版本"></a>4.3 检查java版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324141546584.png" alt="image-20220324141546584"></p><p>ps：如果提示 -bash: java: command not found，断开服务器连接，重新连接。再次输入java -version命令。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Linux</tag>
      
      <tag>CentOS</tag>
      
      <tag>M1芯片</tag>
      
      <tag>macOS</tag>
      
      <tag>JDK</tag>
      
      <tag>ARM架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS M1芯片DockerDeskTop安装CentOS胎教级教程</title>
    <link href="/2022/03/23/macOS%20M1%E8%8A%AF%E7%89%87DockerDeskTop%E5%AE%89%E8%A3%85CentOS%E8%83%8E%E6%95%99%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/03/23/macOS%20M1%E8%8A%AF%E7%89%87DockerDeskTop%E5%AE%89%E8%A3%85CentOS%E8%83%8E%E6%95%99%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><h4 id="1-1-系统信息"><a href="#1-1-系统信息" class="headerlink" title="1.1 系统信息"></a>1.1 系统信息</h4><p><strong>操作系统：</strong>MacOS  Monterey 12.2.1</p><p><strong>芯片：</strong>Apple M1 Pro</p><h4 id="1-2-软件信息"><a href="#1-2-软件信息" class="headerlink" title="1.2 软件信息"></a>1.2 软件信息</h4><p><strong>软件：</strong>Docker DeskTop 4.6.0、Final Shell 3.9.2.2</p><h4 id="1-3-镜像信息"><a href="#1-3-镜像信息" class="headerlink" title="1.3 镜像信息"></a>1.3 镜像信息</h4><p><strong>IMAGE：</strong>centos</p><p><strong>TAG：</strong>latest</p><p><strong>CentOS:</strong> CentOS Linux release 8.4.2105</p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><h4 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1 拉取镜像"></a>2.1 拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull centos<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220323182245183.png" alt="image-20220323182245183"></p><h4 id="2-2-创建容器"><a href="#2-2-创建容器" class="headerlink" title="2.2 创建容器"></a>2.2 创建容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -dp 5002:22 --name centos8 --privileged=<span class="hljs-literal">true</span>  centos /usr/sbin/init<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220323182345478.png" alt="image-20220323182345478"></p><h5 id="2-2-1-命令详解"><a href="#2-2-1-命令详解" class="headerlink" title="2.2.1 命令详解"></a>2.2.1 命令详解</h5><p>run：表示运行容器</p><p>-dp:  -d和-p的缩写，表示后台运行、表示宿主机端口与Docker容器端口映射</p><p>–name：为容器指定一个名称</p><p>–privileged：赋予特权，给予容器内的root拥有真正的root权限。</p><p>centos：启动的镜像</p><p>/usr/sbin/init：解决容器内systemctl命令无权限使用的问题</p><h4 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h4><p>格式：docker exec -it 容器名 bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it centos8 bash<br><span class="hljs-comment">#查询centos版本</span><br>cat /etc/redhat-release<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220323182641159.png" alt="image-20220323182641159"></p><h4 id="2-4-修改yum源"><a href="#2-4-修改yum源" class="headerlink" title="2.4 修改yum源"></a>2.4 修改yum源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入目录</span><br><span class="hljs-built_in">cd</span> /etc/yum.repos.d<br><span class="hljs-comment">#修改配置文件CentOS-Linux-BaseOS.repo</span><br>vi CentOS-Linux-BaseOS.repo<br><span class="hljs-comment">#修改配置文件CentOS-Linux-AppStream.repo</span><br>vi CentOS-Linux-AppStream.repo<br></code></pre></td></tr></table></figure><h5 id="2-4-1修改后的CentOS-Linux-BaseOS-repo文件"><a href="#2-4-1修改后的CentOS-Linux-BaseOS-repo文件" class="headerlink" title="2.4.1修改后的CentOS-Linux-BaseOS.repo文件"></a>2.4.1修改后的CentOS-Linux-BaseOS.repo文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[baseos]<br>name=CentOS Linux <span class="hljs-variable">$releasever</span> - BaseOS<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=BaseOS&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/</span><br>baseurl=https://vault.centos.org/centos/<span class="hljs-variable">$releasever</span>/BaseOS/<span class="hljs-variable">$basearch</span>/os/<br>gpgcheck=1<br>enabled=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial<br></code></pre></td></tr></table></figure><h5 id="2-4-2-修改后的CentOS-Linux-BaseOS-repo文件"><a href="#2-4-2-修改后的CentOS-Linux-BaseOS-repo文件" class="headerlink" title="2.4.2 修改后的CentOS-Linux-BaseOS.repo文件"></a>2.4.2 修改后的CentOS-Linux-BaseOS.repo文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[appstream]<br>name=CentOS Linux <span class="hljs-variable">$releasever</span> - AppStream<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=AppStream&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/</span><br>baseurl=https://vault.centos.org/centos/<span class="hljs-variable">$releasever</span>/AppStream/<span class="hljs-variable">$basearch</span>/os/<br>gpgcheck=1<br>enabled=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial<br></code></pre></td></tr></table></figure><h4 id="2-5-系统初始化"><a href="#2-5-系统初始化" class="headerlink" title="2.5 系统初始化"></a>2.5 系统初始化</h4><p>由于docker中是一个纯净版本，我需要给他安装必要的软件。（当然不止这些，需要用到的时候再装也行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install openssh-server vim passwd initscripts -y<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324093010356.png" alt="image-20220324093010356"></p><h4 id="2-6-启动ssh服务"><a href="#2-6-启动ssh服务" class="headerlink" title="2.6 启动ssh服务"></a>2.6 启动ssh服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动sshd</span><br>systemctl start sshd<br><span class="hljs-comment">#查看sshd进程</span><br>ps -ef | grep sshd<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324093336060.png" alt="image-20220324093336060"></p><h4 id="2-7-设置虚拟机root用户密码"><a href="#2-7-设置虚拟机root用户密码" class="headerlink" title="2.7 设置虚拟机root用户密码"></a>2.7 设置虚拟机root用户密码</h4><p>设置系统root用户密码，输入两次密码设置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd root<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324093716897.png" alt="image-20220324093716897"></p><h4 id="2-8-ssh连接测试"><a href="#2-8-ssh连接测试" class="headerlink" title="2.8 ssh连接测试"></a>2.8 ssh连接测试</h4><h5 id="2-8-1-通过宿主机shh连接"><a href="#2-8-1-通过宿主机shh连接" class="headerlink" title="2.8.1 通过宿主机shh连接"></a>2.8.1 通过宿主机shh连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost -p 5002<br></code></pre></td></tr></table></figure><p>此时可以通过宿主机ssh来访问这台虚拟机：ssh root@localhost -p 5002 这里-p就是指定的5002端口去ssh容器中的ss端口。此时做到了ssh到这台容器虚拟机里面。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324094106165.png" alt="image-20220324094106165"></p><h5 id="2-8-2-通过finalshell连接"><a href="#2-8-2-通过finalshell连接" class="headerlink" title="2.8.2 通过finalshell连接"></a>2.8.2 通过finalshell连接</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324094343767.png" alt="image-20220324094343767"></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324094516073.png" alt="image-20220324094516073"></p><h3 id="三、制作镜像"><a href="#三、制作镜像" class="headerlink" title="三、制作镜像"></a>三、制作镜像</h3><p>由于基础镜像的centos镜像是纯净版的，需要在基础镜像之上在安装对应的软件。因此如果我们已经安装了一些软件则可以将这个安装的工具的镜像在打包成一个镜像，后续就可以使用这个“基础镜像”来拉起容器，这个时候这个容器里面就可以有个有这些工具了。因此可以用docker命令对这个容器进行镜像制作。使用到的命令：</p><h4 id="3-1-基于centos容器制作镜像"><a href="#3-1-基于centos容器制作镜像" class="headerlink" title="3.1 基于centos容器制作镜像"></a>3.1 基于centos容器制作镜像</h4><p>格式：docker commit -m “镜像描述”   -a “制作者”  容器名 镜像名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit -m <span class="hljs-string">&quot;test make dockerimage&quot;</span> -a<span class="hljs-string">&quot;mike&quot;</span> centos8 centos8:v1<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324095728609.png" alt="image-20220324095728609"></p><h4 id="3-2-创建容器"><a href="#3-2-创建容器" class="headerlink" title="3.2 创建容器"></a>3.2 创建容器</h4><p>基于创建的centos8:v1的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -dp 5003:22 --name centos8v1 --privileged=<span class="hljs-literal">true</span>  centos8:v1 /usr/sbin/init<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324100118947.png" alt="image-20220324100118947"></p><h4 id="3-3-测试ssh连接"><a href="#3-3-测试ssh连接" class="headerlink" title="3.3 测试ssh连接"></a>3.3 测试ssh连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost -p 5003<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324100330446.png" alt="image-20220324100330446"></p><h3 id="四、问题汇总"><a href="#四、问题汇总" class="headerlink" title="四、问题汇总"></a>四、问题汇总</h3><h4 id="4-1-无法使用ifconfig"><a href="#4-1-无法使用ifconfig" class="headerlink" title="4.1 无法使用ifconfig"></a>4.1 无法使用ifconfig</h4><p>问题描述：使用ifconfig命令，提示-bash: ifconfig: command not found</p><p>问题原因：centos镜像是纯净版的，很多软件没有安装。</p><p>解决方案：安装net-tools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install net-tools -y<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324102244830.png" alt="image-20220324102244830"></p><p>测试结果：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20220324102413249.png" alt="image-20220324102413249"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Linux</tag>
      
      <tag>CentOS</tag>
      
      <tag>M1芯片，macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/12/28/ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85MySQL/"/>
    <url>/2021/12/28/ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="源码方式安装MySQL（ARM架构）"><a href="#源码方式安装MySQL（ARM架构）" class="headerlink" title="源码方式安装MySQL（ARM架构）"></a>源码方式安装MySQL（ARM架构）</h2><h3 id="一、软件介绍"><a href="#一、软件介绍" class="headerlink" title="一、软件介绍"></a><strong>一、软件介绍</strong></h3><p>MySQL是一个关系型数据库管理系统。</p><h3 id="二、环境要求"><a href="#二、环境要求" class="headerlink" title="二、环境要求"></a><strong>二、环境要求</strong></h3><p>mysql-5.7.28版本</p><h3 id="三、配置编译环境"><a href="#三、配置编译环境" class="headerlink" title="三、配置编译环境"></a><strong>三、配置编译环境</strong></h3><h4 id="步骤一：检查cmake是否安装"><a href="#步骤一：检查cmake是否安装" class="headerlink" title="步骤一：检查cmake是否安装"></a><strong>步骤一：检查cmake是否安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -qa |grep cmake<br></code></pre></td></tr></table></figure><ul><li><p>如果未安装，需要安装：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://cmake.org/files/v<span class="hljs-number">3</span>.<span class="hljs-number">12</span>/cmake-<span class="hljs-number">3</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span>.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压cmake</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf cmake-3.12.1.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>进入 cmake目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> cmake-3.12.1<br></code></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bootstrap<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gmake<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gmake install<br></code></pre></td></tr></table></figure></li></ul><h4 id="步骤二：安装依赖包"><a href="#步骤二：安装依赖包" class="headerlink" title="步骤二：安装依赖包"></a><strong>步骤二：安装依赖包</strong></h4><ul><li><p>执行以下命令安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bison* ncurses*<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bzip2 wget<br></code></pre></td></tr></table></figure></li><li><p>在线安装openssl-devel：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install openssl-devel<br></code></pre></td></tr></table></figure></li><li><p>离线安装openssl-devel：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://www.openssl.org/<span class="hljs-built_in">source</span>/openssl-1.1.1d.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压openssl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf openssl-1.1.1d.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>进入openssl-1.1.1d目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  openssl-1.1.1d <br></code></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./config shared zlib<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make depend<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure></li><li><p>安装rpcgen</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/thkukuk/rpcsvc-proto/releases/download/v1.4/rpcsvc-proto-1.4.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf rpcsvc-proto-1.4.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>进入解压后的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> rpcsvc-proto-1.4<br></code></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure></li></ul><h4 id="步骤三：升级gcc版本至5-3或者以上-忽略这一步，提供的测试环境目前是7-3-1-6版本的。"><a href="#步骤三：升级gcc版本至5-3或者以上-忽略这一步，提供的测试环境目前是7-3-1-6版本的。" class="headerlink" title="步骤三：升级gcc版本至5.3或者以上(忽略这一步，提供的测试环境目前是7.3.1-6版本的。)"></a><strong>步骤三：升级gcc版本至5.3或者以上</strong>(忽略这一步，提供的测试环境目前是7.3.1-6版本的。)</h4><h5 id="1-检查gcc的版本"><a href="#1-检查gcc的版本" class="headerlink" title="1.检查gcc的版本"></a><strong>1.检查gcc的版本</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228190757494.png" alt="image-20211228190757494"></p><ul><li><p>(可选）安装gcc7.3。</p></li><li><p>本文档以7.3版本为例。</p></li></ul><h5 id="2-当版本不满足要求时，需要安装gcc"><a href="#2-当版本不满足要求时，需要安装gcc" class="headerlink" title="2.当版本不满足要求时，需要安装gcc"></a><strong>2.当版本不满足要求时，需要安装gcc</strong></h5><ul><li><p>下载gcc7.3。</p></li><li><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz">https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz</a></p></li><li><p>将“gcc-7.3.0.tar.gz”放置于“/home”目录下，并解压安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf gcc-7.3.0.tar.gz<br></code></pre></td></tr></table></figure></li></ul><h5 id="3-下载isl、gmp、mpc、mpfr"><a href="#3-下载isl、gmp、mpc、mpfr" class="headerlink" title="3.下载isl、gmp、mpc、mpfr"></a><strong>3.下载isl、gmp、mpc、mpfr</strong></h5><ul><li><p>1)在“gcc-7.3.0”目录下，检查gcc的依赖包是否已下载和安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./contrib/download_prerequisites<br></code></pre></td></tr></table></figure></li><li><p>2)（可选）根据需要，下载“gmp-6.1.0.tar.bz2”、“isl-0.16.1.tar.bz2”、“mpc-1.0.3.tar.gz”或“mpfr-3.1.4.tar.bz2”。</p></li><li><p>在步骤3.1中检查到存在上述依赖包未下载安装时，请根据需要执行相应的命令下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2<br><br>wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.16.1.tar.bz2<br><br>wget https://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz<br><br>wget https://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2<br></code></pre></td></tr></table></figure></li><li><p>3)将安装包放置于“/home/gcc-7.3.0”目录下。</p></li></ul><h5 id="4-编译安装gcc"><a href="#4-编译安装gcc" class="headerlink" title="4.编译安装gcc"></a><strong>4.编译安装gcc</strong></h5><ul><li><p>1)编译gcc。</p><ul><li><p>“-j”参数可利用多核CPU加快编译速度，在本示例中，使用的是16核CPU，所以此处为“-j64”。</p></li><li><p>可通过下述命令查询CPU核数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /proc/cpuinfo| grep <span class="hljs-string">&quot;processor&quot;</span>| wc -l<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/gcc-7.3.0<br><br>mkdir gcc-build-7.3.0<br><br><span class="hljs-built_in">cd</span> gcc-build-7.3.0<br><br>../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr<br><br>make -j64<br></code></pre></td></tr></table></figure><ul><li><p>2)执行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure></li><li><p>3)确定“libstdc++.so”是在“/usr/lib64”目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/lib64<br>ll |grep libstdc++.so<br></code></pre></td></tr></table></figure></li></ul><p><img src="http://www.adapt-center.com/upload/editor/20210726/thumb_70945b3a1798e5a561c0bd2c7ae92c27_1200_0.jpg" alt="img"></p><ul><li><p>4)确定软连接存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll |grep libstdc++.so.6.0.24<br></code></pre></td></tr></table></figure></li></ul><p><img src="http://www.adapt-center.com/upload/editor/20210726/thumb_cc33714da0eb6260e591d7d70381144c_1200_0.jpg" alt="undefined"></p><ul><li><p>5)查看版本，如图1-4所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br></code></pre></td></tr></table></figure></li></ul><p><img src="http://www.adapt-center.com/upload/editor/20210726/thumb_0c69fa0d622acfbc4b4c3a8800477d3d_1200_0.jpg" alt="img"></p><h3 id="四、下载源码"><a href="#四、下载源码" class="headerlink" title="四、下载源码"></a><strong>四、下载源码</strong></h3><ul><li><p>在“<a href="https://downloads.mysql.com/archives/community/%E2%80%9D%E4%B8%8B%E8%BD%BDMySQL%E6%BA%90%E7%A0%81%E5%8C%85%EF%BC%8C%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">https://downloads.mysql.com/archives/community/”下载MySQL源码包，并上传至服务器。</a></p></li><li><p>须知</p><ul><li>下载MySQL源码包时，如果版本为“5.x.x”，则必须为5.7.27以上，如果版本为“8.x.x”，则必须为8.0.17以上。否则需要安装补丁，补丁的安装请参见本文档“编译安装”中的描述。</li></ul></li><li><p><strong>说明：</strong></p><p><strong>由于系统为ARM架构，故需要下载源码编译安装</strong></p><p><strong>select Operating System 选项和Select OS Version选项必须与图片一致</strong></p><p><strong>选择mysql-boost-xxx版本</strong></p></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228192947574.png" alt="image-20211228192947574"></p><h3 id="五、编译安装"><a href="#五、编译安装" class="headerlink" title="五、编译安装"></a><strong>五、编译安装</strong></h3><h4 id="1-进入下载的源码包所在的目录，解压缩源码包"><a href="#1-进入下载的源码包所在的目录，解压缩源码包" class="headerlink" title="1.进入下载的源码包所在的目录，解压缩源码包"></a><strong>1.进入下载的源码包所在的目录，解压缩源码包</strong></h4><p>解压后生成“mysql-5.7.x”文件夹，具体版本号以实际为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zvxf mysql-boost-5.7.28.tar.gz <br></code></pre></td></tr></table></figure><h4 id="2-（可选）安装补丁"><a href="#2-（可选）安装补丁" class="headerlink" title="2.（可选）安装补丁"></a><strong>2.（可选）安装补丁</strong></h4><ul><li><p>MySQL源码包版本为“5.x.x”，则必须为5.7.27以上，版本为“8.x.x”，则必须为8.0.17以上。否则需要安装补丁。</p></li><li><p>1)下载补丁文件，并放置到“mysql-5.7.x”路径下。</p><ul><li>补丁下载路径：<a href="https://bugs.mysql.com/file.php?id=28180&amp;bug_id=94699">https://bugs.mysql.com/file.php?id=28180&amp;bug_id=94699</a></li></ul></li><li><p>2)进入目录并打补丁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mysql-5.7.XX<br>patch -p1 &lt; 0001-Bug-94699-Mysql-deadlock-and-bugcheck-on-aarch64.patch<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-在解压后的源码包路径“mysql-5-7-x”下，创建“cmake-sh”"><a href="#3-在解压后的源码包路径“mysql-5-7-x”下，创建“cmake-sh”" class="headerlink" title="3.在解压后的源码包路径“mysql-5.7.x”下，创建“cmake.sh”"></a><strong>3.在解压后的源码包路径“mysql-5.7.x”下，创建“cmake.sh</strong>”</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mysql-5.7.28<br>vim cmake.sh<br></code></pre></td></tr></table></figure><ul><li>文件内容如下，其中，“DWITH_BOOST”的取值请根据实际的boost路径修改。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">cmake . -DCMAKE_INSTALL_PREFIX=/usr/<span class="hljs-built_in">local</span>/mysql \<br>-DMYSQL_DATADIR=/data/data \<br>-DSYSCONFDIR=/etc \<br>-DWITH_INNOBASE_STORAGE_ENGINE=1 \<br>-DWITH_PARTITION_STORAGE_ENGINE=1 \<br>-DWITH_FEDERATED_STORAGE_ENGINE=1 \<br>-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \<br>-DWITH_MYISAM_STORAGE_ENGINE=1 \<br>-DENABLED_LOCAL_INFILE=1 \<br>-DENABLE_DTRACE=0 \<br>-DDEFAULT_CHARSET=utf8mb4 \<br>-DDEFAULT_COLLATION=utf8mb4_general_ci \<br>-DWITH_EMBEDDED_SERVER=1 \<br>-DDOWNLOAD_BOOST=1 \<br>-DWITH_BOOST=/root/mysql-5.7.28/boost/boost_1_59_0<br></code></pre></td></tr></table></figure><ul><li><p><strong>说明：-DCMAKE_INSTALL_PREFIX=/usr/local/mysql   安装路径</strong></p><p><strong>-DMYSQL_DATADIR=/data/data    数据存储路径</strong></p><p><strong>-DWITH_BOOST=/mysql/mysql-5.7.28/boost/boost_1_59_0根据实际的boost路径修改</strong></p></li></ul><h4 id="4-给“cmake-sh”赋以权限并运行，等待运行完成"><a href="#4-给“cmake-sh”赋以权限并运行，等待运行完成" class="headerlink" title="4.给“cmake.sh”赋以权限并运行，等待运行完成"></a><strong>4.给“cmake.sh”赋以权限并运行，等待运行完成</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x cmake.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./cmake.sh<br></code></pre></td></tr></table></figure><ul><li><p>执行完后注意是否成功，成功后会生成Makefile文件</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228210711947.png" alt="image-20211228210711947"></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228210752140.png" alt="image-20211228210752140"></p></li><li><p>在执行**./cmake.sh**时会自动下载“boost_1_59_0.tar.gz” ，若出现超时报错的情况，可手工下载，并将文件放置到“cmake.sh”配置文件中“DWITH_BOOST”指定对应的路径下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>若在预编译时出现依赖包不全的情况，可自行查阅资料安装依赖包，并重新预编译。重新预编译前，需要执行<strong>rm -f CMakeCache.txt</strong>删“CMakeCache.txt文件。”</p></li></ul><h4 id="5-在MySQL源码路径下运行make-j64，等待编译完成"><a href="#5-在MySQL源码路径下运行make-j64，等待编译完成" class="headerlink" title="5.在MySQL源码路径下运行make -j64，等待编译完成"></a><strong>5.在MySQL源码路径下运行make -j64，等待编译完成</strong></h4><ul><li><p>“-j”参数可利用多核CPU加快编译速度，在本示例中，使用的是8核CPU，所以此处为“-j32”。</p></li><li><p>可通过下述命令查询CPU核数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /proc/cpuinfo| grep <span class="hljs-string">&quot;processor&quot;</span>| wc -l<br>make -j32<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228211517517.png" alt="image-20211228211517517"></p><h4 id="6-运行make-install，等待安装过程结束"><a href="#6-运行make-install，等待安装过程结束" class="headerlink" title="6.运行make install，等待安装过程结束"></a>6.运行<strong>make install</strong>，等待安装过程结束</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211228211618648.png" alt="image-20211228211618648"></p><h3 id="六、配置MySQL"><a href="#六、配置MySQL" class="headerlink" title="六、配置MySQL"></a><strong>六、配置MySQL</strong></h3><h4 id="1-创建“mysql”用户及用户组"><a href="#1-创建“mysql”用户及用户组" class="headerlink" title="1.创建“mysql”用户及用户组"></a><strong>1.创建“mysql”用户及用户组</strong></h4><p>查看系统中是否存在mysql用户和组：以下是存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/group | grep mysql<br>cat /etc/passwd | grep mysql<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211229092904368.png" alt="image-20211229092904368"></p><p>若不存在则创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd mysql<br>useradd -g mysql mysql<br></code></pre></td></tr></table></figure><h4 id="2-修改“-usr-local-mysql”（安装路径）权限"><a href="#2-修改“-usr-local-mysql”（安装路径）权限" class="headerlink" title="2.修改“/usr/local/mysql”（安装路径）权限"></a><strong>2.修改“/usr/local/mysql”（安装路径）权限</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chown -R mysql.mysql /usr/<span class="hljs-built_in">local</span>/mysql<br></code></pre></td></tr></table></figure><h4 id="3-进入安装路径，创建“data”、“log”、“run”文件夹，执行初始化配置脚本，生成初始的数据库和表"><a href="#3-进入安装路径，创建“data”、“log”、“run”文件夹，执行初始化配置脚本，生成初始的数据库和表" class="headerlink" title="3.进入安装路径，创建“data”、“log”、“run”文件夹，执行初始化配置脚本，生成初始的数据库和表"></a><strong>3.进入安装路径，创建“data”、“log”、“run”文件夹，执行初始化配置脚本，生成初始的数据库和表</strong></h4><ul><li>注意：执行下述命令后<strong>，</strong>会产生初始随机密码<strong>，</strong>需要记录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mysql<br>mkdir -p /data/<span class="hljs-built_in">log</span> /data/data /data/run<br>bin/mysqld --initialize --basedir=/usr/<span class="hljs-built_in">local</span>/mysql --datadir=/data/data --user=mysql<br></code></pre></td></tr></table></figure><ul><li>用–initialize-insecure     替换–initialize  就可以设置没有密码。后面可以自己用参数带进去修改密码</li><li>报错：</li></ul><p>bin/mysqld: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory<br>bin/mysqld: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory</p><ul><li><p>出现该问题首先检查该链接库文件有没有安装使用 命令进行核查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -qa|grep libaio <br></code></pre></td></tr></table></figure></li><li><p>增加软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /root/openssl-1.1.1d/libssl.so.1.1 /usr/lib64/libssl.so.1.1<br>ln -s /root/openssl-1.1.1d/libcrypto.so.1.1  /usr/lib64/libcrypto.so.1.1 <br></code></pre></td></tr></table></figure></li><li><p>执行命令成功后产生了密码：L+d1&gt;M2On%G&lt;</p></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211230181248614.png" alt="image-20211230181248614"></p><h4 id="4-创建“mysql-log”和“mysql-pid”文件，赋予“mysql”用户及用户组权限"><a href="#4-创建“mysql-log”和“mysql-pid”文件，赋予“mysql”用户及用户组权限" class="headerlink" title="4.创建“mysql.log”和“mysql.pid”文件，赋予“mysql”用户及用户组权限"></a><strong>4.创建“mysql.log”和“mysql.pid”文件，赋予“mysql”用户及用户组权限</strong></h4><ul><li>其中，创建的“mysql.log”和“mysql.pid”文件是空文件，创建后保存退出即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /data/<span class="hljs-built_in">log</span>/mysql.log<br><br>vim /data/run/mysql.pid<br><br>chown -R mysql:mysql /data<br></code></pre></td></tr></table></figure><h4 id="5-修改“my-cnf”中的文件路径"><a href="#5-修改“my-cnf”中的文件路径" class="headerlink" title="5.修改“my.cnf”中的文件路径"></a><strong>5.修改“my.cnf”中的文件路径</strong></h4><p>如图所示（注意：若/usr/local/mysql下有my.cnf则默认此文件为配置文件需要修改此路径下的my.cnf，若没有则为/etc/my.cnf）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/my.cnf<br></code></pre></td></tr></table></figure><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211231101208174.png" alt="image-20211231101208174" style="zoom:50%;" /><ul><li><strong>注意：</strong><ul><li><strong>skip-grant-tables</strong> <strong>不要写（此为忘记密码时所用）</strong></li><li><strong>文件中配置的路径一定要与自己环境一致，否则启动会报错</strong></li></ul></li></ul><h3 id="七、运行MySQL"><a href="#七、运行MySQL" class="headerlink" title="七、运行MySQL"></a>七、<strong>运行MySQL</strong></h3><h4 id="1-启动MySQL服务"><a href="#1-启动MySQL服务" class="headerlink" title="1.启动MySQL服务"></a><strong>1.启动MySQL服务</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#拷贝文件</span><br>cp /usr/<span class="hljs-built_in">local</span>/mysql/support-files/mysql.server /etc/init.d/mysql<br><br><span class="hljs-comment">#设置开机自启</span><br>chkconfig mysql on<br><br><span class="hljs-comment">#启动</span><br>service mysql start<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211231103507742.png" alt="image-20211231103507742"></p><h4 id="2-将以下内容添加进环境变量，并使之生效"><a href="#2-将以下内容添加进环境变量，并使之生效" class="headerlink" title="2.将以下内容添加进环境变量，并使之生效"></a><strong>2.将以下内容添加进环境变量，并使之生效</strong></h4><ul><li><p>编辑文件并添加内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bash_profile<br></code></pre></td></tr></table></figure></li><li><p>添加的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/<span class="hljs-built_in">local</span>/mysql/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li><li><p>添加环境变量后如图所示。</p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211231103808839.png" alt="image-20211231103808839" style="zoom:50%;" /></li><li><p>使环境变量生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure></li><li><p>查看MySQL的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动mysql</span><br>systemctl start mysql<br><br><span class="hljs-comment">#查看mysql的命令</span><br>systemctl status mysql<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-建立套接字软链接，接入MySQL环境"><a href="#3-建立套接字软链接，接入MySQL环境" class="headerlink" title="3.建立套接字软链接，接入MySQL环境"></a><strong>3.建立套接字软链接，接入MySQL环境</strong></h4><ul><li><p>建立套接字软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /data/data/mysql.sock /tmp/mysql.sock<br></code></pre></td></tr></table></figure></li><li><p>需要输入的密码为配置MySQL时产生的初始密码（L+d1&gt;M2On%G&lt;），请留意初始密码包含了特殊字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查询临时密码</span><br>grep <span class="hljs-string">&#x27;temporary password&#x27;</span> /data/<span class="hljs-built_in">log</span>/mysql.log <br><br><span class="hljs-comment">#登陆mysql</span><br>mysql -uroot -p<br></code></pre></td></tr></table></figure></li><li><p>修改密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改密码<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Tcdn@2021&#x27;; <br><br>#刷新权限<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p>查询数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure></li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><h4 id="问题一：启动MySQL服务提示“ERROR-The-server-quit-without-updating-PID-file”"><a href="#问题一：启动MySQL服务提示“ERROR-The-server-quit-without-updating-PID-file”" class="headerlink" title="问题一：启动MySQL服务提示“ERROR! The server quit without updating PID file”"></a>问题一：启动MySQL服务提示“ERROR! The server quit without updating PID file”</h4><ul><li><p><strong>解决方法：</strong></p><ul><li><p>1)首先检查my.cnf文件中的所有路径是否正确</p></li><li><p>2)MySQL安装及“data/log/run”路径未赋予用户及用户组正确权限，请使用以下命令赋权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">chown -R mysql:mysql /usr/<span class="hljs-built_in">local</span>/mysql<br><br>chown -R mysql:mysql /data<br></code></pre></td></tr></table></figure></li><li><p>3)查看是否已有mysql进程在运行，kill掉后再尝试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep mysqld<br><br><span class="hljs-comment">#杀掉进程</span><br><span class="hljs-built_in">kill</span> -9 进程号<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="问题二：忘记MySQL的初始密码"><a href="#问题二：忘记MySQL的初始密码" class="headerlink" title="问题二：忘记MySQL的初始密码"></a>问题二：忘记MySQL的初始密码</h4><ul><li><p><strong>问题描述：</strong></p><ul><li>在连接MySQL时，忘记初始密码。</li></ul></li><li><p><strong>解决方法：</strong></p><ul><li><p>修改在my.cnf配置文件中加上**skip-grant-tables ,**<strong>重启服务</strong></p></li><li><p><strong>输入</strong>mysql -uroot -p</p></li><li><p>显示输入密码，不输入直接按回车键进入mysql</p></li></ul></li></ul><h4 id="问题三：执行初始化配置脚本报错"><a href="#问题三：执行初始化配置脚本报错" class="headerlink" title="问题三：执行初始化配置脚本报错"></a>问题三：执行初始化配置脚本报错</h4><ul><li><p><strong>问题描述</strong></p><ul><li><p>在初始化配置脚本时报错</p><p>bin/mysqld: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory<br>bin/mysqld: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory</p></li></ul></li><li><p><strong>解决方法</strong></p><ul><li><p>出现该问题首先检查该链接库文件有没有安装使用 命令进行核查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -qa|grep libaio <br></code></pre></td></tr></table></figure></li><li><p>增加软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /root/openssl-1.1.1d/libssl.so.1.1 /usr/lib64/libssl.so.1.1<br>ln -s /root/openssl-1.1.1d/libcrypto.so.1.1  /usr/lib64/libcrypto.so.1.1 <br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十四、微服务拆分实战</title>
    <link href="/2021/12/07/%E5%8D%81%E5%9B%9B%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%AE%9E%E6%88%98/"/>
    <url>/2021/12/07/%E5%8D%81%E5%9B%9B%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h3 id="十四、微服务拆分实战"><a href="#十四、微服务拆分实战" class="headerlink" title="十四、微服务拆分实战"></a>十四、微服务拆分实战</h3><ul><li>前面已经介绍了TSF的基本功能以及使用，接下来我们再回到微服务上面来；</li><li>微服务的粒度是难点，也常常是争论的焦点。应当使用合理的粒度划分微服务，而不是一味将服务做小。代码量的多少不能作为微服务划分的依据，因为不同的服务本身的业务复杂性不同，代码量也不同。在微服务的设计阶段，就应确定其边界。微服务之间应该相对独立并保持松耦合。接下来我们看一下基于TSF的微服务拆分方法。</li></ul><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>了解微服务的拆分原则</li><li>掌握运用DDD（Domain Driven Design）方法进行领域建模</li></ul><h4 id="第一章-微服务拆分介绍"><a href="#第一章-微服务拆分介绍" class="headerlink" title="第一章 微服务拆分介绍"></a>第一章 微服务拆分介绍</h4><h5 id="1-1-微服务拆分简介"><a href="#1-1-微服务拆分简介" class="headerlink" title="1.1 微服务拆分简介"></a>1.1 微服务拆分简介</h5><ul><li><strong>企业什么时候引入微服务</strong></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207180528638.png" alt="image-20211207180528638"></p><ul><li>一般来说，项目第一阶段的主要目标是快速开发和验证想法，证明产品思路是否可行。这个阶段功能设计一般不会太复杂，开发采取快速迭代的方式，架构也不适合过度设计。所以将所有功能打包部署在一起，集中地进行开发、测试和运维，对于项目起步阶段，是最高效也是最节省成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。</li><li>一般情况下，这个时候就需要大规模地扩张开发人员，以支撑多个功能的开发。如果这个时候继续采用单体应用架构，多个功能模块混杂在一起开发、测试和部署的话，就会导致不同功能之间相互影响，一次打包部署需要所有的功能都测试OK才能上线。不仅如此，多个功能模块混部在一起，对线上服务的稳定性也是个巨大的挑战，比如A开发的一个功能由于代码编写考虑不够全面，上线后产生了内存泄漏，运行一段时间后进程异常推出，那么部署在这个服务池中的所有功能都不可访问。</li><li>所以，什么时候需要引入微服务呢？如上图所示，系统刚构建的时候，软件的复杂度并不高，这时候使用单体开发模式的效率很高。而微服务有额外成本的，需要搭建框架、发布、监控等基础设施。但是随着业务越来越复杂，我们的系统也越来越复杂，这时候单体应用的开发效率开始降低，微服务开发方式的效率优势开始凸显。</li><li><strong>综上所述，初创和小规模团队不建议采用微服务。主要决定因素是系统复杂性和团队规模，当到达一个点，单体架构严重影响效率才考虑。另外补充一点，微服务还和组织和团队有关，而不仅仅是技术。</strong></li></ul><ul><li><p><strong>如何将单体架构应用拆分为微服务架构</strong></p><ul><li><p>识别业务领域及边界</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207183212807.png" alt="image-20211207183212807"></p></li></ul></li><li><p>如何进行微服务的拆分呢？</p><ul><li>首先，我们需要对业务进行建模，识别业务领域及边界。</li><li>首先需要将客户、体验设计师、业务分析师、技术人员集结在一起对业务需求进行沟通， 随后对其进行领域划分，确定限界上下文(Boundary Context)，也称战略建模。</li></ul></li></ul><ul><li><p><strong>微服务的拆分策略</strong></p><ul><li>绞杀者策略<ul><li>指在遗留系统外围，将新功能用新的方式构建为新的服务。随着时间的推移，新的服务逐渐“绞杀”老的遗留系统。对于那些老旧庞大难以更改的遗留系统，推荐采用绞杀者模式。</li></ul></li><li>修饰者策略<ul><li>就如修房或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修复。修复的同时，需保证与其他部分仍能协同功能。</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207183604537.png" alt="image-20211207183604537"></p></li></ul><h6 id="1-1-1-微服务拆分的维度"><a href="#1-1-1-微服务拆分的维度" class="headerlink" title="1.1.1 微服务拆分的维度"></a>1.1.1 微服务拆分的维度</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207183855917.png" alt="image-20211207183855917"></p><ul><li>那么服务化拆分具体该如何实施呢？一个最有效的手段就是将不同的功能模块服务化，独立部署和运维。以社交 App 为例，你可以认为消息通知是一个服务，好友圈评论是一个服务，个人主页也是一个服务。</li><li>这种服务化拆分方式是纵向拆分，是从业务维度进行拆分。标准是按照业务的关联程度来决定， 关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</li><li>还有一种服务化拆分方式是横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</li><li>继续以前面提到的社交 App 举例，无论是首页信息流、评论、消息箱还是个人主页，都需要显示用户的昵称。假如用户的昵称功能有产品需求的变更，你需要上线几乎所有的服务，这个成本就有点高了。显而易见，如果我把用户的昵称功能单独部署成一个独立的服务，那么有什么变更我只需要上线这个服务即可，其他服务不受影响，开发和上线成本就大大降低了。</li><li>还有其他拆分的维度，比如说：<ul><li>业务的角度 </li><li>人员的角度  </li><li>架构的角度 </li><li>发展的角度</li></ul></li></ul><h6 id="1-1-2-微服务拆分的粒度"><a href="#1-1-2-微服务拆分的粒度" class="headerlink" title="1.1.2 微服务拆分的粒度"></a>1.1.2 微服务拆分的粒度</h6><ul><li>微服务拆分时需要考虑如下因素：</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207184254939.png" alt="image-20211207184254939"></p><h5 id="1-2-康威定律与微服务拆分"><a href="#1-2-康威定律与微服务拆分" class="headerlink" title="1.2 康威定律与微服务拆分"></a>1.2 康威定律与微服务拆分</h5><ul><li>康威定律第一定律<ul><li>设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207184908984.png" alt="image-20211207184908984"></p><p>​                                                                         马努.科内特的”组织架构图“</p><ul><li>微服务架构是一种非常流行的新概念，即便可供以借鉴的经验比较少，当然不能阻挡它成为热门话题与研究对象。令人惊讶地是，其实微服务的概念早在五十多年前就已经被提出，多年来，研究表明了这些观点的准确性。这就是本文所介绍的——康威定律。现在已经有很多企业正在尝试 使用它创建高效的微服务架构。</li><li>康威定律用通俗的说法就是：组织形式等同系统设计。</li><li>如上图所示，不同的公司采用了不同的组织结构</li></ul><ul><li><p>康威定律第二定律</p><ul><li><p>时间再多一件事也不可能做的完美，但总有时间做完一件事情</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207185728789.png" alt="image-20211207185728789"></p></li></ul></li><li><p>Eric Hollnagel是敏捷开发社区的泰斗之一，在他《Efficiency-Effectiveness Trade Offs》 一书 中解释了类似的论点</p><ul><li>Problem too complicated? Ignore details</li><li>Not enough resources?Give up features.</li></ul></li><li><p>系统越做越复杂，功能越来越多，外部市场的竞争越来越剧烈，投资人的期待越来越高。但人的智力是有上限的，即使能力再强的人，融到钱再多也不一定招到足够多合适的人。对于一个非常复杂的系统，我们永远无法考虑周全。Eric认为，这个时候最好的解决办法竟然是——“破罐子破摔”。</p></li><li><p>其实我们在日常开发中也经常碰到。产品经理的需求太复杂了？适当忽略一些细节，先抓主线。 产品经理的需求太多了？放弃一些功能。</p></li><li><p>对于一个分布式系统，我们几乎永远不可能找到并修复所有的bug，单元测试覆盖1000%也没有用，错误流淌在分布式系统的血液里。解决方法不是消灭这些问题，而是容忍这些问题，在问题发生时，能自动回复，微服务组成的系统，每一个微服务都可能挂掉，这是常态，我们只要有足够的冗余和备份即可。即所谓的弹性设计（Resilience） 或者叫高可用设计（High Availability）。</p></li></ul><ul><li><p>康威定律第三定律</p><ul><li><p>线型系统和线型组织架构间有潜在的异质同态特性</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207190149421.png" alt="image-20211207190149421"></p></li></ul></li><li><p>这是康威第一定律组织和设计间内在关系的一个具体应用。更直白的说，你想要什么样的系统， 就搭建什么样的团队。如果你的团队分成前端团队，Java后台开发团队，DBA团队，运维团队， 你的系统就会变成上图左边的样子。</p></li><li><p>相反，如果你的系统是按照业务边界划分的，大家按照一个业务目标去把自己的模块做出小系统， 小产品的话，你的大系统就会变成上图右边的样子，即微服务的架构。</p></li></ul><ul><li><p>康威定律第四定律</p><ul><li><p>大的系统组织总是比小的系统更倾向于分解</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207190509906.png" alt="image-20211207190509906"></p></li></ul></li><li><p>前面说了，人是复杂的社会动物，人与人的通过非常复杂。但是当我们面对复杂系统时，又往往只能通过增加人力来解决。这时，我们的组织一般是如何解决这个沟通问题的呢？Divide and conquer,分而治之。大家看看自己的公司的组织，是不是一个一线经理一般都是管理15个人以下的？二线经理再管理更少的一线？三线再管理更少的，以此类推。（这里完全没有暗示开发经理比开发工程师更难管理）</p></li></ul><ul><li><p>康威定律总结</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207190808861.png" alt="image-20211207190808861"></p></li><li><p>了解了康威定律是什么，再来看看他如何在半个世纪前就奠定了微服务架构的理论基础。</p><ul><li>再对应下衡量微服务的标准，我们很容易会发现他们之间的密切关系：<ul><li>分布式服务组成的系统</li><li>按照业务而不是技术来划分组织</li><li>做有生命的产品而不是项目</li><li>Smart endpoints and dumb pipes（我的理解是强服务个体和弱通信）</li><li>自动化运维（DevOps）</li><li>容错</li><li>快速演化</li></ul></li></ul></li></ul><h4 id="第二章-DDD与微服务拆分"><a href="#第二章-DDD与微服务拆分" class="headerlink" title="第二章 DDD与微服务拆分"></a>第二章 DDD与微服务拆分</h4><h5 id="2-1-微服务与DDD"><a href="#2-1-微服务与DDD" class="headerlink" title="2.1 微服务与DDD"></a>2.1 微服务与DDD</h5><h6 id="2-1-1-如何建模微服务"><a href="#2-1-1-如何建模微服务" class="headerlink" title="2.1.1 如何建模微服务"></a>2.1.1 如何建模微服务</h6><ul><li><p><strong>什么样的微服务是设计良好的微服务</strong></p><ul><li><p>松耦合</p><ul><li>如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。使用微服务最重要的一点是能够独立修改及部署单个服务而不需要修改系统的其它部分。</li></ul></li><li><p>高内聚</p><ul><li>我们希望把相关的行为聚集在一起，把不相关的行为放在别处。为什么呢？因为如果你要改变某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快地发布。如果需要在很多不同的地方做这些修改，那么可能就需要同时发布多个微服务才能交付这个功能。在多个不同的地方进行修改会很慢，同时部署多个服务风险也很高，这两者都是我们想要避免的。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207193957597.png" alt="image-20211207193957597"></p></li></ul></li><li><p>比如我们要设计一个电商系统，可以按照功能分成库存、订单、商品这几个服务，每个服务之间利用HTTP请求的方式通信，当一个服务重写或者重构后只要保持接口的一致性是不会影响其他服务的逻辑的，我们就说这几个服务是松耦合的。</p></li></ul><ul><li><p><strong>微服务设计和拆分的困境</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207194709364.png" alt="image-20211207194709364"></p></li><li><p>进入微服务架构时代以后，微服务确实也解决了原来采用集中式架构的单体应用的很多问题，比如扩展性、弹性伸缩能力、小规模团队的敏捷开发等等。</p></li><li><p>但是看到这些好处的同时，微服务实践过程中也产生了不少的争论和疑惑；微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？如何保持业务和系统的一致性</p></li><li><p>可以说，很久以来都没有一套系统的理论和方法可以指导微服务的拆分，包括微服务架构模式的提出者Martin fowler在提出微服务架构的时候，也没有告诉我们究竟应该如何拆分微服务。</p></li><li><p>那么如何拆分微服务，是否有相关理论或知识体系支撑呢？答案是肯定的，其中最主要的一种方法论就是<strong>DDD-领域驱动设计</strong>。</p></li></ul><ul><li><p><strong>微服务拆分中最重要的步骤</strong></p><ul><li><p>限界上下文，限界上下文确定了微服务的边界</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207195420039.png" alt="image-20211207195420039"></p></li></ul></li><li><p>EricEvans的《领域驱动设计》一书主要专注于如何对现实世界的领域进行建模。该书中有很多非常棒的想法，比如通用语言、仓储、抽象等。其中Evans引入的一个很重要的概念是限界上下文（bounded context）。他认为任何一个给定的领域都包含多个限界上下文，每个限界上下文中的东西（Eric Evans更常使用模型这个词，应该比”东西“好”得多）分成两部分，一部分不需要与外部通信，另一部分则需要。每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他的上下文。</p></li><li><p>限界上下文强调显示的边界。如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。在这本书中，<strong>Evans使用细胞作比喻；“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。”</strong></p></li><li><p>有时候，同一个名字在不同的上下文中有着往前不同的含义。比如，退货表示的是客户退回的一些东西，在客户的上下文中，退货意味着填写邮寄信息、寄送包裹，然后等待退款。在仓库的上下文中，退货表示的是一个即将到来的包裹，而且这个包裹会重新入库。退货这个概念会与将要执行的任务相关，比如我们可能会发起一个重新入库的请求。这个退货的共享模型会在多个不同的进程中使用，并且在每个限界上下文中都会存在相应的实体，不过，这些实体仅仅是在每个山下文内部表示而已。再举个例子，比如电商里面的商品，在销售阶段是商品，在运输阶段是货物，用户使用起来是工具。</p></li></ul><h6 id="2-1-2-DDD介绍"><a href="#2-1-2-DDD介绍" class="headerlink" title="2.1.2 DDD介绍"></a>2.1.2 DDD介绍</h6><ul><li><p>DDD（领域驱动设计）是一种设计方法，围绕业务概念构建领域模型，并通过分离技术实现的复杂性，从而控制软件演化的复杂度。领域驱动设计解决的两个核心问题是：</p><ol><li>业务架构如何合理的设计划分？</li><li>技术架构与业务架构如何保持一致？</li></ol></li></ul><h6 id="2-1-3-DDD与微服务的关系"><a href="#2-1-3-DDD与微服务的关系" class="headerlink" title="2.1.3 DDD与微服务的关系"></a>2.1.3 DDD与微服务的关系</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207201337952.png" alt="image-20211207201337952"></p><ul><li>DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力， 也就是我们常说的演进式架构。</li><li><strong>DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象， 建立领域模型，维持业务和代码的逻辑一致性。</strong></li><li><strong>微服务主要关注：</strong>运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</li><li><strong>通过DDD战略设计可以建立领域模型，划定领域边界，解决微服务设计过程中，边界难以划定的难题</strong>。如果你的业务焦点在领域和领域逻辑，那么你就可以选择DDD作为微服务的设计方法！</li></ul><h6 id="2-1-4-DDD建模微服务的两个阶段"><a href="#2-1-4-DDD建模微服务的两个阶段" class="headerlink" title="2.1.4 DDD建模微服务的两个阶段"></a>2.1.4 DDD建模微服务的两个阶段</h6><p>![image-20211208095538050](/Users/mike/Library/Application Support/typora-user-images/image-20211208095538050.png)</p><ul><li><p>战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文， 限界上下文可以作为微服务设计的参考边界。</p><ul><li>DDD 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。事件风暴是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用用例分析、场景分析和用户旅程分析，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。</li></ul></li><li><p>战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、 实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</p></li><li><p><strong>DDD 之战略设计</strong></p><ul><li><p>通过战略设计得到的领域及限界上下文</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208100411806.png" alt="image-20211208100411806"></p></li></ul></li></ul><ul><li><p><strong>DDD 之战术设计</strong>：从技术角度出发</p><ul><li><p>侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208100733569.png" alt="image-20211208100733569"></p></li></ul></li></ul><h6 id="2-1-5-DDD的优势"><a href="#2-1-5-DDD的优势" class="headerlink" title="2.1.5 DDD的优势"></a>2.1.5 DDD的优势</h6><ul><li>领域驱动设计的优势<ul><li>业务导向</li><li>业务逻辑内聚，应用边界清晰</li><li>建立领域模型优先</li><li>分析、设计、代码和数据有机结合</li><li>代码即设计</li><li>扩展性好</li></ul></li></ul><h5 id="2-2-DDD核心概念"><a href="#2-2-DDD核心概念" class="headerlink" title="2.2 DDD核心概念"></a>2.2 DDD核心概念</h5><ul><li>关于领域：研究对象<ul><li>子域：<ul><li>核心域：核心子域</li><li>通用域：被多个子域使用的通用功能子域</li><li>支撑域：其它子域</li></ul></li></ul></li><li>在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。</li><li>决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。</li><li>这三类子域相较之下，核心域是最重要的，我们下面讲目的的时候还会以核心域为例详细介绍。 通用域和支撑域如果对应到企业系统，举例来说的话，通用域则是你需要用到的通用系统，比如认证、权限等等，这类应用很容易买到，没有企业特点限制，不需要做太多的定制化。而支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统。</li><li>总结来说，领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而<strong>领域模型映射成系统就是微服务了</strong>。</li><li>核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。</li><li>以电商场景为例，这里电商即是我们研究的领域<ul><li>核心域</li><li>通用域</li><li>支撑域</li></ul></li><li>子域的划分本质上是公司战略方向的体现</li></ul><h5 id="2-2-DDD核心概念-（续）"><a href="#2-2-DDD核心概念-（续）" class="headerlink" title="2.2 DDD核心概念 （续）"></a>2.2 DDD核心概念 （续）</h5><ul><li>在 DDD 领域建模和系统建设过程中，有很多的参与者，包括领域专家、产品经理、项目经理、 架构师、开发经理和测试经理等。对同样的领域知识，不同的参与角色可能会有不同的理解，那大家交流起来就会有障碍，怎么办呢？因此，在 DDD 中就出现了“通用语言”和“限界上下文” 这两个重要的概念。</li><li>这两者相辅相成，通用语言定义上下文含义，限界上下文则定义领域边界，以确保每个上下文含义在它特定的边界内都具有唯一的含义，领域模型则存在于这个边界之内。</li><li>关于通用语言<ul><li>在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。也就是说，通用语言是团队统一的语言，不管你在团队中承担什么角色， 在同一个领域的软件生命周期里都使用统一的语言进行交流。</li><li>那么，通用语言的价值也就很明了了，它可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。</li><li>通用语言包含术语和用例场景，并且能够直接反映在代码中。通用语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令。</li></ul></li><li>关于限界上下文<ul><li>为了避免同样的概念或语义在不同的上下文环境中产生歧义，DDD 在战略设计上提出了“限 界上下文”这个概念，用来确定语义所在的领域边界。</li></ul></li></ul><h5 id="2-2-DDD核心概念-（续）-1"><a href="#2-2-DDD核心概念-（续）-1" class="headerlink" title="2.2 DDD核心概念 （续）"></a>2.2 DDD核心概念 （续）</h5><ul><li>关于实体<ul><li>拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。</li></ul></li><li>关于值对象<ul><li>通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208104144154.png" alt="image-20211208104144154"></p><ul><li>实体值对象Entities Value Objects：在一个软件系统中，实体表示哪些具有生命周期并且会在其生命周期中发生改变的东西；而值对象则表示起描述性作用的并且可以相互替换的概念。</li><li>在 DDD 不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、 操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，<strong>实体和值对象是组成领域模型的基础单元</strong>。</li><li>实体<ul><li>在 DDD 中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持 一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。</li></ul></li><li>值对象：<ul><li>《实现领域驱动设计》一书中对值对象的定义：通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。 </li><li>如上图所示：人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等 属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了。</li></ul></li><li>实体和值对象的关系<ul><li>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。值对象和实体在某些场景下可以互换，很多 DDD 专家在这些场景下，其实也很难判断到底将领域对象设计成实体还是值对象？可以说，值对象在某些场景下有很好的价值，但是并不是所有的场景都适合值对象。你需要根据团队的设计和开发习惯，以及上面的优势和局限分析， 选择最适合的方法。</li></ul></li></ul><h5 id="2-2-DDD核心概念-（续）-2"><a href="#2-2-DDD核心概念-（续）-2" class="headerlink" title="2.2 DDD核心概念 （续）"></a>2.2 DDD核心概念 （续）</h5><ul><li>在 DDD 中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力。</li><li>关于聚合<ul><li>域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</li></ul></li><li>关于聚合根<ul><li>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。</li></ul></li><li>如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体， 还是聚合的管理者。</li><li>以电商为例：<ul><li>电商里面比较典型的几个聚合根，比如：库存、商品、订单等等。以订单为例，订单在聚合里是聚合根，与订单关联的有订单明细和收货地址。订单明细包括商品ID,商品名称，价格以及数量等信息，由于订单明细是多个，它是一个集合，它被设计为实体，被订单引用。而订单只有一个收货地址，这个收货地址的值来源于你个人中心维护的收货地址，收货地址只能被整体替换，所以它被设计为值对象。</li></ul></li></ul><h5 id="2-3-DDD实践流程"><a href="#2-3-DDD实践流程" class="headerlink" title="2.3 DDD实践流程"></a>2.3 DDD实践流程</h5><ul><li><p>如何落地DDD？</p><ul><li>事件风暴[Event Storming]是一种快速探索复杂业务领域的方法</li></ul></li><li><p>事件风暴有如下特征</p><ul><li><p>Effective：可以让实践者在数小时内理解复杂业务模型</p></li><li><p>Engaging：带着问题的和拥有答案的人一起来构建模型</p></li><li><p>Efficient：能快速发现限界上下文以及相关的聚合根等</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208111851277.png" alt="image-20211208111851277"></p></li></ul></li><li><p>事件风暴是一项团队活动，领域专家与项目团队通过头脑风暴的形式，罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合，然后对每一个事件，标注出导致该事件的命令，再为 每一个事件标注出命令发起方的角色。命令可以是用户发起，也可以是第三方系统调用或者定时器触发等，最后对事件进行分类，整理出实体、聚合、聚合根以及限界上下文。而事件风暴正是 DDD 战略设计中经常使用的一种方法，它可以快速分析和分解复杂的业务领域，完成领域建模。</p></li><li><p>事件风暴需要准备些什么</p></li><li><p>产品愿景:产品愿景的主要目的是对产品顶层价值的设计，使产品目标用户、核心价值、差异化竞争点等信息达成一致，避免产品偏离方向。</p><ul><li>产品愿景的参与角色：领域专家、业务需求方、架构师和开发经理。</li><li>在建模之前，项目团队要思考这些点：</li><li>这个过程也是明确用户中台建设方向和统一团队思想的过程。参与者要对每一个点（发表意见，用水笔写在贴纸上，贴在黄色贴纸的位置。这个过程会让参与者充分发表意见，最后会将发散的意见统一为通用语言，建立产品愿景墙。如果你的团队的产品愿景和目标已经很清晰了，那这个步骤你可以忽略。</li></ul></li></ul><h5 id="2-3-DDD实践流程-（续）"><a href="#2-3-DDD实践流程-（续）" class="headerlink" title="2.3 DDD实践流程 （续）"></a>2.3 DDD实践流程 （续）</h5><ul><li><p>如何使用事件风暴</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208113548173.png" alt="image-20211208113548173"></p></li><li><p>统一语言（也叫通用语言）：定义业务和技术之间沟通的专用术语，避免产生歧义</p></li><li><p>业务流程梳理：领域专家介绍业务，参与者可以任意提问，大家在理解业务的基础上梳理出业务流。</p></li><li><p>寻找事件：任何的业务都会以数据的形式留下足迹。我们对于数据的追溯可以通过对事件的追溯来完成。当把这些事件按照时间顺序排列起来，几乎可以清晰的推测出在过往的一段时间内到底 发生了什么数据变化。</p></li><li><p>寻找命令：命令代表了外部系统或者用户触发的动作、以及内部的定时行为</p></li><li><p>寻找聚合：寻找业务中的关键事件</p></li><li><p>划分子域&amp;界限</p></li><li><p><strong>最后得到的限界上下文约等于微服务</strong></p></li></ul><h5 id="2-4-DDD案例解析"><a href="#2-4-DDD案例解析" class="headerlink" title="2.4 DDD案例解析"></a>2.4 DDD案例解析</h5><ul><li><p>我们以腾讯云课程报名为例，通过DDD构建领域模型。在这个业务中不同用户的需求。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208113949162.png" alt="image-20211208113949162"></p></li><li><p>通过事件风暴理清需求，快速探索业务领域</p></li></ul><h6 id="2-4-1-用户访谈"><a href="#2-4-1-用户访谈" class="headerlink" title="2.4.1 用户访谈"></a>2.4.1 用户访谈</h6><ul><li>通过用户访谈，了解当前的业务流程：</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208114051727.png" alt="image-20211208114051727"></p><ul><li>总结核心的业务问题，识别子领域，限界上下文就是子领域功能和模型的边界。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208114146782.png" alt="image-20211208114146782"></p><h6 id="2-4-2-进行领域建模"><a href="#2-4-2-进行领域建模" class="headerlink" title="2.4.2 进行领域建模"></a>2.4.2 进行领域建模</h6><ul><li><p>排课领域-建模</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208122505589.png" alt="image-20211208122505589"></p></li><li><p>报名缴费领域-建模</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208155038765.png" alt="image-20211208155038765"></p></li></ul><ul><li><p>课程评价领域-建模</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208155924913.png" alt="image-20211208155924913"></p></li></ul><ul><li><p>进行上下文映射</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208160127228.png" alt="image-20211208160127228"></p></li></ul><h4 id="第三章-微服务设计实战"><a href="#第三章-微服务设计实战" class="headerlink" title="第三章 微服务设计实战"></a>第三章 微服务设计实战</h4><h5 id="3-1-微服务设计实战介绍"><a href="#3-1-微服务设计实战介绍" class="headerlink" title="3.1 微服务设计实战介绍"></a>3.1 微服务设计实战介绍</h5><h6 id="3-1-1-微服务的拆分应该考虑哪些方面"><a href="#3-1-1-微服务的拆分应该考虑哪些方面" class="headerlink" title="3.1.1 微服务的拆分应该考虑哪些方面"></a>3.1.1 微服务的拆分应该考虑哪些方面</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208160334965.png" alt="image-20211208160334965"></p><h6 id="3-1-2-微服务设计实战流程"><a href="#3-1-2-微服务设计实战流程" class="headerlink" title="3.1.2 微服务设计实战流程"></a>3.1.2 微服务设计实战流程</h6><ul><li><p>微服务设计实战流程如下所示：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208160438048.png" alt="image-20211208160438048"></p></li></ul><h5 id="3-2-微服务拆分流程"><a href="#3-2-微服务拆分流程" class="headerlink" title="3.2 微服务拆分流程"></a>3.2 微服务拆分流程</h5><ul><li><p>战略设计：从业务视角出发</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208160850054.png" alt="image-20211208160850054"></p><ul><li><p>通过事件风暴从错综复杂的业务领域中分析并构建领域模型，划分领域边界。建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208160706518.png" alt="image-20211208160706518"></p></li><li><p>事件风暴是一项团队活动，领域专家与项目团队通过头脑风暴的形式，罗列出领域中所有的领域事件，整合之后形成最终的领域事件集合，然后对每一个事件，标注出导致该事件的命令，再为 每一个事件标注出命令发起方的角色。命令可以是用户发起，也可以是第三方系统调用或者定时器触发等，最后对事件进行分类，整理出实体、聚合、聚合根以及限界上下文。而事件风暴正是 DDD 战略设计中经常使用的一种方法，它可以快速分析和分解复杂的业务领域，完成领域建模。</p></li></ul></li><li><p><strong>战术设计：从技术角度出发，将战略设计的结果落地</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211208161102156.png" alt="image-20211208161102156"></p></li></ul><h5 id="3-3-小组讨论"><a href="#3-3-小组讨论" class="headerlink" title="3.3 小组讨论"></a>3.3 小组讨论</h5><ul><li>规则<ul><li>每4名学员一组</li><li>每组构想一个业务场景</li><li>利用DDD战略设计对业务场景进行领域建模，确定限界上下文</li><li>根据限界上下文确定微服务系统的形态</li><li>小组合作开发完成微服务</li><li>将开发完成的微服务部署到TSF平台</li><li>对微服务镜像服务治理和运维的操作</li></ul></li><li>分小组进行微服务设计实战</li></ul><h5 id="3-4-汇报总结"><a href="#3-4-汇报总结" class="headerlink" title="3.4 汇报总结"></a>3.4 汇报总结</h5><ul><li>汇报内容<ul><li>业务场景介绍</li><li>微服务拆分过程介绍</li><li>微服务展示</li></ul></li><li>成果汇报</li></ul><h4 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h4><ul><li>本文主要讲述了如下内容：<ul><li>康威定律和微服务</li><li>DDD介绍</li><li>利用DDD思想拆分微服务</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>十三、微服务设计的原则及价值</title>
    <link href="/2021/12/06/%E5%8D%81%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%E5%8F%8A%E4%BB%B7%E5%80%BC/"/>
    <url>/2021/12/06/%E5%8D%81%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%E5%8F%8A%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="十三、微服务设计的原则及价值"><a href="#十三、微服务设计的原则及价值" class="headerlink" title="十三、微服务设计的原则及价值"></a>十三、微服务设计的原则及价值</h3><ul><li>前面已经介绍了TSF的基本功能以及使用，接下来我们再回到微服务上面来；</li><li> 微服务的粒度是难点，也常常是争论的焦点。应当使用合理的粒度划分微服务，而不是一味将服务做小。代码量的多少不能作为微服务划分的依据，因为不同的服务本身的业务复杂性不同，代码量也不同。在微服务的设计阶段，就应确定其边界。微服务之间应该相对独立并保持松耦合。接下来我们看一下基于TSF的微服务设计的原则及价值。</li></ul><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>了解微服务的设计目标</li><li>掌握微服务的设计原则</li><li>了解微服务化带来的价值</li></ul><h4 id="第一章-微服务的设计目标"><a href="#第一章-微服务的设计目标" class="headerlink" title="第一章 微服务的设计目标"></a>第一章 微服务的设计目标</h4><h5 id="1-1-微服务的设计目标"><a href="#1-1-微服务的设计目标" class="headerlink" title="1.1 微服务的设计目标"></a>1.1 微服务的设计目标</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206183056817.png" alt="image-20211206183056817"></p><ul><li>微服务架构是一种架构模式，将单体应用划分为一组服务，服务之间互相协作，为用户提供最终价值</li><li>每个服务运行在其独立的进程中，服务间采用轻量级的通信机制协作（通常是基于RESTful API）</li><li>每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206183412125.png" alt="image-20211206183412125"></p><ul><li>设计和交付：要做到标志化，把应用拆分成独立的小服务，持续部署，通过自动化工具减少重复工作量，提供工作效率，让开发人员有更多的时间关注业务，以业务为中心。</li><li>系统架构原则：<ul><li>减少惯性思维，迅速做出有利于自己的选择反馈，减少团队间的依赖；</li><li>消除偶然的复杂性，替换不必要的复杂过程、系统和集成，以便我们能够集中精力于问题的本质；</li><li>一致的接口和数据流消除重复的数据和创建清晰的记录系统，具有一致的集成接口；</li><li>没有银弹，现成的解决方案提前交付有价值，但会产生惰性和偶然的复杂性；</li></ul></li><li>战略目标：最终打造可扩展的弹性业务系统，助力产业在新领域扩展，在已有市场业务中，不断创新保持领先身位。</li></ul><h4 id="第二章-微服务的设计原则"><a href="#第二章-微服务的设计原则" class="headerlink" title="第二章 微服务的设计原则"></a>第二章 微服务的设计原则</h4><h5 id="2-1-微服务的设计原则简介"><a href="#2-1-微服务的设计原则简介" class="headerlink" title="2.1 微服务的设计原则简介"></a>2.1 微服务的设计原则简介</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206184116810.png" alt="image-20211206184116810"></p><ul><li><strong>业务领域蓝图</strong>：告诉我们的最大价值我觉得是，当我们要开发一个系统时，应该尽量先把领域模型想清楚，然后再开始动手编码，这样的系统后期才会很好维护。</li><li><strong>全维度可视化</strong>：从不同维度实现可视化，如TSF中提供了服务拓扑，服务监控，调用链等</li><li><strong>全流程自动化</strong>：自动化一切可以自动化的，降低部署和发布的难度</li><li><strong>容错设计</strong>：自动化容错设计，如熔断器，集群</li><li><strong>去中心化设计</strong>：提供服务的扩展能力</li><li><strong>独立部署</strong>：服务可以独立部署</li></ul><h5 id="2-2-TSF与微服务设计原则"><a href="#2-2-TSF与微服务设计原则" class="headerlink" title="2.2 TSF与微服务设计原则"></a>2.2 TSF与微服务设计原则</h5><ul><li>基于微服务设计原则的TSF平台介绍<ul><li>TSF与全维度可视化</li><li>TSF与全流程自动化（devops）</li><li>TSF与微服务容错设计</li><li>TSF与微服务去中心化设计</li><li>TSF与平台去中心化设计</li><li>TSF与独立部署</li></ul></li><li>接下来看一下在TSF中体现的微服务设计原则</li></ul><h6 id="2-2-1-TSF与全维度可视化"><a href="#2-2-1-TSF与全维度可视化" class="headerlink" title="2.2.1 TSF与全维度可视化"></a>2.2.1 TSF与全维度可视化</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206185508126.png" alt="image-20211206185508126"></p><ul><li>调用链查询用来查询和定位具体某一次调用的情况。使用者可以通过具体的服务、接口定位、IP等来查询具体的调用过程，查找调用过程所需要的时间和运行情况。</li><li>通过调用链详情，可以根据TraceID查询调用链的详细信息。调用链详情是为了定位在分布式链路调用过程中每个环节的耗时和异常（不包含本地方法调用情况，本地方法调用建议使用业务Log的方式记录）。</li><li>通过调用链通常为了解决如下几个问题：<ul><li>定位耗时较长的服务</li><li>不合理的调用逻辑（如一次请求多次调用某服务，建议改为批量调用接口）</li></ul></li></ul><h6 id="2-2-1-TSF与全维度可视化（续）"><a href="#2-2-1-TSF与全维度可视化（续）" class="headerlink" title="2.2.1 TSF与全维度可视化（续）"></a>2.2.1 TSF与全维度可视化（续）</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206190038009.png" alt="image-20211206190038009"></p><ul><li>可以再服务治理中通过服务拓扑图中的颜色块区别正常与异常访问的请求，通过可视化，具体日志方式可以方便快速的定位问题点</li></ul><h6 id="2-2-2-TSF与DevOps"><a href="#2-2-2-TSF与DevOps" class="headerlink" title="2.2.2 TSF与DevOps"></a>2.2.2 TSF与DevOps</h6><ul><li><p>DevOps整体结构及业界生态<img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206191050177.png"></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206191317766.png" alt="image-20211206191317766"></p></li><li><p>TSF打通了从微服务开发到部署的整个流程，同时整个流程借助自动化工具实现了持续集成，持续发布到持续运营的目的。真正打通了DevOps的闭环生态</p></li><li><p>DevOps是一个完整的面向IT运维的工作流，以IT自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。</p></li><li><p>DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。</p></li><li><p>换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。专家们总结出了DevOps能力图（如图1），良好的闭环可以大大增加整体的产出。</p></li></ul><h6 id="2-2-2-TSF与DevOps（续）"><a href="#2-2-2-TSF与DevOps（续）" class="headerlink" title="2.2.2 TSF与DevOps（续）"></a>2.2.2 TSF与DevOps（续）</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206191620833.png" alt="image-20211206191620833"></p><ul><li><p>在TSF中把基础框架构建全部通过自动化框架代码生成，开发人员只需要引入代码就可以快速完成基础框架代码构建，让开发人员更多的关注业务</p></li><li><p>测试过程中，把单元测试，集成测试。回归测试等通过自动化测试工具完成，同时实现灰度发布，自动回滚功能，相比原有传统方式大大减少了工作量。</p></li></ul><h6 id="2-2-3-TSF与微服务容错设计"><a href="#2-2-3-TSF与微服务容错设计" class="headerlink" title="2.2.3 TSF与微服务容错设计"></a>2.2.3 TSF与微服务容错设计</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206192033950.png" alt="image-20211206192033950"></p><ul><li><p>优雅的服务降级：微服务架构的最大优点之一是您可以隔离故障，并在当组件单独故障时，进行优雅的服务降级。例如，在中断期间，照片共享应用程序中的客户可能无法上传新图片，但仍可以浏览、编辑和共享其现有照片。</p></li><li><p>变更管理：在微服务架构中，服务依赖于彼此。要处理变更中的问题，您可以实施变更管理策略和自动回滚机制。</p></li><li><p>健康检查与负载均衡：实例由于出现故障、部署或自动缩放的情况，会进行持续启动、重新启动或停止操作。它可能导致它们暂时或永久不可用。为避免问题，您的负载均衡器应该从路由中跳过不仅阿卡的实例，应用实例健康状况可以通过外部观察来确定。您可以通过重复调用GET/health端点或通过自我报告来实现。现在主流的服务发现解决方案，会持续从实例中收集健康信息，并配置负载均衡器，将流量仅路由到健康的组件上。</p></li><li><p>自我修复：可以帮助应用程序从错误中恢复过来。当应用程序可以采取必要步骤从故障状态恢复时，我们就可以说它是可以实现自我修复的</p></li><li><p>舱壁模式：工业中使用舱壁将船舶划分为几个部分，以便在船体破坏的情况下，可以将船舶各个部件密封起来；船壁的概念在软件开发中可以被应用在隔离资源上</p></li><li><p>测试故障：利用ChaosMonkey（混乱猴子）技术进行混沌工程，经常测试故障，让您的团队具备故障处理的能力</p></li><li><p>ChaosMonkey（混乱猴子）</p><ul><li>该技术以在生产环境中随机关闭服务节点而“恶名远扬”，这就是目前熟知的混沌工程的早期雏形。《Chaos Engineering》书中是这样描述的：<ul><li>混乱猴子的美妙之处就在于此，它能尽可能地将服务节点失效的痛苦的提到最前，同时让所有工程师在构建一个具有足够弹性应对失败的系统上，达成一个一致的目标。</li><li>混乱猴子的灵感来自于Netflix几年前搬迁上云的过程，主要是为了解决该阶段暴露的问题，然而，目前不少企业的上云进程依旧缓慢，这种状态下是否还需要混沌工程？随着软件的测试流程越来越成熟且完善，是否有必要花费精力搞混沌工程？如果需要，这一领域有哪些开源工具可供快速部署实践？</li></ul></li></ul></li><li><p>混沌工程：混沌工程师在分布式系统上镜像实验的学科，目的是建立对系统抵御生产环境中失控条件的能力以及信心。</p><ul><li>这句话同样出自《Chaos Engineering》，粗看起来，这一含义有些晦涩难懂。如果简单概况下，周洋对混沌工程的理解是如下四点：<ol><li>一种拥抱失败的技术文化</li><li>一套抽象严谨的实践原则</li><li>一种主动防御的稳定性手段</li><li>一个高速发展的技术领域</li></ol></li></ul></li><li><p>故障转移缓存：由于网络问题和我们系统的变化，服务经常会失败。然而，由于自我修复和负载均衡的保障，它们中的大多数中断是临时的，我们应该找到一个解决方案，使我们的服务在这些故障时服务仍旧可以工作。这就是故障转移缓存的作用，它可以帮助并为我们的应用程序在服务故障时提供必要的数据。</p></li><li><p>重试逻辑：在某些情况下，我们无法缓存数据，或者我们相对其进行更改，但是我们的操作最终都失败了。对于此，我们可以重试我们的操作，因为我们可以预期资源将在一段时间后恢复，或者我们的负载均衡器将请求发送到了健康的实例上。</p></li><li><p>限流器和负载降级：通过流量限制，您可以过滤掉造成流量峰值的服务，或者您可以确保您的应用程序在自动缩放无法满足时，依然不会超载。</p></li><li><p>快速失败原则与独立性：在微服务中通过使用超时来达到快速失败的效果是一种反模式的，你应该避免使用它。取而代之，您可以应用断路器模式，依据操作的成功与失败统计数据决定。</p></li><li><p>断路器：当特定类型的错误在短时间内多次发生时，断路器会被断开。开路的断路器可以防止进一步的请求-就像我们平时所说的电路跳闸一样。断路器通常在一定时间后关闭，在这期间可以为底层服务提供足够的空间来恢复。</p></li></ul><h6 id="2-2-3-TSF与微服务容错设计（续）"><a href="#2-2-3-TSF与微服务容错设计（续）" class="headerlink" title="2.2.3 TSF与微服务容错设计（续）"></a>2.2.3 TSF与微服务容错设计（续）</h6><ul><li>微服务架构的最大优点之一是用户可以隔离故障，并在当组件单独故障时，进行优雅的服务降级。</li><li>故障转移缓存通常使用两个不同的过期日期；较短的时间告诉您在正常情况下缓存可以使用的过期时间，而较长的时间可以再服务故障时缓存依旧可用的过期时间。</li></ul><p>![image-20211207110224314](/Users/mike/Library/Application Support/typora-user-images/image-20211207110224314.png)</p><ul><li>当特定类型的错误在短时间内多次发生时，断路器会被断开。开路的断路器可以防止进一步的请求-就像我们平时所说的电路跳闸一样。断路器通常在一定时间后关闭，在这期间可以为底层服务提供足够的空间来恢复。    </li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207112934307.png" alt="image-20211207112934307"></p><ul><li>第一种类型我们以排行榜单为例，比如对王者荣耀的排行榜单数据进行缓存。同一份榜单数据我们设置两份缓存，第一份缓存数据设置为一分钟后过期，第二份数据设置为一个小时后过期。这样在第二分钟到一个小时的时间内，如果存储第一份缓存数据的服务器挂掉后，我们可以直接使用第二份缓存，从而屏蔽故障。</li><li>第二种类型以电商为例，当电商后台的数据库发生故障时，我们可以设置断路，这样就不会有新的或者重复的请求进入后端的业务系统。</li><li>TSF平台提供服务注册中心，健康检查，负载均衡，失败重试，服务限流，断路器，配置管理等手段实现容错设计，让服务高可用。</li></ul><h6 id="2-2-4-TSF与微服务去中心化设计"><a href="#2-2-4-TSF与微服务去中心化设计" class="headerlink" title="2.2.4 TSF与微服务去中心化设计"></a>2.2.4 TSF与微服务去中心化设计</h6><ul><li><p>基于目前业界最常见的三种开发方式，提供基于腾讯TSF的演进方案</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207114955977.png" alt="image-20211207114955977"></p></li><li><p>原生SpringCloud， SpringBoot，Dubbo应用可以快速改造成TSF的模式，帮助原生应用快速实现去中心化设计。</p></li></ul><h6 id="2-2-4-TSF与微服务去中心化设计（续）"><a href="#2-2-4-TSF与微服务去中心化设计（续）" class="headerlink" title="2.2.4 TSF与微服务去中心化设计（续）"></a>2.2.4 TSF与微服务去中心化设计（续）</h6><ul><li><p>架构理念的变化</p><ul><li><p>微服务过程中，架构理念由面向系统结构转为面向服务设计</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207115313875.png" alt="image-20211207115313875"></p></li></ul></li><li><p>首先在架构上由原来的面向系统结构转变为面向服务的设计方式：</p><ul><li>在原来的架构中，销售系统的UI和业务逻辑高耦合</li><li>在微服务化后，各类业务系统的UI层尽管不同却可以最大化的复用现有的逻辑。</li></ul></li><li><p>业务流程的变化</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207120620303.png" alt="image-20211207120620303"></p></li><li><p>业务流程方面也有传统的外包模式业务转变为微服务业务流程，基于业务领域设计原则，提供代码复用能力，让企业更多的关注新业务；</p></li></ul><h6 id="2-2-5-TSF与独立部署"><a href="#2-2-5-TSF与独立部署" class="headerlink" title="2.2.5 TSF与独立部署"></a>2.2.5 TSF与独立部署</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207120928168.png" alt="image-20211207120928168"></p><ul><li>微服务TSF平台在发布部署过程中基于部署组维度镜像服务路由，完成不停服的灰度发布。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207121115345.png" alt="image-20211207121115345"></p><ul><li>TSF同时支持虚拟机部署以及容器部署方式，应用以微服务形式开发，可以再TSF中独立部署。</li></ul><h4 id="第三章-微服务架构最佳实践"><a href="#第三章-微服务架构最佳实践" class="headerlink" title="第三章 微服务架构最佳实践"></a>第三章 微服务架构最佳实践</h4><h5 id="3-1-微服务调用中的安全架构"><a href="#3-1-微服务调用中的安全架构" class="headerlink" title="3.1 微服务调用中的安全架构"></a>3.1 微服务调用中的安全架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207143124417.png" alt="image-20211207143124417"></p><h5 id="3-2-微服务最佳实践-技术架构"><a href="#3-2-微服务最佳实践-技术架构" class="headerlink" title="3.2  微服务最佳实践-技术架构"></a>3.2  微服务最佳实践-技术架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207152537773.png" alt="image-20211207152537773"></p><h5 id="3-3-分层微服务架构-组件最佳实践"><a href="#3-3-分层微服务架构-组件最佳实践" class="headerlink" title="3.3 分层微服务架构-组件最佳实践"></a>3.3 分层微服务架构-组件最佳实践</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207152659921.png" alt="image-20211207152659921"></p><ul><li>本案例是一个电商的场景，核心业务可以拆分为：在线卖场、订单、会员和购物卡这几个微服务</li><li>对于通用的能力如安全认证，国际化等组件可以封装到公共基础应用微服务中</li><li>在公共服务层可以搭建分布式消息队列，全文索引，认证模块等</li></ul><h5 id="3-4-TSF的能力图"><a href="#3-4-TSF的能力图" class="headerlink" title="3.4 TSF的能力图"></a>3.4 TSF的能力图</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207153224564.png" alt="image-20211207153224564"></p><h4 id="第四章-微服务的实践案例"><a href="#第四章-微服务的实践案例" class="headerlink" title="第四章 微服务的实践案例"></a>第四章 微服务的实践案例</h4><h5 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207153410000.png" alt="image-20211207153410000"></p><ul><li><p>背景介绍：2018年某地海关实行关检合并，将原先的出入境检验和海关通关进行合并，统一交由海关侧执行，实现”三个一“模式，即”一次申报“，”一次查验“，”一次放行“</p><ul><li><p>压缩货物通关环节</p></li><li><p>提升通关效率</p></li><li><p>降低企业成本</p></li><li><p>实现信息公开</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207153914820.png" alt="image-20211207153914820"></p></li></ul></li></ul><h6 id="4-1-1-用户痛点和需求"><a href="#4-1-1-用户痛点和需求" class="headerlink" title="4.1.1 用户痛点和需求"></a>4.1.1 用户痛点和需求</h6><ul><li><p> 痛点和需求：关检合并，不仅仅是简单的系统打通和改造，同时带来的是流程的合并和数据的打通，将出入境检验和海关通关相关的系统数据进行合并和标准化。</p></li><li><p>原有的出入境检验表和海关通关表填制的规范不同，表中各个项的参数或代码不同，需要标准化。</p></li><li><p>底层数据需要打通和整合，同时适应上层业务好服务不同的访问需求。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207154328963.png" alt="image-20211207154328963"></p></li></ul><h6 id="4-1-2-TSF与微服务设计原则"><a href="#4-1-2-TSF与微服务设计原则" class="headerlink" title="4.1.2 TSF与微服务设计原则"></a>4.1.2 TSF与微服务设计原则</h6><ul><li> 痛点和需求：整合原有出入境检验和海关通关相关业务和流程，实现海关业务功能标准化、构件化、服务化</li><li>快速打通全国通关一体化业务流程，实现流程标准化和闭环。</li><li>对原有业务实现复用和整合，加快新服务的开发速度，提高海关信息建设对业务改革的支撑能力</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207154634569.png" alt="image-20211207154634569"></p><h5 id="4-2-落地方案介绍"><a href="#4-2-落地方案介绍" class="headerlink" title="4.2 落地方案介绍"></a>4.2 落地方案介绍</h5><ul><li>基于腾讯云TSF分布式框架，实现<ul><li>分布式应用的快速构建</li><li>提供服务注册发现</li><li>服务治理，CICD能力</li><li>支撑海关原有业务复用和新业务快速构建，并提供统一的权限管理和控制，利用TSF提供的数字化营运能力实现高效运维，保障高效业务的开发和业务可靠稳定。</li></ul></li><li>TSF打通腾讯云Iaas和PaaS<ul><li>无缝对接腾讯云人工智能和数据能力平台</li><li>为上层业务提供基础技术能力，打通数据壁垒。</li></ul></li><li>落地后的系统架构图</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207155317517.png" alt="image-20211207155317517"></p><h5 id="4-3微服务化后的优势"><a href="#4-3微服务化后的优势" class="headerlink" title="4.3微服务化后的优势"></a>4.3微服务化后的优势</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211207155359287.png" alt="image-20211207155359287"></p><ul><li>快速构建分布式应用，提升开发效率<ul><li>基于腾讯云TSF提供的技术中台能力，快速响应海关关检合并的业务和流程需求，整合原有服务，提供服务注册发现、服务治理，CI/CD等能力，缩短开发周期，节约成本。</li></ul></li><li>针对不同用户角色提供服务的权限控制和管理，提高业务的安全性和可控性。</li><li>高效运维和数字化运营能力<ul><li>可视化数字运营</li><li>丰富的日志检索</li><li>业务监控告警能力</li><li>快速定位异常，节约运维成本，为业务保驾护航。</li></ul></li><li>无缝对接腾讯云技术设施和PaaS层能力，提供更加丰富的基础能力<ul><li>无缝对接腾讯云IaaS，大数据和人工智能等基础平台能力，实现资源和服务的统一纳管，为上层业务转型提供有效支撑。 </li></ul></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li>微服务设计的原则有哪些？</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十二、TSF分布式事务管理</title>
    <link href="/2021/12/03/%E5%8D%81%E4%BA%8C%E3%80%81TSF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <url>/2021/12/03/%E5%8D%81%E4%BA%8C%E3%80%81TSF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="十二、TSF分布式事务管理"><a href="#十二、TSF分布式事务管理" class="headerlink" title="十二、TSF分布式事务管理"></a>十二、TSF分布式事务管理</h3><p>随着微服务的增多，业务上不可避免的出现了多个服务（不同服务可能使用的是不同的数据库） 之间协作的问题（比如：跨行转账，2个账户数据在不同的地方，一个账户扣钱，另一个账户收 钱，这2个操作必须同时成功或者失败），这时候多个服务涉及的操作要么同时都成功，要么同 时都失败，这就是分布式事务。接下来我们看一下TSF的分布式事务管理功能。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>了解本地事务与分布式事务</li><li>了解分布式事务典型场景</li><li>掌握二阶段提交、三阶段提交和TCC</li><li>掌握使用TSF管理和监控分布式事务</li></ul><h4 id="第一章-本地事务与分布式事务简介"><a href="#第一章-本地事务与分布式事务简介" class="headerlink" title="第一章 本地事务与分布式事务简介"></a>第一章 本地事务与分布式事务简介</h4><h5 id="1-1-事务简介"><a href="#1-1-事务简介" class="headerlink" title="1.1 事务简介"></a>1.1 事务简介</h5><ul><li><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在关系数据库中，一个事务由一组SQL语句组成。</p></li><li><p>事务属性通常称为<strong>ACID</strong>特性,分别为：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203164433250.png" alt="image-20211203164433250"></p></li><li><p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务由事务开始(begin transaction)和事务结束(commit transaction或 rollback transaction)之间执行 的全体操作组成，通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起。</p></li><li><p>一个逻辑工作单元要成为事务，必须满足所谓的ACID(原子性、一致性、隔离性和持久性)属性。</p></li><li><p>原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</p></li><li><p>一致性（consistency）：事务在完成时，必须使所有的数据都保持一致状态，即保持数据的完整性（在存储或传输信息的过程中，原始的信息不能允许被随意更改）</p></li><li><p>隔离性（isolation）：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。</p></li><li><p>持久性（durability）：持续性也称永久性（permanence），指一个事务一旦提交，它对数据库 中数据的改变就应该是永久性的。</p></li></ul><h5 id="1-2-本地事务"><a href="#1-2-本地事务" class="headerlink" title="1.2 本地事务"></a>1.2 本地事务</h5><ul><li><p>大多场景下，我们的应用都只需操作单一的数据库，这种情况下的事务称之为本地事务(Local Transaction)。</p></li><li><p>本地事务的ACID特性是数据库直接提供支持。</p></li><li><p>本地事务应用架构如下所示：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206111426768.png" alt="image-20211206111426768"></p></li><li><p>在JDBC编程中，我们通过java.sql.Connection对象来开启、关闭或者提交事务。</p></li><li><p>很多java应用都整合了spring，并使用其声明式事务管理功能来完成事务功能。一般使用的步骤如下：</p><ul><li>配置事务管理器。spring提供了一个PlatformTransactionManager接口，其有2个重要的实现类：<ul><li>DataSourceTransactionManager：用于支持本地事务，其内部通过操作java.sql.Connection来开启、提交和回滚事务。</li><li>JtaTransactionManager：用于支持分布式事务，其实现了JTA规范，使用XA协议进行两阶段提交。需要注意的是，这只是一个代理，我们需要为其提供一个JTA provider，一般 是Java EE容器提供的事务协调器(Java EE server’s transaction coordinator)，也可以不 依赖容器，配置一个本地的JTA provider。</li></ul></li><li>在需要开启的事务的bean的方法上添加@Transitional注意，可以看到，spring除了支持本地事务，也支持分布式事务，下面我们先对分布式事务的典型应用场景进行介绍。</li></ul></li></ul><h5 id="1-3-分布式事务"><a href="#1-3-分布式事务" class="headerlink" title="1.3 分布式事务"></a>1.3 分布式事务</h5><ul><li><p>分布式事务</p><ul><li>顾名思义就是在分布式环境下运行的事务。</li><li>对于分布式事务来说，事务的每个操作步骤是运行在不同机器上服务的。</li><li>分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作， 提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。</li></ul></li><li><p>在现如今的大型互联网平台中，基本上都是采用分布式的SOA架构，所以分布式事务是非常常见的。比如一个电商平台的下单场景，一般对于用户下单会有两个步骤，一是订单业务采取下订单操作，二是库存业务采取减库存操作，但在大型电子商务平台上这两个业务一般会运行在不同的 机器上，这就是一个典型的分布式事务场景。还有一个常见的场景就是支付宝向余额宝转账，而支付宝和余额宝不是一个系统，怎么保证这两个系统之间的一致性就是分布式事务所关注的问题。</p></li></ul><h4 id="第二章-分布式事务典型场景"><a href="#第二章-分布式事务典型场景" class="headerlink" title="第二章 分布式事务典型场景"></a>第二章 分布式事务典型场景</h4><h5 id="2-1-跨库事务"><a href="#2-1-跨库事务" class="headerlink" title="2.1 跨库事务"></a>2.1 跨库事务</h5><ul><li><p>跨库事务：一个应用某个功能需要操作多个库，不同的库中存储不同的业 务数据。</p></li><li><p>在相对复杂的业务场景中，一个业务可能同时操作9个库。</p></li><li><p>下图为一个服务同时操作2个库的情况：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206113454881.png" alt="image-20211206113454881"></p></li></ul><h5 id="2-2-分库分表"><a href="#2-2-分库分表" class="headerlink" title="2.2 分库分表"></a>2.2 分库分表</h5><ul><li><p>通常一个库数据量较大或者预期未来的数据量较大时，会进行水平拆分，也就是分库分表。</p><ul><li><p>如下图，将数据库B拆分成了2个库：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206113618989.png" alt="image-20211206113618989"></p></li></ul></li><li><p>对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低sql操作的复杂性。如，对于sql：insert into user(id,name) values (1,”tianshouzhi”),(2,”wangxiaoxiao”)。这条sql是操 单库的语法，单库情况下，可以保证事务的一致性。</p></li><li><p>但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数 、据库中间件要将其改写为2条sql，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此基本上所有的数据库中间件都面临着分布式事务的问题。</p></li></ul><h5 id="2-3-服务化-SOA"><a href="#2-3-服务化-SOA" class="headerlink" title="2.3 服务化(SOA)"></a>2.3 服务化(SOA)</h5><ul><li><p>某应用同时操作9个库业务逻辑非常复杂，对于开发人员是极大的挑战，应 拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过 RPC框架来进行远程调用，实现彼此的通信。</p></li><li><p>下图为3个服务之间彼此调用的架构：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206114401308.png" alt="image-20211206114401308"></p></li><li><p>Service A完成某个功能需要直接操作数据库，同时需要调用Service B和Service C，而Service B 又同时操作了2个数据库，Service C也操作了一个库。需要保证这些跨服务的对多个数据库的操作要不都成功，要不都失败，实际上这可能是最典型的分布式事务场景。</p></li><li><p>小结：上述讨论的分布式事务场景中，无一例外的都直接或者间接的操作了多个数据库。如何保证事务的ACID特性，对于分布式事务实现方案而言，是非常大的挑战。同时，分布式事务实现方 案还必须要考虑性能的问题，如果为了严格保证ACID特性，导致性能严重下降，那么对于一些要 求快速响应的业务，是无法接受的。</p></li></ul><h4 id="第三章-二阶段提交、三阶段提交和TCC"><a href="#第三章-二阶段提交、三阶段提交和TCC" class="headerlink" title="第三章 二阶段提交、三阶段提交和TCC"></a>第三章 二阶段提交、三阶段提交和TCC</h4><h5 id="3-1-二阶段提交"><a href="#3-1-二阶段提交" class="headerlink" title="3.1 二阶段提交"></a>3.1 二阶段提交</h5><ul><li><p>两阶段提交协议（Two Phase Commit）不是在XA规范中提出，但是XA 规范对其进行了优化，因此统一放到这里进行讲解。而从字面意思来理解 ，Two Phase Commit，就是将提交(commit)过程划分为2个阶段(Phase) ：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206120547855.png" alt="image-20211206120547855"></p></li><li><p>阶段1：</p><ul><li>TM（Transaction Manager，事务管理器）通知各个RM（Resource Manager，资源管理器）准备提交它们的事务分支。如果RM判断自己进行的工作可以被提交，那就对工作内容进行持久化，再给TM肯定答复；要是发生了其他情况，那给TM的都是否定答复。 在发送了否定答复并回滚了已经的工作后，RM就可以丢弃这个事务分支信息。</li><li>以mysql数据库为例，在第一阶段，事务管理器向所有涉及到的数据库服务器发出prepare”准备提交”请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成”可以提交”,然后把结果返回给事务管理器。</li></ul></li><li><p>阶段2</p><ul><li>TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都 prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare失败的话，则TM通知所有RM回滚自己的事务分支。</li><li>以mysql数据库为例，如果第一阶段中所有数据库都prepare成功，那么事务管理器向数据库服务器发出”确认提交”请求，数据库服务器把事务的”可以提交”状态改为”提交完成”状态，然后返回应答。如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把”可以提交”的事务回撤。</li></ul></li><li><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p><ol><li>同步阻塞问题</li><li>单点故障</li><li>数据不一致</li></ol></li></ul><h5 id="3-2-三阶段提交"><a href="#3-2-三阶段提交" class="headerlink" title="3.2 三阶段提交"></a>3.2 三阶段提交</h5><ul><li><p>三阶段提交（3PC)，是二阶段提交（2PC）的改进版本。</p></li><li><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul></li><li><p>三阶段提交有：CanCommit、PreCommit、DoCommit三个阶段。</p></li><li><p>三阶段提交协议在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。</p></li><li><p>CanCommit阶段:3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送 commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应</p></li><li><p>PreCommit阶段:根据反应情况来决定是否可以继续事务的PreCommit操作</p><ul><li>如果响应全部yes，则进行事务预执行</li><li>如果有一个响应为no，或者等待超时，那么就中断事务，发送中断请求</li></ul></li><li><p>DoCommit阶段：该阶段进行真正的事务提交，也可以分为以下两种情况：</p><ul><li>执行提交</li><li>中断事务</li></ul></li><li><p>对于协调者(Coordinator)和参与者(Cohort)都设置了超时机制（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到cohort的消息则默认失败），在2PC的准备阶段和提交阶段之间，插入预提交阶段，使3PC拥有CanCommit、PreCommit、DoCommit三个阶段。 PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的</p></li></ul><h5 id="3-3-TCC"><a href="#3-3-TCC" class="headerlink" title="3.3 TCC"></a>3.3 TCC</h5><ul><li>TCC 模式是应用层的两阶段提交：<ul><li>先 try, 再执行 confirm；若 try 失败，则执行cancel。</li></ul></li><li>TCC 模式解决的问题包括但不限于：<ul><li>数据库的两阶段并发性能差。</li><li>数据库对XA协议的支持可能不完善。</li><li>在分布式架构下，主业务系统并非直接操作数据库，而是调用从业务系统的服务接口 。</li></ul></li><li><strong>TCC 模式是一种补偿性分布式事务</strong>。其中TCC 三个字母分别对应Try、Confirm、Cancel三种操 作。其中Try 阶段预留业务资源，Confirm 阶段确认执行业务操作，cancel 阶段取消执行业务操作。TCC 模式解决了跨服务操作的原子性问题，对数据库的操作是一阶段提交，性能较好。因此， TCC 模式是现今被广泛应用的一种分布式事务模式。</li><li>Try: 尝试执行业务<ul><li>完成所有业务检查(一致性)</li><li>预留必须业务资源(准隔离性)</li></ul></li><li>Confirm:确认执行业务<ul><li>真正执行业务</li><li>不作任何业务检查</li><li>只使用Try阶段预留的业务资源</li><li>Confirm操作要满足幂等性</li></ul></li><li>Cancel: 取消执行业务<ul><li>释放Try阶段预留的业务资源</li><li>Cancel操作要满足幂等性</li></ul></li></ul><h4 id="第四章-分布式事务应用持续开发指南"><a href="#第四章-分布式事务应用持续开发指南" class="headerlink" title="第四章 分布式事务应用持续开发指南"></a>第四章 分布式事务应用持续开发指南</h4><h5 id="4-1-名词解释"><a href="#4-1-名词解释" class="headerlink" title="4.1 名词解释"></a>4.1 名词解释</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206155714357.png" alt="image-20211206155714357"></p><ul><li><p>事务：事务是指作为单个逻辑工作单元执行的一系列操作。事务的执行有一致性。同一个事务只能同时被操作或不被操作。</p></li><li><p>主事务：主事务是事务的发起者。同一个事务只能有一个主事务。</p></li><li><p>子事务：子事务是同一个主事务下的分支。</p></li><li><p>事务管理器：事务管理器是一个协调分布式事务、管理事务执行状态的独立服务。</p></li></ul><h5 id="4-2-开发指南-场景描述"><a href="#4-2-开发指南-场景描述" class="headerlink" title="4.2  开发指南-场景描述"></a>4.2  开发指南-场景描述</h5><ul><li><p>场景描述：</p><ul><li><p>两台虚拟机，分别命令为node1、node2，每台虚拟机上都安装了MySQL数据库，现在向node1上的数据库更新用户账户信息，向node2上的数据库新增用户消费信息。</p></li><li><p>基本流程如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206160010473.png" alt="image-20211206160010473"></p></li></ul></li><li><p>接下来以如上场景来说明TCC的事务开发步骤，以SprigCloud项目为例</p></li><li><p>基本开发流程如上图</p></li></ul><h6 id="4-2-1-开发指南-配置TCC事务"><a href="#4-2-1-开发指南-配置TCC事务" class="headerlink" title="4.2.1 开发指南-配置TCC事务"></a>4.2.1 开发指南-配置TCC事务</h6><ul><li><p>配置TCC事务</p><ul><li><p>通过Maven引入依赖，在项目的pom文件添加下述配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tsf-transaction-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.5-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="4-2-2-开发指南-添加注解"><a href="#4-2-2-开发指南-添加注解" class="headerlink" title="4.2.2 开发指南-添加注解"></a>4.2.2 开发指南-添加注解</h6><ul><li><p>启用Tcc事务在Spring Cloud的启动类加入注解@EnableTcc: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableTcc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>  SpringApplication.run(App.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="4-2-2-开发指南-添加注解（续）"><a href="#4-2-2-开发指南-添加注解（续）" class="headerlink" title="4.2.2 开发指南-添加注解（续）"></a>4.2.2 开发指南-添加注解（续）</h6><ul><li>在事务的入口函数上添加@TsfTcc注解，TsfTcc注解有如下属性：<ul><li>serviceName：事务所属的服务名，必选。</li><li>type：事务类型，TransactionType.ROOT表示主事务，TransactionType.BRANCH 表示子事务，默认值为Root，可选。</li><li>timeout_ms：事务的超时时间，属性可选，默认为60秒，可选。</li><li>confirmMethodName：confirm方法名，主事务可选，子事务必选。</li><li>cancelMethodName：cancel方法名，主事务可选，子事务必选。</li><li>autoRetry: 事务超时后，是否由服务器托管继续自动重试。</li></ul></li><li>建议注解加在接口定义的方法上</li></ul><h6 id="4-2-3-开发指南-定义主事务"><a href="#4-2-3-开发指南-定义主事务" class="headerlink" title="4.2.3 开发指南-定义主事务"></a>4.2.3 开发指南-定义主事务</h6><ul><li><p>定义主事务</p><ul><li><p>主事务函数只需要定义一个事务入口函数即可。type选择Root类型；函数抛出 Throwable异常，返回值没有特殊要求；建议业务将所需的参数都封装成一个对象， 只使用这一个对象作为入参即可（所有的参数必须实现Serializable接口），一个主事务函数定义的样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTransaction</span> </span>&#123;<br><br><span class="hljs-meta">@TsfTcc(serviceName = &quot;myTcc&quot;, type = TransactionType.ROOT, timeout_ms = 60000)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">beginTcc</span><span class="hljs-params">(MyParams params)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-comment">//这里写业务逻辑，调用子事务函数</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="4-2-4-开发指南-定义子事务"><a href="#4-2-4-开发指南-定义子事务" class="headerlink" title="4.2.4 开发指南-定义子事务"></a>4.2.4 开发指南-定义子事务</h6><ul><li>定义子事务<ul><li>一个完整的子事务需要定义3个方法：Try，Confirm，Cancel。</li><li>其中只有Try方法才需要加TsfTcc注解，在TsfTcc标签中指定对应Confirm和Cancel方法名即可。</li><li>子事务函数定义约束如下：<ul><li>Try，Confirm，Cancel的前两个参数必须为String txId和long branchId(在主事务调用子事务的时候，这两个参数分别为null和0即可)，其中txId为主事务Id，全局唯一；branchId为子事务Id，用于区分子事务的父子关系和子事务之间的调用顺序。</li><li>Try函数返回Throwable异常；Try函数的返回值为void，Tcc通过异常返回失败结果。</li><li>Confirm和Cancel函数返回值为boolean类型，操作成功返回true，操作失败返回False。</li></ul></li></ul></li></ul><h6 id="4-2-6-开发指南-事务函数样例"><a href="#4-2-6-开发指南-事务函数样例" class="headerlink" title="4.2.6 开发指南-事务函数样例"></a>4.2.6 开发指南-事务函数样例</h6><ul><li>一个子事务函数定义的样例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SubService</span></span>&#123;<br>  <br>  <span class="hljs-meta">@TsfTcc(serviceName = &quot;subService&quot;, type = TransactionType.BRANCH, confirmMethodName = &quot;subConfirm&quot;, cancelMethodName = &quot;subCancel&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subTry</span><span class="hljs-params">(String txId, <span class="hljs-keyword">long</span> branchId, MyParams Params)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">subConfirm</span><span class="hljs-params">(String txId, <span class="hljs-keyword">long</span> branchId, MyParams Params)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">subCancel</span><span class="hljs-params">(String txId, <span class="hljs-keyword">long</span> branchId, MyParams Params)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>主事务与子事务结合样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTransaction</span></span>&#123;<br>  <br>  SubService subService;<br>  <br>  <span class="hljs-meta">@TsfTcc(serviceName = &quot;myTcc&quot;, type = Transaction.ROOT, timeout_ms = 600000)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">beginTcc</span><span class="hljs-params">(MyParams params)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>      subService.subTry(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, params);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="4-3-分布式事务应用程序开发常见问题"><a href="#4-3-分布式事务应用程序开发常见问题" class="headerlink" title="4.3 分布式事务应用程序开发常见问题"></a>4.3 分布式事务应用程序开发常见问题</h5><ul><li>如何保证全局事务的正确执行</li><li>子事务如何访问外部服务</li><li>业务需要处理什么类型的异常</li><li>业务什么时候会进行回滚</li><li>分布式事务的超时、重试机制</li></ul><ul><li>如何保证全局事务的正确执行<ul><li>Tcc通过主事务函数作为入口，协调控制多个跨库/跨服务的子事务的执行流程。因此，Tcc保证的是在各个子事务之间的事务特性，一次性Confirm或者Cancel所有的子事务。然而Tcc不能够保证每个子事务内部的事务性质，<strong>因此在使用Tcc时的最佳实践应该是在每个子事务内部需要自己执行本地事务</strong>。</li></ul></li><li>子事务如何访问外部服务<ul><li>在SpringCloud中，可以通过集成FeignClient去访问外部的服务，再次以上述的子事务为例， 假如子事务需要调用一个代金券服务的相关接口，则配置如下:<ul><li>在接口上增加了如下注解：<ul><li>@FeignClient(value = “couponService”)，value的值为外部服务在服务注册中心注册的服务名</li><li>@RequestMapping(value = “/api/v6/data/couponService”)，value的值为外部服务的根URL</li></ul></li><li>在方法上增加了如下注解：<ul><li>@RequestMapping(value = “/try”, method = RequestMethod.POST)，value的值为外部 服务的api的URL以及请求方式。</li></ul></li></ul></li></ul></li><li>业务需要处理什么类型的异常<ul><li>主事务函数中主要需要捕获两个异常：TransactionCancelledException异常表示事务失败 cancelled，TransactionTimeoutException异常表示事务超时。运行时业务抛出的异常会被包装在这两个异常中，可以通过getCause()方法获取业务真正的运行时异常。</li></ul></li><li>业务什么时候会进行回滚<ul><li>当前业务只有在子事务Try失败的时候进行cancel操作,当进入confirm阶段之后，confirm失败只会继续重试confirm，直到超时为止。</li></ul></li><li>分布式事务的超时、重试机制<ul><li>用户可以在主事务的注释中定义超时时间，默认超时时间为60秒，此时的超时时间为整个事务的超时时间。当事务超时后，事务管理器对事务进行接管，以每5秒一次的重试频率自动触发重试，重试频率逐渐增长，直到600秒。用户可以在控制台上控制中断这一重试过程，也可以手动触发重试。7天后，重试自动终止。对于未超时的事务，Try 阶段自动重试3次，3次重试不成功自动触发 Cancel 进行回滚。对于 Confirm 或者 Cancel 阶段始终不能执行成功的情况，会重试直到超时。超时后由事务管理器接管。</li></ul></li></ul><h4 id="第五章-使用TSF管理和监控分布式事务"><a href="#第五章-使用TSF管理和监控分布式事务" class="headerlink" title="第五章 使用TSF管理和监控分布式事务"></a>第五章 使用TSF管理和监控分布式事务</h4><h5 id="5-1-使用TSF管理和监控分布式事务"><a href="#5-1-使用TSF管理和监控分布式事务" class="headerlink" title="5.1 使用TSF管理和监控分布式事务"></a>5.1 使用TSF管理和监控分布式事务</h5><ul><li>腾讯云TSF框架，提供基于TCC（Try-Confirm-Cancel）的事务方案，解决跨服务的一致性问题。<ul><li>第一阶段：主业务服务分别调用所有从业务服务的 try 操作，并在活动管理器中记录所有从业务服务。当所有从业务服务 try 成功或者某个从业务服务 try 失败时，进入第二阶段</li><li>第二阶段：活动管理器根据第一阶段从业务服务的 try 结果来执行 confirm 或 cancel 操作。如果第一阶段所有从业务服务都 try 成功，则协作者调用所有从业务服务的 confirm 操作，否则，调用所有从业务服务的 cancel 操作。（confirm操作，需要业务满足幂等）</li></ul></li><li>前面我们已经介绍了二阶段提交，三阶段提交以及TCC提交方式，在TSF中使用的是TCC分布式事务方案</li></ul><h5 id="5-1-使用TSF管理和监控分布式事务（续）"><a href="#5-1-使用TSF管理和监控分布式事务（续）" class="headerlink" title="5.1 使用TSF管理和监控分布式事务（续）"></a>5.1 使用TSF管理和监控分布式事务（续）</h5><ul><li><p>在第二阶段中，confirm 和 cancel 同样存在失败情况，所以需要对这两种情况做异常处理以保证数据一致性。</p><ul><li>Confirm /Cancel失败：会一直重试对应的Confirm或者Cancel操作直到成功，因此需要保证业务是幂等的。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206164733490.png" alt="image-20211206164733490"></p></li><li><p>try 阶段：尝试执行，完成所有业务检查（一致性），预留必需业务资源（准隔离性）。</p></li><li><p>Confirm 阶段：确认真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源， Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p></li><li><p>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p></li></ul><h4 id="第六章-TSF分布式事务最佳实践"><a href="#第六章-TSF分布式事务最佳实践" class="headerlink" title="第六章 TSF分布式事务最佳实践"></a>第六章 TSF分布式事务最佳实践</h4><h5 id="6-1-TSF分布式配置"><a href="#6-1-TSF分布式配置" class="headerlink" title="6.1 TSF分布式配置"></a>6.1 TSF分布式配置</h5><ul><li><p>腾讯云TSF框架，提供精准掌握事务流程，包括：</p><ul><li><p>不同状态的事务筛选</p></li><li><p>事务IP、服务名、方法名</p></li><li><p>子事务列表</p></li><li><p>参数列表</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206165720423.png" alt="image-20211206165720423"></p></li></ul></li><li><p>在TSF控制台中提供了“事务管理”功能：</p><ol><li>打开TSF控制台。</li><li>点击【事务管理】功能。</li><li>控制台上选择需要查看的事务时间段，选择需要查看的事务状态，并填写关键词。关键词可 以选择事务相关的服务名、方法名称。</li><li>点击查询，将展示事务id、起始节点、超时时长等等相关信息，查询界面如上图。</li></ol></li></ul><h5 id="6-1-TSF分布式配置（续）"><a href="#6-1-TSF分布式配置（续）" class="headerlink" title="6.1 TSF分布式配置（续）"></a>6.1 TSF分布式配置（续）</h5><ul><li><p>查看子事务</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206170132844.png" alt="image-20211206170132844"></p></li><li><p>点击上一页中的主事务id，可以查看主事务下的子事务运行状态，包含子事务的方法名、服务名、 节点、状态、起止时间等信息。每一次子事务发起的请求都会记录在子事务列表中，包含子事务的确认、取消、重试等等。当子事务发生重试时，可以查看子事务重试是由主事务触发、由事务管理器启动发起重试还是由用户在控制台上进行手动触发。</p></li></ul><h5 id="6-1-TSF分布式配置（续）-1"><a href="#6-1-TSF分布式配置（续）-1" class="headerlink" title="6.1 TSF分布式配置（续）"></a>6.1 TSF分布式配置（续）</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206170234965.png" alt="image-20211206170234965"></p><ul><li>点击子事务列表右侧的“查看事务参数”，可以查看每条子事务的参数内容，如上图：</li></ul><h5 id="6-2-TSF分布式事务最佳实践"><a href="#6-2-TSF分布式事务最佳实践" class="headerlink" title="6.2 TSF分布式事务最佳实践"></a>6.2 TSF分布式事务最佳实践</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211206170318675.png" alt="image-20211206170318675"></p><ul><li>已超时事务处理：<ul><li>当主事务的处理时间超过了SDK中设置的超时时限后，认为事务已处于超时状态。针对超时事务， TSF 提供了两种重试渠道：自动重试和手动重试。当事务超时时，框架自动重试，重试时间间隔 从5秒一次倍速递增直到600秒一次，当超时时间超过7天后，自动停止重试。手动重试是指用户可以在控制台上通过点击的方式触发重试</li></ul></li><li>操作步骤：<ol><li>打开TSF控制台。</li><li>点击【事务管理】功能。</li><li>批量选择需要进行手动重试或需要停止/触发自动重试的事务，点击启动操作，如上图。</li></ol></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li>开发TSF分布式事务的主要流程是怎么样的？</li><li>分布式事务的主要场景有哪些？</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十一、TSF与API网关</title>
    <link href="/2021/12/03/%E5%8D%81%E4%B8%80%E3%80%81TSF%E4%B8%8EAPI%E7%BD%91%E5%85%B3/"/>
    <url>/2021/12/03/%E5%8D%81%E4%B8%80%E3%80%81TSF%E4%B8%8EAPI%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="十一、TSF与API网关"><a href="#十一、TSF与API网关" class="headerlink" title="十一、TSF与API网关"></a>十一、TSF与API网关</h3><p>前面我们已经介绍了TSF的运维管理，服务治理，配置管理功能的使用；TSF 同时也和腾讯云API 网关打通了，您可使用 API Gateway 封装自身业务，将您的数据、业务逻辑或功能安全可靠的开放出来，用以实现自身系统集成、以及与合作伙伴的业务连接，接下来我们看一下TSF的API网关功能。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>了解微服务网关基本概念</li><li>掌握TSF 与 API网关的使用</li></ul><h4 id="第一章-微服务网关基本概念"><a href="#第一章-微服务网关基本概念" class="headerlink" title="第一章 微服务网关基本概念"></a>第一章 微服务网关基本概念</h4><h5 id="1-1-微服务网关概述"><a href="#1-1-微服务网关概述" class="headerlink" title="1.1 微服务网关概述"></a>1.1 微服务网关概述</h5><ul><li><p>微服务网关：</p><ul><li><p>微服务网关是用于实现微服务对外出口的服务，用于协助开发者完成微服务对外提供调用及微服务互相之间调用。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203155840131.png" alt="image-20211203155840131"></p></li></ul></li><li><p><strong>简单的说 ：服务网关 = 路由转发 + 过滤器</strong></p><ul><li><p>路由转发：接收一切外界请求，转发到后端的微服务上去；</p></li><li><p>过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成</p></li></ul></li></ul><h5 id="1-2-微服务网关优势"><a href="#1-2-微服务网关优势" class="headerlink" title="1.2 微服务网关优势"></a>1.2 微服务网关优势</h5><ul><li><p>减少客户端与微服务之间的调用次数，提高效率；</p></li><li><p>便于监控，可在网关中监控数据，可以做统一切面任务处理；</p></li><li><p>便于认证，只需要在网关进行认证即可，无需每个微服务都进行认证；</p></li><li><p>降低客户端与服务端的耦合度。</p></li><li><p> 在客户端和服务端之间增加一个API网关，所有的外部请求先通过这个微服务网关，它只需跟网 关进行交互，而由网关进行各个微服务的调用；还有如下优势：</p></li><li><p>微服务调用管理：微服务网关作为微服务的出⼝口，同时也作为一个微服务将自身注册在注册 中心中，用户通过微服务网关可直接调用后端的微服务业务，并且对后端的微服务做统⼀一的 管理、限流、鉴权等。微服务网关本身提供负载均衡、健康检查、监控等基本能力，方便用户对后端的微服务及调用者的调用情况管理</p></li><li><p>使用灵活方便：以服务的形式提供微服务网关给用户，有控制台操作，又兼具开源产品所有的代码动态加载的灵活性。用户可以快起创建微服务网关开放业务。</p></li><li><p>高可靠：每一个微服务网关均为HA高可用，每个用户的微服务网关使⽤用与其他用户资源隔离，保证服务的可用性。</p></li></ul><h5 id="1-3-微服务网关使用场景"><a href="#1-3-微服务网关使用场景" class="headerlink" title="1.3 微服务网关使用场景"></a>1.3 微服务网关使用场景</h5><ul><li>在用户系统为微服务架构开发的情况下，微服务架构带来如下状况：<ul><li>大量的微服务模块，微服务本身需要具有出口提供给客户端调用。</li><li>使用腾讯云微服务框架TSF时，常遇到不同隔离命名空间下的直接调用。</li><li>每个微服务都需要统一的调用规范、提供鉴权认证等。</li><li>每个微服务用户期望从入口即可获取到后端微服务中的完整调用链。</li></ul></li><li>在这种情况下，对 API 的管理和使用，会随着微服务模块的增长而越来越麻烦。而利用微服务网关，能很好的解决这些问题。</li></ul><h5 id="1-3-微服务网关使用场景（续）"><a href="#1-3-微服务网关使用场景（续）" class="headerlink" title="1.3 微服务网关使用场景（续）"></a>1.3 微服务网关使用场景（续）</h5><ul><li><p>后端不同命名空间中的微服务可通过微服务网关互相访问</p></li><li><p>外部客户也可通过微服务网关的IP进行访问。（微服务网关对外提供IP）。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203161450216.png" alt="image-20211203161450216"></p></li><li><p> 如上是微服务网关的典型应用场景</p></li></ul><h4 id="第二章-TSF-与-API网关使用"><a href="#第二章-TSF-与-API网关使用" class="headerlink" title="第二章 TSF 与 API网关使用"></a>第二章 TSF 与 API网关使用</h4><h5 id="2-1-腾讯云API网关"><a href="#2-1-腾讯云API网关" class="headerlink" title="2.1 腾讯云API网关"></a>2.1 腾讯云API网关</h5><ul><li><p>腾讯云API网关：</p><ul><li>在腾讯云公网网站中可以直接使用腾讯云的API网关功能，TSF与API网关产品打通，用户可以在 腾讯云 API 网关上可以配置微服务 API 来将外部请求转发到 TSF 平台上部署的微服务。API 网关与 TSF 平台内的微服务之间的关系如下图：</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203161844876.png" alt="image-20211203161844876"></p></li><li><p>腾讯云 API 网关与腾讯云 TSF 是两个独立的产品，关于 API 网关可参考： <a href="https://cloud.tencent.com/document/product/628">https://cloud.tencent.com/document/product/628</a></p></li><li><p>用户必须将给命名空间配置 code （Namespace Code）才能实现将 API 网关外部的请求转发 到命名空间内的微服务。对于不同命名空间内的名称都是 product 的微服务来说，只有通过命名 空间 ID 和微服务名称来唯一确定一个微服务。由于平台生成的命名空间 ID 较难辨识（通常是 namespaceid-xxxx) ，因此引入命名空间 Code 来作为唯一标示。命名空间 Code 具有如下特 性：</p><ul><li>跨集群唯一性</li><li>用户自定义</li><li>可读性强</li><li>不可修改</li></ul></li><li><p>在TSF上配置命名空间Code可参考： <a href="https://cloud.tencent.com/document/product/649/17644">https://cloud.tencent.com/document/product/649/17644</a></p></li></ul><h5 id="2-2-微服务网关鉴权"><a href="#2-2-微服务网关鉴权" class="headerlink" title="2.2 微服务网关鉴权"></a>2.2 微服务网关鉴权</h5><ul><li><p>支持使用密钥对、Oauth的形式进行访问控制</p></li><li><p>密钥对鉴权原理：hmac算法加密</p></li><li><p>为了保护您的 API，避免恶意访问、未授权访问、应用漏洞、黑客攻击等导致的数据损失、资产损失，我们提供了多种 API 认证方式和 API 防护策略。TSF网关支持支持使用密钥对、Oauth的 形式进行访问控制；其中Oauth鉴权：使用业界标准 Oauth 2.0 鉴权；</p></li><li><p>您可以使用 secretId 和 secretKey 对您的 API 进行认证管理。secretId 和 secretKey 成对出现， 这里将它们将称为 secretId/secretKey 对。在使用 secretId/secretKey 对认证前，需要先创建 好一对 secretId 和 secretKey;</p></li><li><p>Hmac：HMAC是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一 个消息为输入，生成一个消息摘要作为输出。</p></li><li><p>OAuth（开放授权）是一个关于授权的开放标准，允许用户让第三方应用访问该用户在某一网站 上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用</p></li><li><p>OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 OAuth 2.0关注客户端开发者的简易性</p></li><li><p>在认证和授权的过程中涉及的三方包括：</p><ol><li><p>服务提供方，用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。</p></li><li><p>用户，存放在服务提供方的受保护的资源的拥有者</p></li><li><p>客户端，要访问服务提供方资源的第三方应用，通常是网站，如提供照片打印服务的网站。 在认证过程之前，客户端要向服务提供者申请客户端标识</p></li></ol></li></ul><h5 id="2-3-微服务网关限流"><a href="#2-3-微服务网关限流" class="headerlink" title="2.3 微服务网关限流"></a>2.3 微服务网关限流</h5><ul><li>用户可以配置微服务网关每个api路径被请求的最大QPS</li><li>超过该次数可以的请求会被拒绝</li><li>QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准；</li><li>可以在微服务网关中设置每个api请求的最大QPS；如果请求超过最大次数，将会触发限流。</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>API网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十、TSF配置管理</title>
    <link href="/2021/12/03/%E5%8D%81%E3%80%81TSF%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2021/12/03/%E5%8D%81%E3%80%81TSF%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="十、TSF配置管理"><a href="#十、TSF配置管理" class="headerlink" title="十、TSF配置管理"></a>十、TSF配置管理</h3><p>前面我们已经介绍了TSF的运维管理，服务治理功能，接下来我们看一下TSF的配置管理功能</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>掌握TSF配置管理的基本操作</li><li>掌握应用配置的基本操作</li><li>掌握全局配置的基本操作</li><li>掌握配置回调的基本操作</li><li>掌握配置模板的基本操作</li><li>掌握文件配置的基本操作</li></ul><h4 id="第一章-配置管理概述"><a href="#第一章-配置管理概述" class="headerlink" title="第一章 配置管理概述"></a>第一章 配置管理概述</h4><h5 id="1-1-配置管理概述"><a href="#1-1-配置管理概述" class="headerlink" title="1.1 配置管理概述"></a>1.1 配置管理概述</h5><ul><li>配置管理：<ul><li>为了更好的解决分布式环境下多台服务实例的配置不统一问题，TSF 提供了分布式配置功能。</li></ul></li><li>TSF 的配置功能具有如下特点：<ul><li>支持配置的分布式化管理</li><li>支持在控制台上编写 YAML 格式的配置。</li><li>配置异构系统管理<ul><li>异构系统是指一个应用有多个部署组时（例如开发环境、测试环境的部署 组），由于配置不同，从而需要多个部署包的情况。使用分布式配置功能后，用户只需要同一个 部署包，不同部署组的配置会自动分配。</li></ul></li><li>配置更新自动化：<ul><li>用户在平台更新配置，使用该配置的系统会自动发现该情况，并应用新配置。</li></ul></li></ul></li><li>目前 TSF 分布式配置功能仅支持 Spring Cloud 类型的应用。</li></ul><h5 id="1-2-配置管理分类"><a href="#1-2-配置管理分类" class="headerlink" title="1.2 配置管理分类"></a>1.2 配置管理分类</h5><ul><li>配置管理分类：<ul><li>应用配置</li><li>全局配置</li><li>本地配置</li></ul></li><li>应用配置和全局配置属于 TSF 平台上的配置（下面称为远程配置），本地配置是应用程序在代码 工程中创建的配置（如 application.yml 和 bootstrap.yml）。应用配置和全局配置的根本区别 在于 配置发布的范围，应用配置发布的范围是部署组维度，全局配置发布的范围是命名空间维度。</li><li>优先级：应用配置 &gt; 全局配置 &gt; 本地配置 </li></ul><h4 id="第二章-应用配置"><a href="#第二章-应用配置" class="headerlink" title="第二章 应用配置"></a>第二章 应用配置</h4><h5 id="2-1-使用方式-使用流程"><a href="#2-1-使用方式-使用流程" class="headerlink" title="2.1 使用方式-使用流程"></a>2.1 使用方式-使用流程</h5><ul><li><p>TSF动态配置使用步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203114325085.png" alt="image-20211203114325085"></p></li><li><p>如上采用应用配置方式，全部配置使用方式跟应用配置类似，只是优先级不一样。</p></li><li><p>动态配置使用步骤：</p><ul><li>pom.xml 添加配置依赖项</li><li>在代码中引用配置</li><li>TSF平台填写配置</li><li>通过 TSF 平台下发动态配置，配置的作用范围是部署组。</li></ul></li></ul><h6 id="2-1-1-添加依赖"><a href="#2-1-1-添加依赖" class="headerlink" title="2.1.1 添加依赖"></a>2.1.1 添加依赖</h6><ul><li><p>步骤一：</p><ul><li><p>项目根目录pom.xml配置文件中添加依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用分布式配置自动刷新功能，需要显示添加actuator的依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="2-1-2-引用配置"><a href="#2-1-2-引用配置" class="headerlink" title="2.1.2 引用配置"></a>2.1.2 引用配置</h6><ul><li><p>步骤二：</p><ul><li><p>引用配置，二种方式：</p><ul><li>@ConfigurationProperties注解方式</li><li>@Value 注解方式</li></ul></li><li><p>@ConfigurationProperties 使用类映射多个配置，适合多个配置映射使用</p></li><li><p>@Value 单个属性映射配置，适合少量配置映射使用</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203114745424.png" alt="image-20211203114745424"></p></li></ul></li><li><p>@ConfigurationProperties支持松散语法， @Value不支持松散语法，松散语法也就是属性命 名规则示例如下：</p><ul><li> person.firstName:使用标准方式</li><li> person.first-name:大写用-</li><li>person.first_name:大写用_</li><li>PERSON_FIRST_NAME: 系统属性推荐使用这种写法</li></ul></li><li><p>@ConfigurationProperties @Validated 支持 JSR303数据校验，@Value不支持</p></li><li><p>@ConfigurationProperties不支持EL表达式（如：userAge = #{2*6}）</p></li><li><p>@Value支持EL表达式（如：@Value(userAge=#{2*6})）</p></li><li><p>在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；如果专门编写了一个 javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties</p></li></ul><h6 id="2-1-2-引用配置（续）"><a href="#2-1-2-引用配置（续）" class="headerlink" title="2.1.2 引用配置（续）"></a>2.1.2 引用配置（续）</h6><ul><li><p>使用配置类 @ConfigurationProperties</p></li><li><p>例如下图中使用@ConfigurationProperties方式，代码如下：</p><ul><li><p>使用 @ConfigurationProperties 注解来标明这个类是一个配置类。</p></li><li><p>使用@RefreshScope注解开启自动 刷新机制。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203115130188.png" alt="image-20211203115130188"></p></li></ul></li><li><p>@ConfigurationProperties 注解中的prefix代表配置的前缀，也就是说需要符合这个前缀配置 才能映射到类中的属性</p></li><li><p>@RefreshScope注解开启 自动刷新机制，也就是在配置发生改变的时候回自动刷新，不需要重新应用</p></li></ul><h6 id="2-1-2-引用配置-续）"><a href="#2-1-2-引用配置-续）" class="headerlink" title="2.1.2 引用配置(续）"></a>2.1.2 引用配置(续）</h6><ul><li><p>使用属性配置注解： @Value；代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;provider.config.name:name1&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure></li><li><p>如上代码通过@Value注解指定配置的名称为： provider.config.name； 然后把provider.config.name配置对应的值注入到name属性中。</p></li><li><p>provider.config.name:name1：冒号后面的“name1”是默认值</p></li><li><p>上述代码演示了使用@value方式注入配置。在启动类 ProviderApplication 中，使用 @Value 注解来标识一个配置变量。</p></li></ul><h6 id="2-1-3-配置内容填写"><a href="#2-1-3-配置内容填写" class="headerlink" title="2.1.3 配置内容填写"></a>2.1.3 配置内容填写</h6><ul><li><p>步骤三：</p><ul><li><p>TSF控制台填写配置</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203115618496.png" alt="image-20211203115618496"></p></li></ul></li><li><p>具体操作步骤：</p><ul><li>登录 TSF 控制台。</li><li>单击导航栏应用配置。</li><li>选择新建配置。</li><li>单击【新建】按钮。</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203115950123.png" alt="image-20211203115950123"></p><ul><li>填写配置内容。配置可以按照 YAML 方式进行编辑。YAML 格式规范参考 YAML 格式介绍，官网文档：<a href="https://cloud.tencent.com/document/product/649/17925%E3%80%82">https://cloud.tencent.com/document/product/649/17925。</a></li><li>单击【提交】按钮。</li></ul><h6 id="2-1-4-发布配置"><a href="#2-1-4-发布配置" class="headerlink" title="2.1.4 发布配置"></a>2.1.4 发布配置</h6><ul><li><p>步骤四：        </p><ul><li><p>发布配置：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203120108959.png" alt="image-20211203120108959"></p></li></ul></li><li><p>在配置版本中选择对应的版本，点击“发布” ，然后选择对应的部署组就可以把配置发布到对应 的部署组中。</p></li><li><p>配置发布以后可以在日志查看对应配置的打印记录也可以通过浏览器访问配置对应链接的url验证配置更新情况</p></li></ul><h5 id="2-2-应用配置管理的功能"><a href="#2-2-应用配置管理的功能" class="headerlink" title="2.2 应用配置管理的功能"></a>2.2 应用配置管理的功能</h5><ul><li>应用配置的功能：<ul><li>创建配置项：一个配置项管理多个版本的配置</li><li>生成新版本：基于历史版本生成新版本</li><li>发布配置：支持发布配置到部署组</li><li>回滚：回滚到上一个版本的配置</li></ul></li></ul><h6 id="2-2-1-应用配置管理的功能"><a href="#2-2-1-应用配置管理的功能" class="headerlink" title="2.2.1 应用配置管理的功能"></a>2.2.1 应用配置管理的功能</h6><ul><li>应用配置的创建、发布、更新、回滚操作都比较简单，都是直接点击对应的按钮就可以实现了， 参考官网文档：<a href="https://cloud.tencent.com/document/product/649/15539">https://cloud.tencent.com/document/product/649/15539</a></li></ul><h5 id="2-3-配置优先级"><a href="#2-3-配置优先级" class="headerlink" title="2.3 配置优先级"></a>2.3 配置优先级</h5><ul><li><p>TSF 支持多份应用配置发布到同一个部署组，多份配置会根据发布时间的 先后顺序以 key 来进行合并。举例来说，应用 A 有两个应用配置项 config-1， config-2。</p></li><li><p>config-1 的配置内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># config-1配置</span><br><span class="hljs-attr">username</span>: <span class="hljs-string">test_user1</span><br><span class="hljs-meta">feature.status</span>: <span class="hljs-string">false</span><br><span class="hljs-meta">feature.color</span>: <span class="hljs-string">red</span><br></code></pre></td></tr></table></figure></li><li><p>config-2 的配置内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># config-2配置</span><br><span class="hljs-attr">username</span>: <span class="hljs-string">test_user2</span><br><span class="hljs-meta">feature.status</span>: <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure></li><li><p>config-1 和 config-2 先后发布到部署组 group ，会按照 key 来进行合并。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># config-1 与 config-2 合并结果</span><br><span class="hljs-attr">username</span>: <span class="hljs-string">test_user2</span><br><span class="hljs-meta">feature.status</span>: <span class="hljs-string">true</span><br><span class="hljs-meta">feature.color</span>: <span class="hljs-string">red</span><br></code></pre></td></tr></table></figure></li><li><p>配置优先级：应用配置 &gt; 全局配置 &gt; 本地配置</p></li><li><p>多份应用发布到同一个部署组的时候按照优先级，先后循环进行合并；相同的配置项优先级高的 替换优先级低的，后发布的配置替换先发布的配置；不同的配置项之间合并</p></li></ul><h4 id="第三章-全局配置"><a href="#第三章-全局配置" class="headerlink" title="第三章 全局配置"></a>第三章 全局配置</h4><h5 id="3-1-全局配置概述"><a href="#3-1-全局配置概述" class="headerlink" title="3.1 全局配置概述"></a>3.1 全局配置概述</h5><ul><li>全局配置：<ul><li>用于动态更新应用代码中的配置。全局配置可以保证配置内容在某个集群或者命名空间中全局生效。</li></ul></li><li>全局配置包括管理配置和发布配置两部分。<ul><li>管理配置包括创建配置、生成新版本配置和删除配置。</li><li>配置可以发布到命名空间下的所有应用。</li></ul></li><li>全局配置的使用跟前面提到的“应用配置”使用一致；优先级不一样：</li><li>优先级：应用配置 &gt; 全局配置 &gt; 本地配置</li></ul><h5 id="3-1-全局配置概述（续）"><a href="#3-1-全局配置概述（续）" class="headerlink" title="3.1 全局配置概述（续）"></a>3.1 全局配置概述（续）</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203121236608.png" alt="image-20211203121236608"></p><ul><li>列表页面也跟应用页面一致。其中“新建”按钮可以直接新建配置，导入配置模块需要配置“配 置模板”功能使用，在后续会介绍；配置列表右侧的配置发布历史中可以查看配置的发布记录。</li></ul><h4 id="第四章-配置回调"><a href="#第四章-配置回调" class="headerlink" title="第四章 配置回调"></a>第四章 配置回调</h4><h5 id="4-1-配置回调使用场景"><a href="#4-1-配置回调使用场景" class="headerlink" title="4.1 配置回调使用场景"></a>4.1 配置回调使用场景</h5><ul><li><p>配置更新触发回调功能允许程序在不重启的情况下动态修改业务逻辑。</p></li><li><p>当配置更新时，触发配置回调方法的调用。</p></li><li><p>配置更新触发回调功能的使用场景包括：</p><ul><li>程序使用一个防刷开关配置，当开关为启用状态时，启动防刷逻辑，当开关为关闭状 态时，停用防刷逻辑。</li><li>程序使用一个 ReidsConfig 的动态配置类，包含 redis 的 host 和 port，当更新这个配置时，更新 Redis 实例。</li><li>配置更新后发出通知消息，通知本地或者远程的其他模块执行变更逻辑。</li></ul></li><li><p>前面我们已经使用了配置项的动态更新，但是如果更新配置项后需要刷新其它业务对象（比如更 改Redis配置后需要刷新Redis实例对象）怎么办？这个时候就需要用到我们的配置回调功能。</p></li></ul><h5 id="4-2-使用方式-配置回调"><a href="#4-2-使用方式-配置回调" class="headerlink" title="4.2 使用方式-配置回调"></a>4.2 使用方式-配置回调</h5><ul><li><p>如下图代码：如果配置项“io.test”发生变化，就会触发callback方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigChangeListener(prefix = &quot;io.test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfigListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigChangeCallback</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger =<br>    LoggerFactory.getLogger(SimpleConfigurationListener.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(ConfigProperty lastConfigItem, ConfigProperty</span></span><br><span class="hljs-params"><span class="hljs-function">    currentConfigItem)</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;config change=====&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如上代码实现了监听“io.test”配置，当配置发生变化就触发callback方法打印日志</li><li>实现方式：通过实现ConfigChangeCallback 接口（重新callback方法）实现配置回调。</li></ul></li></ul><h4 id="第五章-配置模板"><a href="#第五章-配置模板" class="headerlink" title="第五章 配置模板"></a>第五章 配置模板</h4><h5 id="5-1-配置模板概述"><a href="#5-1-配置模板概述" class="headerlink" title="5.1 配置模板概述"></a>5.1 配置模板概述</h5><ul><li><p>配置模板</p><ul><li><p>是为了方便用户保存常用的配置信息，也提供了 Ribbon, Hystrix, Zuul 等 Spring Cloud 组件的配置模板。用户可以基于已有的配置模板进行修改。</p></li><li><p>用户可以基于配置模板来创建 应用配置 或者 全局配置。</p></li></ul></li></ul><h5 id="5-2-新建和使用配置模板"><a href="#5-2-新建和使用配置模板" class="headerlink" title="5.2 新建和使用配置模板"></a>5.2 新建和使用配置模板</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203150623409.png"></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203150807471.png"></p><ul><li><p>具体使用步骤：</p><ul><li><p>登录 TSF 控制台。</p></li><li><p>单击左侧导航栏 配置管理，再选择 配置模板。</p></li><li><p>单击【新建模板】</p></li><li><p>填写配置模板信息。</p></li><li><p>模板名：填写模板名。</p></li><li><p>类型：Ribbon、Hystrix、Zuul 或自定义。</p></li><li><p>配置内容：根据不同的类型，会自动生成对应的配置内容。用户可以进一步修改配置内容。</p></li><li><p>描述：填写描述信息。</p></li><li><p>单击【提交】按钮。</p></li></ul></li></ul><h5 id="5-2-新建和使用配置模板（续）"><a href="#5-2-新建和使用配置模板（续）" class="headerlink" title="5.2 新建和使用配置模板（续）"></a>5.2 新建和使用配置模板（续）</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203151117672.png" alt="image-20211203151117672"></p><ul><li>用户可以使用配置模板来创建应用配置或者全局配置，下面以全局配置举例。<ul><li>登录 TSF 控制台。</li><li>单击左侧导航栏 配置管理，再选择 全局配置。</li><li>单击【导入配置模板】。</li><li>选择要导入的配置模板</li><li>在新建配置页面中，补充全局配置的其他信息</li></ul></li></ul><h4 id="第六章-文件配置"><a href="#第六章-文件配置" class="headerlink" title="第六章 文件配置"></a>第六章 文件配置</h4><h5 id="6-1-文件配置概述"><a href="#6-1-文件配置概述" class="headerlink" title="6.1 文件配置概述"></a>6.1 文件配置概述</h5><ul><li><p>文件配置：</p><ul><li>文件配置功能支持用户通过控制台将配置下发到服务器的指定目录。应用程序通过读 取该目录下的配置文件来实现特殊的业务逻辑。</li></ul></li><li><p>文件配置支持如下功能：</p><ul><li>创建文件配置项：一个文件配置项管理多个版本的配置。</li><li>生成新版本：基于历史版本生成新版本。</li><li>发布配置：支持发布配置到部署组。</li><li>发布情况：查看配置项的发布到哪些部署组。</li><li>回滚：回滚到上一个版本的配置。</li></ul></li></ul><h5 id="6-1-文件配置概述（续）"><a href="#6-1-文件配置概述（续）" class="headerlink" title="6.1 文件配置概述（续）"></a>6.1 文件配置概述（续）</h5><ul><li><p>使用文件配置的前提条件：</p><ul><li><p>对于使用虚拟机部署的应用：只有2018年11月20号之后导入到集群的云主机上会具有 满足应用配置功能的环境。</p></li><li><p>对于容器部署的应用：该功能需要用户修改 Dockerfile 和启动脚本</p><ul><li><p>Dockerfile 中需要将 tsf-consul-template-docker.tar.gz添加到到 /root/ 目录下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#copy consul-template</span><br><span class="hljs-keyword">ADD</span><span class="bash"> tsf-consul-template-docker.tar.gz /root/</span><br></code></pre></td></tr></table></figure></li><li><p>启动脚本 run.sh 中，需要执行 /root/tsf-consul-template-docker/script 目录下的start.sh 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh /root/tsf-consul-template-docker/script/start.sh<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>tsf-consul-template-docker.tar.gz下载地址： <a href="https://main.qcloudimg.com/raw/fa79996a5c995c35b9f948742df4d9d8/tsf-consultemplate-docker.tar.gz">https://main.qcloudimg.com/raw/fa79996a5c995c35b9f948742df4d9d8/tsf-consultemplate-docker.tar.gz</a></p></li></ul><h5 id="6-2-文件配置使用场景"><a href="#6-2-文件配置使用场景" class="headerlink" title="6.2 文件配置使用场景"></a>6.2 文件配置使用场景</h5><ul><li><p>定时检查配置是否更新</p><ul><li>应用程序中包含了读取指定目录配置文件的逻辑，例如定时去检查配置文件是否更新 （通过文件 md5 是否变化等方式检查），如果更新了会执行特定逻辑。</li><li>在控制台上创建文件配置，下发到部署组。</li></ul></li><li><p>动态替换 PHP 文件</p><ul><li>通过控制台发布一个 PHP 文件到指定目录，来达到动态替换服务器上 PHP 文件的目 的。</li></ul></li></ul><h5 id="6-3-文件配置操作步骤"><a href="#6-3-文件配置操作步骤" class="headerlink" title="6.3 文件配置操作步骤"></a>6.3 文件配置操作步骤</h5><ul><li><p>文件配置的使用步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203151921430.png" alt="image-20211203151921430"></p></li></ul><h6 id="6-3-1-新建配置"><a href="#6-3-1-新建配置" class="headerlink" title="6.3.1 新建配置"></a>6.3.1 新建配置</h6><ul><li><p>步骤一：</p><ul><li><p>新建配置：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203152015670.png" alt="image-20211203152015670"></p></li></ul></li><li><p>具体操作步骤：</p><ul><li>登录 TSF 控制台。</li><li>在左侧导航栏中，单击【配置管理】&gt;【文件配置】。</li><li>在文件配置页面，单击【新建】按钮。</li></ul></li></ul><h6 id="6-3-2-填写配置信息"><a href="#6-3-2-填写配置信息" class="headerlink" title="6.3.2 填写配置信息"></a>6.3.2 填写配置信息</h6><ul><li><p>步骤二：</p><ul><li><p>填写配置信息：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203152340703.png" alt="image-20211203152340703"></p></li></ul></li><li><p>文件配置信息</p><ul><li>配置名称</li><li>关联应用</li><li>文件保存编码</li><li>配置内容：支持上传文件或者控制台编辑</li><li>配置文件名称：下发到服务器的配置文件的文件名称</li><li>版本号</li><li>版本描述</li></ul></li></ul><h6 id="6-3-3-配置下发路径信息以及后置脚本"><a href="#6-3-3-配置下发路径信息以及后置脚本" class="headerlink" title="6.3.3 配置下发路径信息以及后置脚本"></a>6.3.3 配置下发路径信息以及后置脚本</h6><ul><li>步骤三：<ul><li>配置下发路径信息以及后置脚本：</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203152312232.png" alt="image-20211203152312232"></p><ul><li><p>配置下发路径：配置下发到服务器的路径</p></li><li><p>后置脚本（选填）：配置下发到服务器后执行的命令（不需要 包含 #! /bin/bash)</p></li><li><p>点击“完成”后就可以完成文件配置的创建功能，可以登录到具体服务目录下进行查看验证。</p></li></ul><h5 id="6-4-文件配置基本操作说明"><a href="#6-4-文件配置基本操作说明" class="headerlink" title="6.4 文件配置基本操作说明"></a>6.4 文件配置基本操作说明</h5><ul><li>基本操作包含：<ol><li>生成新版本<ul><li>在配置列表页，单击配置名称进入详情页。</li><li>单击某个配置版本旁的【生成新版本】按钮。</li><li>填写变更的新版本的配置内容和版本号。</li><li>单击【完成】按钮。</li></ul></li><li>发布配置<ul><li>在配置列表页，单击配置名称进入详情页。</li><li>单击某个配置版本旁的【发布】按钮。</li><li>选择配置发布的目标部署组，填写发布描述。</li><li>单击【提交】。</li></ul></li><li>查看配置发布历史<ul><li>在文件配置页，单击配置发布历史标签页。</li><li>选择目标部署组 ，单击【查询】。</li></ul></li><li>配置回滚<ul><li>在文件配置页，单击配置发布历史标签页。</li><li>单击配置发布历史列表右侧的【回滚】按钮。</li><li>填写回滚说明，单击【提交】。</li></ul></li></ol></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li>TSF配置管理的方式有哪几种？</li><li>TSF配置的优先级是怎么样的？</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九、TSF服务治理</title>
    <link href="/2021/12/02/%E4%B9%9D%E3%80%81TSF%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <url>/2021/12/02/%E4%B9%9D%E3%80%81TSF%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="九、TSF服务治理"><a href="#九、TSF服务治理" class="headerlink" title="九、TSF服务治理"></a>九、TSF服务治理</h3><p>在介绍完TSF的运维管理能力以后，我们接下来看一下TSF的服务治理功能。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，你将可以：</p><ul><li>掌握服务基本操作</li><li>掌握服务鉴权概述与基本操作</li><li>了解服务限流</li><li>掌握服务路由基本原理</li><li>掌握服务路由使用方法</li><li>了解服务路由最佳实践</li></ul><h4 id="第一章-服务基本操作"><a href="#第一章-服务基本操作" class="headerlink" title="第一章 服务基本操作"></a>第一章 服务基本操作</h4><p>首先我们来看一下在TSF平台中的服务基本操作</p><h5 id="1-1-服务发现"><a href="#1-1-服务发现" class="headerlink" title="1.1 服务发现"></a>1.1 服务发现</h5><ul><li><p>Spring Cloud、Dubbo、Mesh都可以在服务注册中心直接发现服务，并展示在服务列表中。</p></li><li><p>创建服务的服务名和注册中心服务一致时，会认为是同一个服务。</p></li><li><p>手动创建服务的应用场景：支持用户在服务上线之前配置服务治理规则。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202170132555.png" alt="image-20211202170132555"></p></li><li><p>服务发现通俗的讲就是不同服务查找发现其它服务的过程。</p></li><li><p>微服务框架，如Spring Cloud,Dubbo,TSF都提供了服务注册中心。通过服务注册中心微服务可 以很简单的发现其它服务。</p></li></ul><h5 id="1-2-服务治理概述"><a href="#1-2-服务治理概述" class="headerlink" title="1.2 服务治理概述"></a>1.2 服务治理概述</h5><ul><li>服务治理：<ul><li>用于对用户运行业务的统一管理，包含对线上流量的管控、服务监控与告警、权限的 限制、抑制线上突发情况等。</li><li>TSF提供了一个统一的入口对线上服务进行管理。</li></ul></li><li>现阶段 TSF 服务治理功能包含：<ul><li>服务鉴权</li><li>服务路由</li><li>服务限流</li></ul></li><li>通过服务注册中心解决了服务发现的问题后，接下来就可以对服务进行治理，比如对已经注册的服务进行监控告警，权限控制等。</li></ul><h5 id="1-2-服务治理概述-续"><a href="#1-2-服务治理概述-续" class="headerlink" title="1.2 服务治理概述(续)"></a>1.2 服务治理概述(续)</h5><ul><li>常见服务治理能力实现的功能：<ul><li>设置服务访问权限控制：白名单黑名单</li><li>设置带有某些标签的请求访问控制</li><li>设置流量最大限制，保护核心服务</li><li>灰度发布、蓝绿发布</li><li>部分用户内测功能</li><li>就近IP访问</li><li>容灾与熔断</li><li>服务API的管理</li></ul></li><li>灰度发布：灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB Test 就是一种灰度 发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没有什么反对意见，那 么逐步扩大范围，把所有用户都迁移到 B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</li><li>蓝绿发布：蓝绿部署是不停老版本，部署新版本然后进行测试。确认OK后将流量切到新版本，然后老版本同时也升级到新版本。</li><li>服务容灾与熔断：服务器故障死机，服务雪崩，网络环境恶劣等都属于服务事故，为了避免出现服务的雪崩，我们需要对服务做容灾/熔断处理等策略避免导致服务不可用对用户造成影响。 2015年9月7日，上交所、深交所、中金所宣布，拟在保留现有个股涨跌幅制度前提下，引入指数熔断机制。随后A股联系两天下跌熔断，提前收盘。其中这里的熔断机制和我们今天讨论的熔 断器思路一致，但是反而导致了A股暴跌，这也说明了我们还是得从根源产出高可用的服务，而 不是依赖某些外部措施帮助我们提高可用性。</li></ul><h6 id="1-2-1-API列表"><a href="#1-2-1-API列表" class="headerlink" title="1.2.1 API列表"></a>1.2.1 API列表</h6><ul><li>查看服务提供哪些 API</li><li>查看 API 的详情</li><li>TSF提供了API列表功能，用户登录TSF控制台以后可以在服务治理中查看对应的服务，点击进入具体服务后可以查看当前服务的AIP列表。</li></ul><h6 id="1-2-2-API列表-（Spring-Cloud）"><a href="#1-2-2-API列表-（Spring-Cloud）" class="headerlink" title="1.2.2 API列表 （Spring Cloud）"></a>1.2.2 API列表 （Spring Cloud）</h6><ul><li><p>Spring Cloud应用如果需要使用TSF平台的API列表功能，需执行如下操作：</p><ul><li><p>在项目根路径下的pom.xml 配置文件中引用如下依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-swagger<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 调整为 SDK 最新版本号 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在代码中无须额外设置</p></li></ul></li><li><p>TSF 框架在微服务注册时，会自动收集并注册微服务提供的 API 接口，用户可通过 TSF 控制台实 时掌握当前微服务提供的 API 情况。API 注册功能基于 OpenApi Specification 3.0 规范注册 API 元数据信息。 用户在查看 API 接口的同时，可查看到 API 出入参数据结构信息。</p></li><li><p> 添加依赖包后，TSF API 注册功能即生效。</p></li></ul><h6 id="1-2-3-API列表-（Mesh）"><a href="#1-2-3-API列表-（Mesh）" class="headerlink" title="1.2.3 API列表 （Mesh）"></a>1.2.3 API列表 （Mesh）</h6><ul><li><p>若Mesh应用需要使用TSF的API列表查询功能，需执行如下操作：</p><ul><li><p>在 Mesh 应用中创建apis目录，在目录中创建 API 描述文件（如：user.yaml）</p></li><li><p>API 描述文件格式参考下图</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202171358609.png" alt="image-20211202171358609"></p></li></ul></li><li><p>API 定义和上报：TSF 支持 Mesh 应用 API 上报功能。在应用程序所在目录中创建 apis 目录， 用来放置服务的 API 定义。一个服务对应一个 yaml 文件，文件名就是服务名，如 petstore 服 务对应的配置是 petstore.yaml。API 遵循 OPENAPI 3.0 规范 。配置文件遵循</p></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/19049">https://cloud.tencent.com/document/product/649/19049</a></p></li></ul><h6 id="1-2-4-标签设置"><a href="#1-2-4-标签设置" class="headerlink" title="1.2.4 标签设置"></a>1.2.4 标签设置</h6><ul><li>标签：<ul><li>用于信息分类，</li></ul></li><li>使用场景包括：<ul><li>服务鉴权：被调方通过标签决定是否提供服务。</li><li>服务路由：通过标签判断应该访问什么服务，可用于金丝雀发布。</li><li>服务限流：通过标签判断应用应该限制哪些请求。</li><li>调用链：可用于调用链的筛选和附带业务信息。</li></ul></li><li>标签主要用于信息分类，比如：给某个接口打上标签，后续在使用的时候可以根据标签进行鉴权， 路由操作。</li></ul><h6 id="1-2-5-标签设置（Spring-Cloud）"><a href="#1-2-5-标签设置（Spring-Cloud）" class="headerlink" title="1.2.5 标签设置（Spring Cloud）"></a>1.2.5 标签设置（Spring Cloud）</h6><ul><li><p>标签分类：</p><ul><li><p>系统自带标签：不需要代码改动。</p></li><li><p>自定义标签：需要在代码中设置标签内容（KV对）。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202171847331.png" alt="image-20211202171847331"></p></li></ul></li><li><p>标签分为：系统标签和自定义标签；系统标签是TSF已经定义好的标签（如服务名），可以直接 在TSF控制台使用，无需代码改动；自定义标签是需要在代码中设置的标签，标签以键值对的形 式设置，然后再通过TSF控制台配置使用。</p></li></ul><h6 id="1-2-5-标签设置（Spring-Cloud）-续"><a href="#1-2-5-标签设置（Spring-Cloud）-续" class="headerlink" title="1.2.5 标签设置（Spring Cloud）(续)"></a>1.2.5 标签设置（Spring Cloud）(续)</h6><ul><li><p>自定义标签：需要在代码中设置</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202172059493.png" alt="image-20211202172059493"></p></li><li><p>自定义标签可以在代码中通过TsfContext.putTag(tagName, tagValue);方式设置标签。</p></li></ul><h6 id="1-2-6-标签设置（Mesh）"><a href="#1-2-6-标签设置（Mesh）" class="headerlink" title="1.2.6 标签设置（Mesh）"></a>1.2.6 标签设置（Mesh）</h6><ul><li><p>Mesh 支持通过 HTTP Header 设置自定义标签。</p></li><li><p>下图为 Python 应用中通过 HTTP header 设置自定义标签。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202172159941.png" alt="image-20211202172159941"></p></li><li><p>Mesh应用对于系统标签的使用跟Spring Cloud应用是一致的；Mesh应用使用自定义标签需要在 http请求的header中设置自定义标签。</p></li></ul><h4 id="第二章-服务鉴权概述与基本操作"><a href="#第二章-服务鉴权概述与基本操作" class="headerlink" title="第二章 服务鉴权概述与基本操作"></a>第二章 服务鉴权概述与基本操作</h4><p>介绍完服务的基本操作，我们接下来看一下TSF中的服务鉴权功能</p><h5 id="2-1-服务鉴权概述"><a href="#2-1-服务鉴权概述" class="headerlink" title="2.1 服务鉴权概述"></a>2.1 服务鉴权概述</h5><ul><li>服务鉴权：<ul><li> 服务鉴权是处理微服务之间相互访问权限问题的解决方案。配置中心下发鉴权规则到服务，当请 求到来时，服务根据鉴权规则判断鉴权结果，如果鉴权通过，则继续处理请求，否则返回鉴权失败的 HTTP 状态码 403（Forbidden）。</li><li>使用场景：<ul><li>控制核心服务（如账户钱财相关服务）的访问权限</li></ul></li></ul></li><li>目前 TSF 提供两种类型的服务鉴权规则：<ul><li>基于黑名单的鉴权规则</li><li>基于白名单的鉴权规则</li></ul></li><li>鉴权规则支持标签形式配置：系统标签，自定义标签</li></ul><h6 id="2-1-1-服务鉴权图解"><a href="#2-1-1-服务鉴权图解" class="headerlink" title="2.1.1 服务鉴权图解"></a>2.1.1 服务鉴权图解</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202173105996.png" alt="image-20211202173105996"></p><ul><li>上图为基于 标签（Tag）的鉴权流程：<ul><li>在服务消费者的业务代码中设置 标签信息。</li><li>通过 TSF 控制台下发鉴权规则给服务提供者。</li><li>服务消费者在调用服务提供者的接口时，会带上标签信息。服务提供者的鉴权模块会根据鉴 权规则和请求来判断鉴权是否通过，如果通过，继续处理请求；如果不通过，将收到 HTTP 返回码 403（Forbidden）。</li></ul></li></ul><h6 id="2-1-2-黑白名单概述"><a href="#2-1-2-黑白名单概述" class="headerlink" title="2.1.2 黑白名单概述"></a>2.1.2 黑白名单概述</h6><ul><li>白名单：<ul><li>当请求匹配 任意一条 鉴权规则 时，允许调用；否则拒绝调用。</li></ul></li><li>黑名单：<ul><li>当请求匹配 任意一条 鉴权规则 时，拒绝调用；否则允许调用。</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202174810728.png" alt="image-20211202174810728"></p><ul><li>服务鉴权分为二大类：黑名单鉴权方式，白名单鉴权方式，鉴权的基本流程如上图</li></ul><h6 id="2-1-3-黑白名单示例"><a href="#2-1-3-黑白名单示例" class="headerlink" title="2.1.3 黑白名单示例"></a>2.1.3 黑白名单示例</h6><ul><li>白名单鉴权方式示例：<ul><li>如：鉴权规则内容是 username 等于 foo，当请求中带有 username=foo 的 tag 时 ，因为匹配规则，服务允许调用；当请求中带有 username=bar 的 tag 时，因为不匹 配规则，服务拒绝调用。</li></ul></li><li>黑名单鉴权方式示例：<ul><li>如：鉴权规则内容是 username 等于 foo，当请求中带有 username=foo 的 tag 时 ，因为匹配规则，服务拒绝调用；当请求中带有 username=bar 的 tag 时，因为不匹 配规则，服务允许调用。</li></ul></li><li>如上用2个例子来说明二种鉴权方式</li><li> 鉴权规则</li><li>鉴权规则的关系：一个服务可能有多个鉴权规则，多个鉴权规则之间是逻辑或（OR）的关系， 只要请求满足任意一条鉴权规则，就相当于匹配成功。</li><li>逻辑关系与值个数的关系：一条标签中，值的个数与逻辑关系的关系如下：<ul><li>逻辑关系 值个数</li><li>包含（IN）                    多个</li><li>不包含（ NOT IN）       多个</li><li>等于（==）                   一个</li><li>不等于（!=）                 一个</li><li>正则表达式（regex）    一个</li></ul></li></ul><h5 id="2-2-服务鉴权基本操作"><a href="#2-2-服务鉴权基本操作" class="headerlink" title="2.2 服务鉴权基本操作"></a>2.2 服务鉴权基本操作</h5><ul><li><p>服务鉴权功能基本操作步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202175343067.png" alt="image-20211202175343067"></p></li><li><p>服务鉴权的基本操作如上图所示</p></li></ul><h6 id="2-2-1-配置依赖项"><a href="#2-2-1-配置依赖项" class="headerlink" title="2.2.1 配置依赖项"></a>2.2.1 配置依赖项</h6><ul><li>步骤 一：<ul><li>应用配置依赖项：添加依赖配置<ul><li>Spring Cloud 应用，添加spring-cloud-tsf-auth依赖</li><li>Mesh 应用，无须额外配置</li></ul></li></ul></li><li>对于 Spring Cloud 应用，需要添加spring-cloud-tsf-auth依赖。</li><li>对于 Mesh 应用，无须额外配置。</li><li>官网文档：<a href="https://cloud.tencent.com/document/product/649/15549">https://cloud.tencent.com/document/product/649/15549</a></li></ul><h6 id="2-2-1-配置依赖项（Spring-Cloud）"><a href="#2-2-1-配置依赖项（Spring-Cloud）" class="headerlink" title="2.2.1 配置依赖项（Spring Cloud）"></a>2.2.1 配置依赖项（Spring Cloud）</h6><ul><li><p>Spring Cloud 应用添加配置项：</p><ul><li><p>在项目工程根目录的pom.xml中添加依赖，具体依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-auth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!-- 调整为 SDK 最新版本号 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>项目启动类上添加@EnableTsfAuth注解，如下图</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202175822199.png" alt="image-20211202175822199"></p></li></ul></li></ul><h6 id="2-2-2-配置鉴权规则"><a href="#2-2-2-配置鉴权规则" class="headerlink" title="2.2.2 配置鉴权规则"></a>2.2.2 配置鉴权规则</h6><ul><li><p>步骤二：</p><ul><li>配置鉴权规则：<ul><li>步骤 1：选择鉴权方式，如白名单</li><li>步骤 2：新建鉴权规则</li><li>步骤 3：填写规则名</li><li>填写鉴权标签：系统标签或者自定义标签</li><li>选择是否立即生效规则</li></ul></li></ul></li><li><p>可以通过黑名单，白名单的方式添加鉴权规则；</p></li><li><p>在服务详情的【服务鉴权】标签页，选择鉴权方式：</p><ul><li>不启用：关闭鉴权功能。</li><li>白名单：匹配任意一条规则的请求，允许调用。</li><li>黑名单：匹配任意一条规则的请求，拒绝调用。</li></ul></li></ul><h6 id="2-2-3-切换鉴权规则（可选）"><a href="#2-2-3-切换鉴权规则（可选）" class="headerlink" title="2.2.3 切换鉴权规则（可选）"></a>2.2.3 切换鉴权规则（可选）</h6><ul><li><p>步骤三：</p><ul><li>切换鉴权方式：该步骤可以选：从一种鉴权模式切换到另外一种鉴权模式<ul><li>白名单切换到黑名单（或黑名单切换到白名单）：保留鉴权规则，但鉴权逻辑逆转。如果用 户希望切换后，使用新的规则，则需要删除原有的，再创建新的规则。</li><li>白名单（或黑名单）切换到不启用：关闭鉴权功能。</li></ul></li></ul></li><li><p>鉴权的效果检查：设置并启用了鉴权规则以后只需要访问对应的服务，可通过在浏览器访问接口 方式验证，如：启用黑名单，当符合黑名单规则后接口应该不能访问；使用白名单规则：只有在 符合白名单里面的规则才能正常访问接口；</p></li></ul><h4 id="第三章-服务限流概述与基本操作"><a href="#第三章-服务限流概述与基本操作" class="headerlink" title="第三章 服务限流概述与基本操作"></a>第三章 服务限流概述与基本操作</h4><p>接下来我们看一下TSF的服务限流功能</p><h5 id="3-1-服务限流"><a href="#3-1-服务限流" class="headerlink" title="3.1 服务限流"></a>3.1 服务限流</h5><ul><li><p>服务限流：</p><ul><li><p><strong>服务限流主要是保护服务节点或者数据节点，防止瞬时流量过大使服务和数据崩溃， 造成服务不可用。</strong></p></li><li><p>限流原理：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202181653474.png" alt="image-20211202181653474"></p></li></ul></li><li><p>服务限流目的</p><ul><li>限流主要是保护服务节点或者数据节点，防止瞬时流量过大使服务和数据崩溃，造成服务不可用。当资源成为瓶颈时，服务框架需要对请求做限流，启动流控保护机制</li></ul></li><li><p>服务限流原理</p><ul><li>在服务提供者端配置限流依赖项，在 TSF 控制台配置限流规则。此时服务消费者去调用服务 提供者时，所有的访问请求都会通过限流模块进行计算，若服务消费者调用量在一定时间内超 过了预设阈值，则会触发限流策略，进行限流处理。</li></ul></li><li><p>TSF限流方案</p><ul><li>TSF 限流方案采用了动态配额分配制，限流中控根据实例的历史流量记录，动态计算预测下一时刻该实例的流量，若所有实例的流量预测值都小于额定平均值（总配额/在线实例数），则以该平均值作为所有实例分配的配额；否则按预测流量的比例分配，且保证一个最小值。</li></ul></li></ul><h5 id="3-2-服务限流使用场景"><a href="#3-2-服务限流使用场景" class="headerlink" title="3.2 服务限流使用场景"></a>3.2 服务限流使用场景</h5><ul><li><p>限流粒度-全局限流</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202181909263.png" alt="image-20211202181909263"></p></li><li><p>全局限流：服务设置一个最大的 QPS（每秒请求数） 阈值 T，当服务实际接收到的每秒请求数超 过 T 时，触发限流。</p></li></ul><ul><li><p>限流粒度-标签限流</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202182154734.png" alt="image-20211202182154734"></p></li><li><p>基于标签限流：服务设置【基于标签】的限流规则（更细粒度的限流）</p><ul><li>示例1：设置自定义标签 username=foo 的 QPS 阈值 1000 次/秒，当服务实际接收到的请求中包含了标签username=foo 的 QPS 超过 1000 次/秒 时，触发限流。</li><li>示例2：设置自定义标签 “ username 包含 foo, bar “ 的 QPS 阈值 1000 次/秒，当服务实际 接收到的请求中包含了标签 username=foo 或 username=bar 的 QPS 超过 1000 次/秒 时， 触发限流。</li></ul></li></ul><h5 id="3-3-服务限流实现步骤"><a href="#3-3-服务限流实现步骤" class="headerlink" title="3.3 服务限流实现步骤"></a>3.3 服务限流实现步骤</h5><ul><li><p>服务限流操作步骤：</p><ul><li><p>Mesh 应用：不需要改造代码，如果希望使用基于标签的限流，需要在代码中设置标签</p></li><li><p>Spring Cloud应用：实现步骤如下图：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202182314496.png" alt="image-20211202182314496"></p></li></ul></li><li><p>Spring Cloud应用实现限流功能操作步骤如上图：</p></li></ul><h6 id="3-3-1-添加服务限流依赖"><a href="#3-3-1-添加服务限流依赖" class="headerlink" title="3.3.1 添加服务限流依赖"></a>3.3.1 添加服务限流依赖</h6><ul><li><p>步骤一：</p><ul><li><p>Spring Cloud项目根目录pom.xml配置文件中添加依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-ratelimit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 调整为 SDK 最新版本号 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>项目根目录的pom.xml配置文件中添加如上依赖包</p></li></ul></li></ul><h6 id="3-3-2-添加限流注解"><a href="#3-3-2-添加限流注解" class="headerlink" title="3.3.2 添加限流注解"></a>3.3.2 添加限流注解</h6><ul><li><p>步骤二：</p><ul><li><p>Spring Cloud项目启动类中添加 @EnableTsfRateLimit 注解（开启服务限流功能）：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202182458533.png" alt="image-20211202182458533"></p></li></ul></li></ul><h6 id="3-3-3-新建限流规则并启用"><a href="#3-3-3-新建限流规则并启用" class="headerlink" title="3.3.3 新建限流规则并启用"></a>3.3.3 新建限流规则并启用</h6><ul><li><p>步骤三：</p><ul><li><p>新建限流规则并启用：</p><ul><li><p>全局限流</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202182601520.png" alt="image-20211202182601520"></p></li></ul></li></ul></li><li><p>限流规则生效的前提条件：服务列表上有 “在线” 状态的微服务。</p></li><li><p>具体操作步骤：</p><ul><li>登录 TSF 控制台。</li><li>在左侧导航栏，单击【服务治理】。</li><li>在服务列表页，单击服务名，进入服务详情页。</li><li>选择服务限流标签页，单击【新建限流规则】按钮。</li><li>填写限流规则信息。</li></ul></li></ul><h6 id="3-3-3-新建限流规则并启用（续）"><a href="#3-3-3-新建限流规则并启用（续）" class="headerlink" title="3.3.3 新建限流规则并启用（续）"></a>3.3.3 新建限流规则并启用（续）</h6><ul><li><p>步骤三：</p><ul><li><p>新建限流规则并启用：</p><ul><li><p>基于标签限流</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202182751252.png" alt="image-20211202182751252"></p></li></ul></li></ul></li><li><p>填写参数说明：</p><ul><li>规则名：填写规则名</li><li>限流粒度：<ul><li>全局限流：不区分限流来源，统计所有请求</li><li>基于标签限流：根据标签规则设置限流</li></ul></li><li>单位时间：正整数，单位：秒</li><li>请求数：正整数，单位：次</li><li>生效状态：是否立即启用限流规则</li><li>描述：填写描述信息</li></ul></li></ul><h6 id="3-3-4-查看限流效果"><a href="#3-3-4-查看限流效果" class="headerlink" title="3.3.4 查看限流效果"></a>3.3.4 查看限流效果</h6><ul><li>步骤四：<ul><li>查看限流效果：<ul><li>如果请求数达到了限流阈值，任何到达的请求都会被限流模块处理</li><li>如果该服务上的配额已经消耗完，会对请求返回 HTTP 429 （Too Many Requests）；否则 会正常放行。用户可以在限流 规则列表下方的请求数-时间图中查看到被限制的请求数或者被限制请求率-时间图中查看到被限 制请求率（计算公式 被限制请求率 = 被限制的请求数 / 请求数）随时间的变化。</li></ul></li><li>可以在浏览器访问接口查看限流效果。</li></ul></li><li>效果查看地址：TSF控制台-》服务治理-》进入具体某个服务-》进入服务限流标签页-》在限流规 则列表的下方可以查看限流效果</li></ul><h4 id="第四章-服务路由基本原理"><a href="#第四章-服务路由基本原理" class="headerlink" title="第四章 服务路由基本原理"></a>第四章 服务路由基本原理</h4><p>接下来我们来看一下TSF的服务路由功能</p><h5 id="4-1-服务路由概述"><a href="#4-1-服务路由概述" class="headerlink" title="4.1 服务路由概述"></a>4.1 服务路由概述</h5><ul><li><p>服务路由：</p><ul><li>符合特定要求的属性来选择服务的提供者，对服务间流量的分配起到掌控的作用</li><li>常见使用场景：<ul><li>灰度发布</li><li>部分账号内测</li><li>按照IP配置流量分配（如本地机房优先规则）</li></ul></li></ul></li><li><p>用户在使用 TSF 运行自己的业务时，由于业务的复杂程度，常常需要部署数目庞大的服务运行在现网环境中。这些服务运行在属性不同的实例上、部署在不同的地域中，用户经常需要选择符合自己特定要求的属性来选择服务的提供者，对服务间流量的分配起到掌控的作用。</p></li><li><p>同时，在微服务的场景下，用户研发新版本上线的迭代周期越来越快，稳定敏捷的上线新版本需 要微服务框架能够支持灰度发布、金丝雀发布、滚动发布等发布方式。通过服务路由功能，用户可以配置流量分配权重，设置某些权重的流量被分配到某个版本号中，为灰度发布等上线模式提供了无需终止服务的底层能力支持。为了保证满足客户的定制化需求，TSF 支持用户定制自己的 路由标签，并支持选择不同的逻辑形式配置标签值，定向分配流量。 总而言之，服务路由功能的主要作用是将调用流量按照自己的需求进行分配。</p></li></ul><h5 id="4-2-服务路由功能"><a href="#4-2-服务路由功能" class="headerlink" title="4.2 服务路由功能"></a>4.2 服务路由功能</h5><ul><li><p>TSF 配置服务路由功能支持以下三种配置来源：</p><ol><li><strong>按照权重方式配置路由规则</strong>。<ul><li>在需要配置服务路由的服务下面，用户可以选择配置流量的权重， 将部分权重的请求流量分配到服务提供方的某个版本下或某个部署组下。</li></ul></li><li><strong>按照系统自带标签的方式进行配置路由规则</strong>。<ul><li>每一个 TSF 上运行的服务都已经被预先设置好了某 些标签，如发起请求的服务消费方所在的部署组、IP、服务发起方的版本号等等。用户可以选择 这些标签，并配置标签值的特定规则，分配带有某些流量的标签到服务提供方的某个部署组上进行处理。在标签值的配置上，用户可以填写“包含、不包含”，“等于、不等于”，正则表达式 等等灵活的规则。</li></ul></li><li><strong>按照用户自定义的标签进行配置路由规则</strong>。<ul><li>TSF提供了用户配置自定义标签的SDK，在实际的使 用中，如果系统自带标签不能保证用户使用的场景，用户可以自定义标签内容，在SDK中进行配 置，并在控制台上配置相同的标签，控制服务消费方提供的流量按照配置的方式流入服务提供方。</li></ul></li></ol></li></ul><h5 id="4-3-服务路由使用方法（Spring-Cloud）"><a href="#4-3-服务路由使用方法（Spring-Cloud）" class="headerlink" title="4.3 服务路由使用方法（Spring Cloud）"></a>4.3 服务路由使用方法（Spring Cloud）</h5><ul><li><p>服务路由功能实现步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202183633682.png" alt="image-20211202183633682"></p></li><li><p>Spring Cloud项目服务路由的实现步骤如上图：</p></li></ul><h6 id="4-3-1-添加依赖"><a href="#4-3-1-添加依赖" class="headerlink" title="4.3.1 添加依赖"></a>4.3.1 添加依赖</h6><ul><li><p>步骤一：</p><ul><li><p>Spring Cloud项目根目录中pom.xml配置文件中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-route<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="4-3-2-添加路由启动注解"><a href="#4-3-2-添加路由启动注解" class="headerlink" title="4.3.2 添加路由启动注解"></a>4.3.2 添加路由启动注解</h6><ul><li><p>步骤二：</p><ul><li><p>Spring Cloud项目启动类中添加@EnableTsfRoute注解（开启服务路由功能）：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202183931960.png" alt="image-20211202183931960"></p></li></ul></li></ul><h6 id="4-3-3-新建路由规则"><a href="#4-3-3-新建路由规则" class="headerlink" title="4.3.3 新建路由规则"></a>4.3.3 新建路由规则</h6><ul><li><p>步骤三：</p><ul><li><p>新建路由规则：</p><ul><li><p>进入服务路由规则界面</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202184047378.png" alt="image-20211202184047378"></p></li></ul></li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202184058901.png" alt="image-20211202184058901"></p><ul><li>具体操作步骤如下：<ul><li>登录 TSF 控制台。</li><li>选择左侧菜单中【服务治理】菜单项。</li><li>选择需要配置服务路由规则的服务，单击服务名称，进入服务详情页。</li><li>选择服务路由选项，单击【新建路由规则】。</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202184212849.png" alt="image-20211202184212849"></p><ul><li><h6 id="在1-0-10之后的版本中，用户可以混合配置权重和标签，更加精细的控制流量"><a href="#在1-0-10之后的版本中，用户可以混合配置权重和标签，更加精细的控制流量" class="headerlink" title="在1.0.10之后的版本中，用户可以混合配置权重和标签，更加精细的控制流量"></a>在1.0.10之后的版本中，用户可以混合配置权重和标签，更加精细的控制流量</h6></li></ul><h6 id="4-3-3-新建路由规则（续）"><a href="#4-3-3-新建路由规则（续）" class="headerlink" title="4.3.3 新建路由规则（续）"></a>4.3.3 新建路由规则（续）</h6><ul><li>系统标签说明：<ul><li>主调方服务名或应用名：拉取全量服务、应用列表。用途：设置不同主调服务、应用访问不同 版本或者部署组</li><li>主调应用版本号或主调部署组：设置不同版本、不同部署组的调用流量导入不同目的地。用途： 同一个主调服务下细分流量分配</li><li>主调方ip：用户可以使用正则表达式划分ip区间，实现按发起方ip配置流量分配。用途：就近 访问、同地域访问</li><li>被调方api和http method：实现api级别服务路由</li></ul></li></ul><h6 id="4-3-3-新建路由规则（续）-1"><a href="#4-3-3-新建路由规则（续）-1" class="headerlink" title="4.3.3 新建路由规则（续）"></a>4.3.3 新建路由规则（续）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 设置多个 tag。如果有某个 tag 之前已经被设置过，那么它的</span><br><span class="hljs-comment">值会被覆盖。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putTags</span><span class="hljs-params">(Map&lt;String, String&gt; tagMap,</span></span><br><span class="hljs-params"><span class="hljs-function">Tag.ControlFlag... flags)</span> </span>&#123;&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 设置单个 tag。如果该 key 之前已经被设置过，那么它的值会</span><br><span class="hljs-comment">被覆盖。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putTag</span><span class="hljs-params">(String key, String value,</span></span><br><span class="hljs-params"><span class="hljs-function">Tag.ControlFlag... flags)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>自定义标签说明<ul><li>自定义标签需要用户代码中设置</li><li>用户代码中需要依赖route，用途：设置用户自定义标签值，如用户账号等信息。</li></ul></li></ul><h6 id="4-3-3-新建路由规则（续）-2"><a href="#4-3-3-新建路由规则（续）-2" class="headerlink" title="4.3.3 新建路由规则（续）"></a>4.3.3 新建路由规则（续）</h6><ul><li>目的地配置：不设置标签的路由流量分配方法：<ul><li>标签设置为空</li><li>所属应用下拉选项为服务绑定的应用。当选择更多 应用时，展示为目前tsf平台下所有应用列表。</li><li>目的地类型：选择部署组表示流量按照部署组进行 导流。选择版本号表示，希望将流量按照不同的版 本进行分配。选择的部署组和版本号都是所在应用 下对应的部署组和版本号</li><li>权重之和必须为100。</li></ul></li><li>常见应用：灰度发布</li></ul><h6 id="4-3-3-新建路由规则（续）-3"><a href="#4-3-3-新建路由规则（续）-3" class="headerlink" title="4.3.3 新建路由规则（续）"></a>4.3.3 新建路由规则（续）</h6><ul><li><p>其他说明</p><ul><li><p>用户可以在同一个路由规则中设置多 个子规则，规则同时生效。</p></li><li><p>用户可以设置子规则优先级。设置优 先级的目的是当一条请求满足多个子 规则时，优先匹配规则的优先级。</p></li><li><p>路由规则列表页面，同时生效一条规则。最多创建10条。</p></li></ul></li></ul><h6 id="4-3-4-服务路由结果展示"><a href="#4-3-4-服务路由结果展示" class="headerlink" title="4.3.4 服务路由结果展示"></a>4.3.4 服务路由结果展示</h6><ul><li>步骤四：<ul><li>服务路由结果展示：</li><li>下图在20：16分开启服务路由，可以看到几分钟内生效效果</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202184943788.png" alt="image-20211202184943788"></p><ul><li>服务路由图形结果展示如上图</li><li>效果查看地址：TSF控制台-》服务治理-》进入具体某个服务-》进入服务路由标签页-》在路由规 则列表的下方可以查看上图流量效果。</li></ul><h5 id="4-4-服务路由容错保护"><a href="#4-4-服务路由容错保护" class="headerlink" title="4.4 服务路由容错保护"></a>4.4 服务路由容错保护</h5><ul><li><p>容错保护开关</p><ul><li>当用户开启容错保护时，流量目的地发生故障时，流量会随机分配给服务下其他部署 组，保证可用性。</li><li>当用户关闭容错保护时，流量目的地发生故障时，流量不会分配其他部署组，会直接报错</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211202185051639.png" alt="image-20211202185051639"></p></li><li><p>可以通过上图中红色框中按钮开启容错保护</p></li></ul><h4 id="第五章-服务路由最佳实践"><a href="#第五章-服务路由最佳实践" class="headerlink" title="第五章 服务路由最佳实践"></a>第五章 服务路由最佳实践</h4><p>接下来我们来看一下TSF中服务路由的最佳实践</p><h5 id="5-1-灰度发布"><a href="#5-1-灰度发布" class="headerlink" title="5.1 灰度发布"></a>5.1 灰度发布</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203100311394.png" alt="image-20211203100311394"></p><ul><li>可以通过TSF控制台-》服务治理-》服务路由 然后新建路由规则实现灰度发布，参考4.3内容</li></ul><h5 id="5-1-灰度发布（续）"><a href="#5-1-灰度发布（续）" class="headerlink" title="5.1 灰度发布（续）"></a>5.1 灰度发布（续）</h5><ul><li><p>配置单个服务不同版本的权重规则</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203100510558.png" alt="image-20211203100510558"></p></li><li><p>如上是配置单个服务的不同版本的路由权重规则实现灰度发布，参考4.3.3内容</p></li></ul><h5 id="5-2-同地机房优先"><a href="#5-2-同地机房优先" class="headerlink" title="5.2 同地机房优先"></a>5.2 同地机房优先</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203100632559.png" alt="image-20211203100632559"></p><ul><li>同地机房优先访问主要是为了解决在异地跨机房调用出现的网络延迟问题，通过路由配置把访问路由到最近的服务器，提高系统的响应速度</li></ul><h5 id="5-2-同地机房优先-续"><a href="#5-2-同地机房优先-续" class="headerlink" title="5.2 同地机房优先(续)"></a>5.2 同地机房优先(续)</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203100742051.png" alt="image-20211203100742051"></p><ul><li>如上图配置，首先在group1中放相同目的地部署组，然后把主调方ip为192.87开头的访问都路 由到group1中</li></ul><h5 id="5-3-部分帐号内测"><a href="#5-3-部分帐号内测" class="headerlink" title="5.3 部分帐号内测"></a>5.3 部分帐号内测</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203100921263.png" alt="image-20211203100921263"></p><ul><li> 部分账号内测主要是为了开启部分账号进行服务内测。</li></ul><h5 id="5-3-部分帐号内测（续）"><a href="#5-3-部分帐号内测（续）" class="headerlink" title="5.3 部分帐号内测（续）"></a>5.3 部分帐号内测（续）</h5><ul><li><p>代码中设置puttag为用户userId</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203101056321.png" alt="image-20211203101056321"></p></li><li><p>如上图所示配置，把userid 为10001-200006的账号全部路由到版本号为20181019133223的部 署组中。</p></li></ul><h4 id="第六章-服务熔断"><a href="#第六章-服务熔断" class="headerlink" title="第六章 服务熔断"></a>第六章 服务熔断</h4><p>接下来我们来看一下TSF中服务熔断</p><h5 id="6-1-服务熔断概述"><a href="#6-1-服务熔断概述" class="headerlink" title="6.1 服务熔断概述"></a>6.1 服务熔断概述</h5><ul><li>当下游的服务因为某种原因导致服务不可用或响应过慢时，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回。当下游服务恢复后，上游服务会恢复调用。</li><li>服务发现通俗的讲就是不同服务查找发现其它服务的过程。</li><li>微服务框架，如Spring Cloud,Dubbo,TSF都提供了服务注册中心。通过服务注册中心微服务可以很简单的发现其它服务。</li></ul><h5 id="6-1-服务熔断概述（续）"><a href="#6-1-服务熔断概述（续）" class="headerlink" title="6.1 服务熔断概述（续）"></a>6.1 服务熔断概述（续）</h5><ul><li><p>TSF 服务治理支持可视化熔断规则管理，支持设置服务、实例、API 三种隔离级别的熔断规则。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203101336698.png" alt="image-20211203101336698"></p></li></ul><h5 id="6-2-服务熔断原理"><a href="#6-2-服务熔断原理" class="headerlink" title="6.2 服务熔断原理"></a>6.2 服务熔断原理</h5><ul><li><p>服务熔断中涉及到关键概念熔断器，熔断器的状态转化如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203103734571.png" alt="image-20211203103734571"></p></li><li><p>熔断器的工作原理如下</p><ul><li>最开始处于closed状态，一旦检测到错误（或慢响应）达到一定阈值，便转为open状态，此时不再调用下游目标服务。</li><li>等待一段时间后，会转化为half open状态，尝试放行一部分请求到下游服务。</li><li>一旦检测到响应成功，回归到closed状态，也即恢复服务；否则回到open状态。</li></ul></li><li><p>其中熔断器从close变为open状态要同时满足以下2个条件：</p><ul><li>前提条件：在滑动时间窗口内至少有一定数量的请求（即最少请求数）</li><li>指标达到阈值：在滑动时间窗口内统计的错误请求率或慢请求率达到一定阈值</li></ul></li></ul><h5 id="6-3-服务熔断使用方法"><a href="#6-3-服务熔断使用方法" class="headerlink" title="6.3 服务熔断使用方法"></a>6.3 服务熔断使用方法</h5><ul><li><p>服务熔断功能实现步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203105140575.png" alt="image-20211203105140575"></p></li><li><p>目前 TSF 支持 Spring Cloud 应用的服务熔断，Mesh 应用的熔断功能将于近期发布。</p></li><li><p>Spring Cloud 熔断开发指南参考<a href="https://cloud.tencent.com/document/product/649/55488">链接名称</a>，注意 Spring Cloud 应用的服务熔断功能需要使用 1.19.0 版本及以上的 SDK，参考 <a href="https://cloud.tencent.com/document/product/649/38982">SDK 版本更新日志</a>。</p></li><li><p>不同于服务限流、路由和鉴权规则在被调服务上设置，服务熔断规则是在<strong>主调方服务</strong>上设置。</p></li><li><p>Spring Cloud项目服务熔断的实现步骤如上图：</p></li></ul><h6 id="6-3-1-添加依赖"><a href="#6-3-1-添加依赖" class="headerlink" title="6.3.1 添加依赖"></a>6.3.1 添加依赖</h6><ul><li><p>步骤一：</p><ul><li><p>Spring Cloud项目根目录中pom.xml配置文件中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="6-3-2-添加服务熔断的注解"><a href="#6-3-2-添加服务熔断的注解" class="headerlink" title="6.3.2 添加服务熔断的注解"></a>6.3.2 添加服务熔断的注解</h6><ul><li><p>步骤二：</p><ul><li><p>Spring Cloud项目启动类中添加@EnableTsf注解：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203110549101.png" alt="image-20211203110549101"></p></li></ul></li></ul><h6 id="6-3-3-关闭Hystrix"><a href="#6-3-3-关闭Hystrix" class="headerlink" title="6.3.3 关闭Hystrix"></a>6.3.3 关闭Hystrix</h6><ul><li><p>步骤三：</p><ul><li><p>在yaml配置文件中关闭 Hystrix：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>使用 TSF 熔断功能需要将 Hystrix 关闭（默认是关闭的，如果之前有打开还请关闭）。相关的容错功能请参考<a href="https://cloud.tencent.com/document/product/649/40582">服务容错</a>。</p></li></ul></li></ul><h6 id="6-3-4-进行熔断配置"><a href="#6-3-4-进行熔断配置" class="headerlink" title="6.3.4 进行熔断配置"></a>6.3.4 进行熔断配置</h6><ul><li><p>步骤四：</p><ul><li>进行熔断配置，目前支持两种方式的熔断配置：<ul><li>方式一：在线动态配置下发。</li><li>方式二：本地静态配置（适合本地联调使用，如果线上使用会被在线配置覆盖，请谨慎使用）， 配置在 yaml 配置文件中。</li></ul></li></ul></li><li><p>新建并启用熔断规则（假设用户希望在consumer-demo上针对下游服务provider-demo设置一个熔断策略）</p></li><li><p>登录 TSF 控制台，在左侧导航栏单击【服务治理】，单击consumer-demo服务进入服务详情页。</p></li><li><p>切换至【服务熔断】标签页，单击【新建熔断规则】，在创建熔断规则对话框中填写熔断规则：</p><ul><li>下游服务： 选择当前 provider-demo 所在命名空间和服务名。</li><li>隔离级别：根据业务场景需求设置隔离级别<ul><li>服务：选择服务隔离级别后，设置熔断策略各参数。</li><li>实例：选择实例隔离级别后，设置熔断策略各参数和最大熔断实例比率。</li><li>API：选择 API 隔离级别后，可选择不同的 API 设置熔断策略，熔断策略中各参数适用于 选中的每个 API。</li></ul></li><li>滑动时间窗口：用于统计熔断器关闭时的请求结果。</li><li>最少请求次数：配置熔断器可以计算错误率之前的最小请求数。</li><li>触发条件（满足以下任一条件触发熔断）：<ul><li>失败请求率：在滑动时间窗口内统计的失败请求占所有请求比率（失败请求是指响应状态 码为4XX和5XX，以及抛出异常的请求）。</li><li>慢请求率：在滑动时间窗口内统计的慢响应的请求占所有请求比率，其中「慢响应」的时 长支持配置</li></ul></li><li>开启到半开间隔：熔断器从 open 状态等待一段时间后变为 half-open 状态，尝试放行一部 分请求到下游服务。</li><li>最大熔断实例比率：该参数仅适用于实例隔离级别，用于控制最大熔断实例个数百分比，避免 下游服务所有实例被熔断导致级联雪崩。例如当下游服务有20个实例且最大熔断实例比率为50%，熔断器最多熔断10个实例。</li></ul></li><li><p>单击【完成】，跳转至熔断规则列表。</p></li><li><p>在熔断规则列表上，单击熔断规则的【启用】，启用该规则。</p></li></ul><h5 id="6-4-服务路由结果展示"><a href="#6-4-服务路由结果展示" class="headerlink" title="6.4 服务路由结果展示"></a>6.4 服务路由结果展示</h5><ul><li><p>服务路由结果展示：</p><ul><li><p>下图在20：16分开启服务路由，可以看到几分钟内生效效果</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211203111741031.png" alt="image-20211203111741031"></p></li></ul></li><li><p>服务路由图形结果展示如上图</p></li><li><p>效果查看地址：TSF控制台-》服务治理-》进入具体某个服务-》进入服务路由标签页-》在路由规 则列表的下方可以查看上图流量效果。</p></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li>TSF的服务治理主要包含哪些功能？</li><li>TSF服务治理的基本开发操作是怎么样？</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、TSF平台管理能力</title>
    <link href="/2021/11/30/%E5%85%AD%E3%80%81TSF%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B/"/>
    <url>/2021/11/30/%E5%85%AD%E3%80%81TSF%E5%B9%B3%E5%8F%B0%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="六、TSF平台管理能力"><a href="#六、TSF平台管理能力" class="headerlink" title="六、TSF平台管理能力"></a>六、TSF平台管理能力</h3><p>前面主要介绍了TSF基本概念，微服务的开发，使用TSF与微服务框架集成；其中TSF与微服务框架的集成，我们主要介绍了TSF与Spring Cloud，Dubbo，Service Mesh框架的集成；整个集成步骤我们也看到了，实际上是非常简单的，简单可以归纳为2个方面：一是依赖包，另一个是配置，通过这二方面可以快速的把Spring Cloud，Dubbo，Service Mesh应用迁移到TSF平台中。</p><p>在前面的内容中实际上我们还留下一个问题：Spring Cloud，Dubbo，Service Mesh应用改造 成了TSF应用以后要如何部署到TSF平台之中呢？要实现部署功能毫无疑问需要用到TSF平台的管 理能力，所以接下来我们先看一下TSF平台的管理能力，换句话说就是如何使用TSF平台。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以:</p><ul><li>掌握TSF权限的管理</li><li>了解如何使用TSF进行资源的隔离与管理</li><li>掌握TSF资源管理基础概念</li><li>学会使用部署组</li><li>学会使用应用程序包的管理</li><li>了解应用程序的启动参数</li><li>学会使用服务编排</li></ul><h4 id="第一章-TSF权限管理"><a href="#第一章-TSF权限管理" class="headerlink" title="第一章 TSF权限管理"></a>第一章 TSF权限管理</h4><p>在真正学习TSF控制台使用之前我们先来看一下几个重要的概念，首先我们来看一下TSF权限管理的基础概念。</p><h5 id="1-1-TSF权限概述"><a href="#1-1-TSF权限概述" class="headerlink" title="1.1 TSF权限概述"></a>1.1 TSF权限概述</h5><ul><li><p>为满足企业客户不同成员使用 TSF 平台的接口操作权限、资源操作权限的 需求，当前腾讯微服务平台支持主账号为子账号灵活分配不同角色、不同 数据集的权限。</p></li><li><p>当前 TSF 可以支持以下几种场景的使用：</p><ul><li><p>为子账号或协作者配置全部资源的全读写策略。</p></li><li><p>为子账号或协作者配置全部资源的部分操作权限，如可以为部分用户配置应用、微服 务、配置的全读写策略，以及集群、命名空间的只读策略。</p></li><li><p>为子账号和协作者配置某些资源（一个或多个）的读或写权限，如可以为不同的子账 号配置不同命名空间、不同应用的不可见、只读、全读写权限。</p></li></ul></li></ul><h6 id="1-1-1-TSF预设策略"><a href="#1-1-1-TSF预设策略" class="headerlink" title="1.1.1 TSF预设策略"></a>1.1.1 TSF预设策略</h6><ul><li>TSF 提供了 QcloudTSFFullAccess 和 QcloudTSFReadOnlyAccess 两条预设策略。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130163231826.png" alt="image-20211130163231826"></p><ul><li><p>操作步骤：</p><ul><li>在子账号和协作者使用 TSF 平台之前，需要进行以下几个步骤：<ol><li>按照 准备工作 中，“子账号和协作者使用 TSF”部分文档进行操作，这一步保证了用户使 用 TSF 时，TSF 访问 VPC、 TKE 等云资源的服务角色权限。</li><li>按照 角色管理、数据集管理、授权管理 三个文档进行操作，配置子账号和协作者使用 TSF 平台时操作和数据集权限。</li></ol></li><li>预设策略只限制用户操作，没有对数据进行过滤。当用户对数据过滤没有需求时，可以只绑定预设策略即可，无需进行上述使用步骤中的步骤2（步骤1还需要进行）。</li></ul></li></ul><h5 id="1-2-TSF角色管理"><a href="#1-2-TSF角色管理" class="headerlink" title="1.2 TSF角色管理"></a>1.2 TSF角色管理</h5><ul><li><p>角色管理是配置子账号与协作者使用 TSF 的操作权限。当前 TSF 平台采取白名单机制，如子账号和协作者没有被授权任何角色，则无法使用 TSF 平台。</p></li><li><p>角色管理的操作步骤为：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130164753811.png" alt="image-20211130164753811"></p></li></ul><h6 id="1-2-1-新建角色"><a href="#1-2-1-新建角色" class="headerlink" title="1.2.1 新建角色"></a>1.2.1 新建角色<img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130165203594.png" alt="image-20211130165203594"></h6><ul><li>新增角色：<ul><li>登录 TSF 控制台。</li><li>在左侧导航栏，单击【管理中心】下的【角色管理】。</li><li>在角色管理页面，单击页面左上角的【新建角色】。</li><li>在新建角色页面，填写角色名称并选择角色权限。</li><li>单击【提交】，完成角色创建。</li></ul></li><li>说明：<ul><li>角色权限中的通用权限包含的 TSF 访问概览页面、监控等页面的基本操作，建议对所有用户授权。</li><li>日志告警、服务告警、部署组告警等告警策略的配置在云监控页面配置，不受 TSF 权限管控。</li><li>镜像仓库列表不受 TSF 权限管控。</li></ul></li></ul><h6 id="1-2-2-编辑角色"><a href="#1-2-2-编辑角色" class="headerlink" title="1.2.2 编辑角色"></a>1.2.2 编辑角色</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130165431277.png" alt="image-20211130165431277"></p><h6 id="1-2-3-删除角色"><a href="#1-2-3-删除角色" class="headerlink" title="1.2.3 删除角色"></a>1.2.3 删除角色</h6><ul><li><p>角色管理的操作步骤为：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130165540643.png" alt="image-20211130165540643"></p></li><li><p>删除角色</p><ul><li>登录 TSF 控制台。</li><li>在左侧导航栏，单击【管理中心】下的【角色管理】。</li><li>将鼠标悬停在目标角色上，单击角色名称右侧的【删除】即可删除该角色。</li></ul></li><li><p>说明：</p><ul><li>当已经给某用户绑定角色和策略组后，删除角色会导致策略不可用，请谨慎删除。</li></ul></li></ul><h5 id="1-3-TSF授权管理"><a href="#1-3-TSF授权管理" class="headerlink" title="1.3 TSF授权管理"></a>1.3 TSF授权管理</h5><ul><li><p>授权管理的操作步骤</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130165654025.png" alt="image-20211130165654025"></p></li><li><p>操作步骤：</p><ul><li><p>登录 TSF 控制台。</p></li><li><p> 在左侧导航栏，单击【管理中心】下的【角色管理】。</p></li><li><p><strong>进行策略配置</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130165907513.png" alt="image-20211130165907513"></p></li><li><p>单击【策略配置】，进入策略生成器页面。</p></li><li><p>配置策略名称和权限。</p><ul><li>策略名称：支持英文字母、数字、以及符号“+ = , . @ _ -”，限制128个字符以内。</li><li>权限配置：选择对应角色与资源组。示例：当用户希望对集群1配置全读写权限，对集群2 配置只读策略时，可以将包含全读写集群的角色与包含集群1的数据集关联作为权限配置的 第一条数据，将包含集群只读的角色与包含集群2的数据集关联作为第二条数据。</li></ul></li><li><p>单击【前往 CAM 进行授权】，并在访问管理产品页面单击【创建策略】</p><ul><li>注意：为避免策略不生效，建议不要在此处修改策略脚本。</li></ul></li><li><p>关联子用户</p><ul><li>将生成的策略 关联用户/用户组。</li><li>单击【确定】，完成授权管理。</li></ul></li></ul></li></ul><h4 id="第二章-TSF资源管理基础"><a href="#第二章-TSF资源管理基础" class="headerlink" title="第二章 TSF资源管理基础"></a>第二章 TSF资源管理基础</h4><p>在真正学习TSF控制台使用之前我们先来看一下几个重要的概念，首先我们来看一下TSF资源管理基础概念。</p><h5 id="2-1-TSF资源管理的三个维度"><a href="#2-1-TSF资源管理的三个维度" class="headerlink" title="2.1 TSF资源管理的三个维度"></a>2.1 TSF资源管理的三个维度</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130170337982.png" alt="image-20211130170337982"></p><ul><li><p>首先我们来看一下上面的这个图，如果掌握了这个图，那对于TSF平台的基本使用可以说已经入门了；图中涉及到TSF的几个重要的概念：集群，命名空间，部署组。</p></li><li><p>集群：集群是指云资源管理的集合，包含了运行应用的云主机等资源</p></li><li><p>命名空间：命名空间是对一组资源和对象的抽象集合。用于逻辑隔离资源</p></li><li><p>部署组：部署组是执行应用批量部署的逻辑概念。一个部署组内包括多个实例，每个实例上运行相同的应用程序。同一个部署组上可以运行一个或者多个应用，但其中的每个实例应用相同。</p></li></ul><h5 id="2-2-TSF下资源使用说明"><a href="#2-2-TSF下资源使用说明" class="headerlink" title="2.2 TSF下资源使用说明"></a>2.2 TSF下资源使用说明</h5><ul><li><p>TSF 下资源使用说明</p><ul><li>集群：分为虚拟机集群、容器集群</li><li>命名空间：不同集群下面相同命名空间可以相互调用，不同命名空间下逻辑隔离</li><li>部署组：部署组属于集群下，是多个实例的集合</li></ul></li><li><p>公有云下，TSF 资源使用说明</p><ul><li>云主机导入集群需要保证云主机和集群在相同的VPC内。</li><li>使用虚拟机部署应用时，一台云主机只能部署一个应用，不能共用</li><li>使用容器部署应用时，应用部署在容器的pod上面，可以实现一台虚拟机部署多个应用</li></ul></li><li><p>公有云通常指第三方提供商用户能够使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的。公有云的最大意义是能够以低廉的价格，提供有吸引力的服务给最终用户，创造新的业务价值，公有云作为一个支撑平台，还能够整合上游的服务（如增值业务，广告）提供者和 下游最终用户，打造新的价值链和生态系统。它使客户能够访问和共享基本的计算机基础设施， 其中包括硬件、存储和带宽等资源。</p></li><li><p>私有云(Private Clouds)是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。</p></li><li><p>混合云是公有云和私有云两种服务方式的结合。由于安全和控制原因，并非所有的企业信息都能放置在公有云上，这样大部分已经应用云计算的企业将会使用混合云模式。</p></li><li><p>VPC:Virtual Private Cloud虚拟私有云， 是存在于共享或公用云中的私有云。虚拟私有云（VPC） 是一个公共云计算资源的动态配置池，需要使用加密协议、隧道协议和其他安全程序，在民营企业和云服务提供商之间传输数据。一个VPC基本上把提供商的多租户架构变成单租户架构。虚拟私有云在概念上类似于虚拟专用网（VPN）。一个VPN可以被用来在公共网，比如互联网上通过专用隧道发送数据，该隧道不能输入未适当加密的数据。</p></li></ul><h5 id="2-3-TSF下资源最佳实践"><a href="#2-3-TSF下资源最佳实践" class="headerlink" title="2.3 TSF下资源最佳实践"></a>2.3 TSF下资源最佳实践</h5><ul><li><p>使用命名空间隔离不同环境：开发环境、测试环境及准生产环境等</p></li><li><p>同一个命名空间支持虚拟机集群和容器集群相互调用</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130171146411.png" alt="image-20211130171146411"></p></li><li><p> 前面已经介绍了TSF的资源关系，在实际的开发过程中一般都会涉及到多个环境，比如：开发环境，测试环境，生产环境；这些不同的环境在TSF中可以通过命名空间来进行隔离，这也是TSF下资源的最佳实践之一</p></li><li><p>在TSF中集群分为2大类：虚拟机集群，容器集群，在同一个命名空间中是支持虚拟机和容器应用的相互调用。</p></li></ul><h5 id="2-4-TSF应用部署的三种类型"><a href="#2-4-TSF应用部署的三种类型" class="headerlink" title="2.4 TSF应用部署的三种类型"></a>2.4 TSF应用部署的三种类型</h5><ul><li><p>TSF 应用部署分为三种类型</p><ul><li><p>虚拟机部署：通过 JAR、zip 包等部署在云主机 CVM 上的应用。</p></li><li><p>容器应用部署：通过镜像部署在 Docker 容器中的应用。</p></li><li><p>Serverless部署</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130171522019.png" alt="image-20211130171522019"></p></li></ul></li><li><p>在TSF中,应用分为二大类：</p><ul><li>虚拟机应用：通过虚拟机部署的应用就是虚拟机应用</li><li>容器应用：通过容器部署的应用就是容器应用</li></ul></li><li><p>三种部署方式的对比如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130171655576.png" alt="image-20211130171655576"></p></li><li><p>上图是虚拟机，容器和Serverless三种部署方式的区别的基本区别。</p></li></ul><h5 id="2-5-TSF中应用和服务的基本概念"><a href="#2-5-TSF中应用和服务的基本概念" class="headerlink" title="2.5 TSF中应用和服务的基本概念"></a>2.5 TSF中应用和服务的基本概念</h5><ul><li><p>应用与服务：</p><ul><li><p>TSF应用是可部署的软件实体，包含一个或一组容器或进程。</p></li><li><p>TSF服务是微服务平台管理的基本单元。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130171816954.png" alt="image-20211130171816954"></p></li></ul></li><li><p>TSF上有应用和服务两个概念：</p><ul><li>TSF应用管理：是用户业务上线之前的程序包、配置、部署组</li><li>TSF服务：偏向管理用户业务上线之后的线上管控</li></ul></li><li><p>应用与服务没有数量上的明确关系</p></li><li><p>应用名称是用户在控制台上自定义的</p></li><li><p>服务名称在程序包、镜像的中代码中定义</p></li></ul><h4 id="第三章-TSF部署组"><a href="#第三章-TSF部署组" class="headerlink" title="第三章 TSF部署组"></a>第三章 TSF部署组</h4><p>介绍完TSF的集群，命名空间，TSF应用与TSF服务的基本概念以及区别之后，我们接下来看一下 TSF部署组的内容。</p><h5 id="3-1-什么是TSF的部署组"><a href="#3-1-什么是TSF的部署组" class="headerlink" title="3.1 什么是TSF的部署组"></a>3.1 什么是TSF的部署组</h5><ul><li><p>部署组：</p><ul><li><p>概念：部署组是执行应用批量部署的逻辑概念。一个部署组内包括多个应用实例，每个应用实例上运行相同的应用程序</p></li><li><p>部署组的操作：创建部署组、删除部署组、部署应用、启动应用、应用扩容等。</p></li><li><p>部署组类型：</p><ul><li>按照部署组关联的应用类型，部署组分为虚拟机应用部署组和容器应用部署组</li><li>虚拟机应用部署组：使用云主机 CVM 来部署应用</li><li>容器应用部署组：使用 Docker 容器来部署应用。Docker 应用部署时，将在 CVM 上创建多 个 Docker 容器实例。</li></ul></li><li><p>部署组对比</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130172309739.png" alt="image-20211130172309739"></p></li></ul></li><li><p>虚拟机应用部署组，容器应用部署组的对不如上图：</p></li><li><p>在这一部分中主要介绍使用虚拟机应用以及虚拟机部署组，在下一部分的内容中我们再介绍容器应用以及容器部署组</p></li><li><p>官网文档地址：<a href="https://cloud.tencent.com/document/product/649/16932">https://cloud.tencent.com/document/product/649/16932</a></p></li></ul><h5 id="3-2-虚拟机应用部署组"><a href="#3-2-虚拟机应用部署组" class="headerlink" title="3.2 虚拟机应用部署组"></a>3.2 虚拟机应用部署组</h5><ul><li>虚拟机应用部署组指的就是部署组中部署的是虚拟机应用。</li><li>虚拟机部署组的操作包括两种：<ul><li>基本操作：部署组的创建和删除。</li><li>应用生命周期管理相关操作：添加实例（扩容）、下线实例（缩容）、部署应用、启 动应用、停止应用。</li></ul></li></ul><h6 id="3-2-1-部署组的创建和删除"><a href="#3-2-1-部署组的创建和删除" class="headerlink" title="3.2.1 部署组的创建和删除"></a>3.2.1 部署组的创建和删除</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130174657894.png" alt="image-20211130174657894"></p><ul><li>创建部署组（如上图一）<ul><li>登录 TSF 控制台。</li><li>单击左侧导航栏中的 部署组。</li><li>选择部署组所属集群和所属命名空间。</li><li>单击部署组列表上方的【新建部署组】按钮。</li><li>设置部署组相关信息。</li><li>部署组名称：部署组的名称，不超过 60 个字符。</li><li>描述：部署组的描述，不超过 200 个字符。</li><li>数据填写完毕后点击保存创建部署组。</li></ul></li><li> 删除部署组（如上图二）：</li><li>在部署组的右侧操作项中点击“删除”即可完成部署组的删除操作。</li></ul><h6 id="3-2-2-部署组中应用生命周期管理相关操作"><a href="#3-2-2-部署组中应用生命周期管理相关操作" class="headerlink" title="3.2.2 部署组中应用生命周期管理相关操作"></a>3.2.2 部署组中应用生命周期管理相关操作</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130174910683.png" alt="image-20211130174910683"></p><ul><li>添加实例：将 CVM 云服务器添加到部署组中，如果部署组此时已经关联了程序包，将执行部署命令。</li><li>下线实例：停止 CVM 云服务器上的应用，然后将实例从部署组中移除。</li><li>部署应用：将应用部署到 CVM 云服务器上，并执行启动命令。</li><li>启动应用：当应用处于停止状态时可以启动应用。</li><li>停止应用：当应用处于运行中状态时可以停止应用。</li></ul><h4 id="第四章-TSF应用程序包的管理"><a href="#第四章-TSF应用程序包的管理" class="headerlink" title="第四章 TSF应用程序包的管理"></a>第四章 TSF应用程序包的管理</h4><p>通过前面的学习我们已经了解了集群，名称空间，应用，部署组的基本概念以及关系，那应用是 如何从本地到部署组的呢？这就需要使用TSF应用程序包的管理功能，接下来我们学习关于TSF应 用程序包的管理功能使用。</p><h5 id="4-1-应用程序包的管理"><a href="#4-1-应用程序包的管理" class="headerlink" title="4.1 应用程序包的管理"></a>4.1 应用程序包的管理</h5><ul><li>程序包管理功能分为二个部分：<ul><li>上传程序包：<ul><li>上传程序包指的是把应用打包后的包（如fatjar）上传到TSF应用仓库中。</li></ul></li><li>删除程序包：<ul><li>删除程序包指的是把不需要的程序包从TSF应用仓库中删除。</li></ul></li></ul></li><li> 接下来我们看一下应用程序包管理的具体操作。</li></ul><h6 id="4-1-1-上传程序包"><a href="#4-1-1-上传程序包" class="headerlink" title="4.1.1 上传程序包"></a>4.1.1 上传程序包</h6><ul><li><p>程序包管理：上传程序包。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130175217201.png" alt="image-20211130175217201"></p></li><li><p>首先登录TSF控制台。</p></li><li><p>点击TSF左侧菜单栏中的“应用管理”进入应用列表页面</p></li><li><p>点击需要管理的应用名称（如若没有应用需要新建应用）</p></li><li><p>进入应用后点击上方的“程序包管理”，如上图所示</p></li><li><p>点击上传程序包按钮就可以进行程序包的上传操作</p></li></ul><h6 id="4-1-2-删除程序包"><a href="#4-1-2-删除程序包" class="headerlink" title="4.1.2 删除程序包"></a>4.1.2 删除程序包</h6><ul><li><p>程序包管理：删除程序包。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130175333054.png" alt="image-20211130175333054"></p></li><li><p>在应用程序包列表页面可以进行应用程序包的删除功能，如上图所示。</p></li></ul><h6 id="4-1-3-启动脚本说明"><a href="#4-1-3-启动脚本说明" class="headerlink" title="4.1.3 启动脚本说明"></a>4.1.3 启动脚本说明</h6><ul><li><p>虚拟机应用支持的程序包格式：</p><ul><li>jar: FatJar 格式的程序包</li><li>tar.gz 、zip : 压缩包中必须包含三个文件：<ul><li>start.sh：启动脚本</li><li>stop.sh：停止脚本</li><li>cmdline：检查应用是否存在的信息。TSF Agent 通过 cmdline 的内容来检查进程是否存活 （通过 Linux 命令 ps -ef | grep  ）。如果不提供 cmdline，在控制台上看到部署组的状态为 已停止 状态，即使应用正在运行。</li></ul></li></ul></li><li><p>目前使用云服务器部署的应用支持的程序包格式包括 jar 、tar.gz 和 zip。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130175545834.png" alt="image-20211130175545834"></p></li><li><p>如果应用是fatjar（后缀是jar）格式，不需要添加上面的启动脚本，如果是tar.gz或者zip包格式 必须添以上的三个脚本文件。</p></li><li><p>其中start.sh脚本内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">! /bin/bash</span><br>already_run=`ps -ef|grep &quot;python promotion&quot;|grep -v grep|wc -l`<br>if [ $&#123;already_run&#125; -ne 0 ];then<br>echo &quot;promotionService already Running!!!! Stop it first&quot;<br>exit -1<br>fi<br>nohup python promotionService.py 8093 &amp;<br></code></pre></td></tr></table></figure><ul><li><p>如上代码是start.sh的启动脚本内容，通俗的讲上述代码就是检测应用是否已经运行，如果已经运行了直接提示“promotion Service already Running!!!! Stop it first“(promotion服务已经运行了,请先停止）；如果服务没有运行就直接运行服务。</p></li><li><p>注意不同的服务名称启动脚本需要做对应修改。</p></li><li><p>stop.sh 停止脚本内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>pid=`ps -ef|grep &quot;python promotion&quot;|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`<br>kill -SIGTERM $pid<br>echo &quot;process $&#123;pid&#125; killed&quot;<br></code></pre></td></tr></table></figure></li><li><p>上述代码是stop.sh停止脚本的代码，意义就是把查找当前服务的pid，然后停止服务。</p></li><li><p>cmdline 检测进程脚本，agent 通过ps -ef | grep ‘cmdline 内容’来检测 进程是否存在</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">python promotion</span><br></code></pre></td></tr></table></figure></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/30359">https://cloud.tencent.com/document/product/649/30359</a></p></li><li><p>cmdline 说明：</p><ul><li><p>如果启动应用是 Java 应用，启动脚本中通过java -java xxx.jar来启动应用。在 cmdline 文件中使用完整的 Java 启动命令。例如启动脚本中包含如下启动命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xms128m -Xmx512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -jar consumer-demo-<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT.jar<br></code></pre></td></tr></table></figure></li><li><p>当应用启动后，agent 会在服务器上执行ps -ef | grep ‘cmdline 内容’来检查进程是否存在。</p></li></ul></li></ul></li></ul><h4 id="第五章-TSF设置应用程序的启动参数"><a href="#第五章-TSF设置应用程序的启动参数" class="headerlink" title="第五章 TSF设置应用程序的启动参数"></a>第五章 TSF设置应用程序的启动参数</h4><p>通过设置集群，命名空间，部署组，应用以后我们就可以使用虚拟机部署应用了，很多时候我们 可能需要设置应用的启动参数（比如jvm 内存大小），那通过TSF如何设置应用程序的启动参数 呢？这就是我们接下来要学习的内容。</p><h5 id="5-1-应用程序的启动参数设置"><a href="#5-1-应用程序的启动参数设置" class="headerlink" title="5.1 应用程序的启动参数设置"></a>5.1 应用程序的启动参数设置</h5><ul><li>用户可以在部署应用的时候设置应用的启动参数</li><li>在部署组列表中点击右侧的“部署应用”可以实现应用的部署功能，我们可以在部署应用的时候 设置应用的启动参数。</li><li>实例资源限制说明：<ul><li>新建容器部署组时可以设置实例数量和每个实例的资源限制。实例的资源限制包括两个指标： CPU 和 内存大小。需要说明的是这里设置的都是 Limit 值，而不是 Request 的值。</li><li>TSF 会根据 Limit 值，自动设置容器实例的 CPU Request 和 内存 Request，两者的数量关 系如下：Limit = Request * 2</li><li>当实例数量 * 资源限制数量 &gt; 集群剩余的资源时，会提示 “资源不足，请导入节点” 的提示语。此时用户需要去集群页面导入云服务器来扩充资源。例如实例数量为 2，实例资源限制是 CPU=0.5核，内存=1G ，而集群剩余资源为 CPU=0.8核，内存=2G 时， 由于 CPU 核数资源不够，会提示资源不足的错误。</li></ul></li><li>参数说明：<ul><li>-Xms:128m 设置jvm的初始堆内存大小为128m</li><li>-Xmx:512m 设置jvm的最大堆内容大小为512m</li></ul></li><li>官网文档：<a href="https://cloud.tencent.com/document/product/649/17683">https://cloud.tencent.com/document/product/649/17683</a></li></ul><h4 id="第六章-TSF服务编排"><a href="#第六章-TSF服务编排" class="headerlink" title="第六章 TSF服务编排"></a>第六章 TSF服务编排</h4><p>前面我们已经介绍了使用TSF部署虚拟机应用，那接下来我们看一下TSF的服务编排功能，类似于 Spring Boot项目可以通过<a href="https://start.spring.io/%E7%BD%91%E7%AB%99%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E3%80%82">https://start.spring.io/网站快速生成模板代码。</a></p><h5 id="6-1-什么是服务编排"><a href="#6-1-什么是服务编排" class="headerlink" title="6.1 什么是服务编排"></a>6.1 什么是服务编排</h5><ul><li><p>什么是服务编排？</p><ul><li>为了提高用户开发微服务代码的效率， TSF 提供服务编排功能。服务编排可以实现快速生成基于 TSF 框架的微服务工程源码，帮助业务设计人员快速构建可运行的微服务程序。</li></ul></li><li><p>TSF 引入了服务编排模板的概念用于保存工程信息，方便后续可以基于模板修改工程参数和下载工程源码。</p></li></ul><h5 id="6-2-新建服务编排模板"><a href="#6-2-新建服务编排模板" class="headerlink" title="6.2 新建服务编排模板"></a>6.2 新建服务编排模板</h5><ul><li><p>新建服务编排模板步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130180828168.png" alt="image-20211130180828168"></p></li><li><p>接下来我们来看一下如何使用服务编排功能，首先我们来看一下新建服务编排模块，新建服务编 排的基本步骤如上图所示。</p></li></ul><h6 id="6-2-1-新建模板"><a href="#6-2-1-新建模板" class="headerlink" title="6.2.1 新建模板"></a>6.2.1 新建模板</h6><ul><li><p>步骤 1：    </p><ul><li><p>进入服务编排功能：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130181022833.png" alt="image-20211130181022833"></p></li><li><p>登录 TSF 控制台。</p></li><li><p>单击左侧导航 服务编排。</p></li><li><p>单击 【新建】按钮。</p></li></ul></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/17931">https://cloud.tencent.com/document/product/649/17931</a>        </p></li></ul><h6 id="6-2-2-填写工程配置和POM配置信息"><a href="#6-2-2-填写工程配置和POM配置信息" class="headerlink" title="6.2.2 填写工程配置和POM配置信息"></a>6.2.2 填写工程配置和POM配置信息</h6><ul><li><p>步骤二：</p><ul><li><p>填写工程配置和 POM 配置信息</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130181255055.png" alt="image-20211130181255055"></p></li></ul></li><li><p>POM 配置信息如下：</p><ul><li>工程名：Spring Boot 工程名，字母开头，支持大小写字母、数字组成，不超过 24 个字符长 度。</li><li>包路径：package 路径，小写字母开头，支持小写字母、数字或小数点组成，不超过 60 个 字符长度。</li><li>GroupID： pom.xml 文件中的 groupId。</li><li>Artifact ID： pom.xml 文件中的 artifactId。</li><li>Name：pom.xml 文件中的 name。</li><li>Version：pom.xml 文件中的 version。</li><li>Description：选填，pom.xml 文件中的 description</li></ul></li></ul><h6 id="6-2-3-填写服务基本信息"><a href="#6-2-3-填写服务基本信息" class="headerlink" title="6.2.3 填写服务基本信息"></a>6.2.3 填写服务基本信息</h6><ul><li><p>步骤 三：</p><ul><li><p>填写服务基本信息</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130181610332.png" alt="image-20211130181610332"></p></li></ul></li><li><p>服务基本信息配置：</p><ul><li>服务名：对应工程文件中的 spring.application.name。</li><li>端口：服务监听端口，仅支持 0-65535。</li><li>Controller 类名前缀：可填写多个，将会生成多个带有前缀的 Controller 类。</li></ul></li></ul><h6 id="6-2-4-保存或者生成工程"><a href="#6-2-4-保存或者生成工程" class="headerlink" title="6.2.4 保存或者生成工程"></a>6.2.4 保存或者生成工程</h6><ul><li><p>步骤四：</p><ul><li><p>保存或者生成工程</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130181610332.png" alt="image-20211130181610332"></p></li></ul></li><li><p>单击【保存并下载】，保存模板，并下载工程的 zip 文件。或者单击【保存】按钮，仅保存模板， 不执行下载操作</p></li></ul><h5 id="6-3-修改服务编排模板"><a href="#6-3-修改服务编排模板" class="headerlink" title="6.3 修改服务编排模板"></a>6.3 修改服务编排模板</h5><ul><li><p>可修改模板的参数信息</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130183542782.png" alt="image-20211130183542782"></p><ul><li>各具体参数设置参考6.2.2中说明</li></ul></li></ul><h5 id="6-4-删除服务编排模板"><a href="#6-4-删除服务编排模板" class="headerlink" title="6.4 删除服务编排模板"></a>6.4 删除服务编排模板</h5><ul><li> 单击服务编排模板列表上目标模板右侧的【删除】按钮，确认后即可删除。<img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130183728533.png" alt="image-20211130183728533"></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>TSF 中集群，命名空间，部署组的关系是怎么样的？</p></li><li><p>应用与服务的区别是什么？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、TSF与ServiceMesh的集成</title>
    <link href="/2021/11/25/%E4%BA%94%E3%80%81TSF%E4%B8%8EServiceMesh%E7%9A%84%E9%9B%86%E6%88%90/"/>
    <url>/2021/11/25/%E4%BA%94%E3%80%81TSF%E4%B8%8EServiceMesh%E7%9A%84%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="五、TSF与ServiceMesh的集成"><a href="#五、TSF与ServiceMesh的集成" class="headerlink" title="五、TSF与ServiceMesh的集成"></a>五、TSF与ServiceMesh的集成</h3><p>微服务自2014年3月由Martin Fowler首次提出以来，在Spring Cloud、Dubbo等各类微服务框架的帮助下，以燎原之势席卷了整个IT技术界，成为了最主流的分布式应用解决方案。但仍然还有很多问题没有得到根本性的解决，比如技术门槛高、多语言支持不足、代码侵入性强等。如何应对这些挑战成为了下一代微服务首要回答的问题。直到服务网格（Service Mesh）被提出，这 一切都有了答案。</p><p>Service Mesh被称为云原生的三驾马车之一（k8s, Service Mesh, serverless）。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以：</p><ul><li>了解Service Mesh的概念和应用场景</li><li>了解Service Mesh的架构</li><li>掌握TSF接入Service Mesh应用</li></ul><h4 id="第一章-Service-Mesh的概念"><a href="#第一章-Service-Mesh的概念" class="headerlink" title="第一章 Service Mesh的概念"></a>第一章 Service Mesh的概念</h4><h5 id="1-1-Service-Mesh概念"><a href="#1-1-Service-Mesh概念" class="headerlink" title="1.1 Service Mesh概念"></a>1.1 Service Mesh概念</h5><ul><li>老系统，异构语言的困境：</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211125095524052.png" alt="image-20211125095524052"></p><ul><li><p>在介绍Service Mesh之前我们先来看一下上面这个图。使用微服务架构确实给我们的开发带来了很大的便利，前面我们也介绍了使用Spring Cloud作为微服务架构；但是使用Spring Cloud还存 在几个明显的问题：首先Spring Cloud只能使用Java语言做开发，那如果不是Java 语言怎么办？ 老系统怎么办，老系统很多情况下可能并没有改造的价值，如果再重新使用Spring Cloud进行重构得不偿失，这些问题是使用Spring Cloud框架无法解决的。既然有问题，人们总是会去寻找解 决方案，经过不断的演变发展，对于异构语言，老系统这种困境目前最好的解决办法就是使用 Service Mesh；接下来我们看一下Service Mesh到底是什么？它是如何帮助我们解决这些困难的。</p></li><li><p>什么是Service Mesh？</p><ul><li><p>Service Mesh又被称之为“服务网格”，是致力于解决服务间通讯的基础设施层。</p></li><li><p>Service Mesh 通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起， 但应用程序不需要知道它们的存在。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211125095827767.png" alt="image-20211125095827767"></p></li><li><p>根据Linkerd CEO William Morgan定义，Service Mesh是用于处理服务间通信的基础设施层， 用于在云原生应用复杂的服务拓扑中实现可靠的请求传递。在实践中，Service Mesh通常是一组 与应用一起部署，但对应用透明的轻量级网络代理。</p></li><li><p>Service Mesh 通常是由一系列轻量级的网络代理组成的，如上图中的蓝色块就是网络代理（这个网络代理也被称之为Sidecar），绿色块就是我们的应用。各个微服务应用之间的通信都被网络代理劫持，相当于在服务之间加了一个中间层，应用之间要想通信，必须要通过这个中间层；这个网络代理与应用程序部署在一起，但是相对于应用程序来说它是完全不需要知道有这个网络代理的。</p></li><li><p>接下来我们看一下这个网络代理（Sidecar）到底是什么？</p></li></ul></li></ul><h6 id="1-1-1-Sidecar-模式"><a href="#1-1-1-Sidecar-模式" class="headerlink" title="1.1.1 Sidecar 模式"></a>1.1.1 Sidecar 模式</h6><ul><li><p>什么是Sidecar模式？</p><ul><li><p>Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211125100215008.png" alt="image-20211125100215008"></p></li></ul></li><li><p>Sidecar 在软件系统架构中特指边车模式。这个模式的灵感来源于我们生活中的边三轮：即在两轮摩托车的旁边添加一个边车的方式扩展现有的服务和功能。</p></li><li><p>Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</p></li><li><p>Sidecar模式如何工作（如上图）：</p><ul><li>Service Mesh层可以位于应用程序侧的Sidecar容器中，同一sidecar的多个副本可以附在每个应用旁。</li><li>来自单个服务的所有传入和传出网络流量均通过Sidecar代理，完成微服务之间的流量管理、 遥测数据收集以及策略的执行等等。从某种意义上来说，服务对于网络是无感知的，只知道所附加的sidecar代理。这就是Sidecar模式工作的本质，它将网络依赖抽象成了Sidecar。</li></ul></li></ul><h6 id="1-1-2-Service-Mesh-架构分层"><a href="#1-1-2-Service-Mesh-架构分层" class="headerlink" title="1.1.2 Service Mesh 架构分层"></a>1.1.2 Service Mesh 架构分层</h6><ul><li><p>Service Mesh 架构分层</p><ul><li>数据面（ Data Plane ）：由独立部署的智能 代理进行组成，接管及控制微服务进程间的 业务数据流量。</li><li>控制面（ Control Plane ）：对数据面进行管 理及配置流量路由，策略加强及统计数据采集。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211125101750236.png" alt="image-20211125101750236"></p></li><li><p>在Service Mesh中，我们需要了解Data Plane和Control Plane两个概念</p><ul><li>Data Plane的作用是处理网格内服务间的通信，并完成服务发现、负载均衡、流量管理、健康检查等功能；</li><li>Control Plane的作用是管理和配置Sidecar来执行策略并收集遥测（telemetry）</li></ul></li></ul><h6 id="1-1-3-Service-Mesh-开源项目"><a href="#1-1-3-Service-Mesh-开源项目" class="headerlink" title="1.1.3 Service Mesh 开源项目"></a>1.1.3 Service Mesh 开源项目</h6><ul><li><p>Service Mesh 开源项目：</p><ul><li>Linkerd ：William Morgan创办的Buoyant 公司开发</li><li>Envoy ：由 Matt Klein 个人开发（Lyft 工程师）</li><li>Istio ：2017 年 5 月 24 日首发布，由 Google、IBM 和 Lyft 联合开发</li><li>Conduit ： Linkerd 的下一代产品</li></ul></li><li><p>Service Mesh 开源项目简介：</p><ul><li>Linkerd：第一代 Service Mesh，2016 年 1 月 15 日首发布，业界第一个 Service Mesh 项目， 由 Buoyant 创业小公司开发（前 Twitter 工程师），2017 年 7 月 11 日，宣布和 Istio 集成， 成为 Istio 的数据面板。</li><li>Envoy：第一代 Service Mesh，2016 年 9 月 13 日首发布，由 Matt Klein 个人开发（Lyft 工 程师），之后默默发展，版本较稳定。</li><li>Istio：第二代 Service Mesh，2017 年 5 月 24 日首发布，由 Google、IBM 和 Lyft 联合开发， 只支持 Kubernetes 平台，2017 年 11 月 30 日发布 0.3 版本，开始支持非 Kubernetes 平台， 之后稳定的开发和发布。</li><li>Conduit：第二代 Service Mesh，2017 年 12 月 5 日首发布，由 Buoyant 公司开发（借鉴 Istio 整体架构，部分进行了优化），对抗 Istio 压力山大，也期待 Buoyant 公司的毅力。</li></ul></li></ul><h6 id="1-1-4-Istio-架构"><a href="#1-1-4-Istio-架构" class="headerlink" title="1.1.4 Istio 架构"></a>1.1.4 Istio 架构</h6><ul><li><p>Istio 服务网格逻辑上分为数据平面和控制平面:</p><ul><li><p><strong>数据平面</strong>由一组以 sidecar 方式部署的智能代理 （Envoy）组成。这些代理可以调节和控制微服务及 Mixer 之间所有的网络通信。</p></li><li><p><strong>控制平面</strong>负责管理和配置代理来路由流量。 此外控制平面配置 Mixer 以实施策略和收集遥测数据。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130101230478.png" alt="image-20211130101230478"></p></li></ul></li><li><p>Istio的很多设计理念的确非常吸引人，又有 Google 和 IBM 两个巨人加持，所以其竞争力非常之强，如上图是Istio的架构图，在TSF中也是采用的Istio/Envoy开源项目作为Service Mesh的落地方案。</p></li><li><p>Proxy：上图中的Proxy就是采用的Envoy代理（Envoy是一个高性能的C++写的proxy转发器）， </p></li><li><p>Envoy:  是lstio的数据面，扮演sidecar的功能，协调服务网格中所有服务的出入站流量，并提供服务发现、负载均衡、限流熔断等能力，还可以收集大量与流量相关的性能指标。</p></li><li><p>Pilot：负责部署在service mesh中的Envoy实例的生命周期管理。本质上是负责流量管理和控制， 是将流量和基础设施扩展解耦，这是Istio的核心。感性上，可以把Pilot看做是管理sidecar的 sidecar, 但是这个特殊的sidacar并不承载任何业务流量。</p></li><li><p>Mixer：Mixer 是一个独立于平台的组件，负责在服务网格上执行访问控制和使用策略，并从 Envoy 代理和其他服务收集遥测数据，Mixer可以认为是其他后端基础设施（如数据库、监控、 日志、配额等）的sidecar proxy。</p></li><li><p>Citadel：Citadel 通过内置身份和凭证管理可以提供强大的服务间和最终用户身份验证。可用于升级服务网格中未加密的流量，并为运维人员提供基于服务标识而不是网络控制的强制执行策略的能力</p></li></ul><h4 id="第二章-为什么需要Service-Mesh"><a href="#第二章-为什么需要Service-Mesh" class="headerlink" title="第二章 为什么需要Service Mesh"></a>第二章 为什么需要Service Mesh</h4><h5 id="2-1-Service-Mesh典型场景"><a href="#2-1-Service-Mesh典型场景" class="headerlink" title="2.1 Service Mesh典型场景"></a>2.1 Service Mesh典型场景</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130102403500.png" alt="image-20211130102403500"></p><ul><li>Service Mesh 并非新出现的功能。Web 应用程序一直需要自己管理复杂的服务间通信， Service Mesh 的起源可以追溯到过去十五年来这些应用的发展。</li><li>当微服务存在多语言场景，底层并非使用SpringBoot框架开发，旧系统微服务化，希望服务框架的升级无需业务联动升级都推荐使用Service Mesh方式。</li></ul><h5 id="2-2-Service-Mesh优势"><a href="#2-2-Service-Mesh优势" class="headerlink" title="2.2 Service Mesh优势"></a>2.2 Service Mesh优势</h5><ul><li><p>Service Mesh优势？</p><ul><li>轻量级网络代理</li><li>应用程序无感知</li><li>多编程语言应用兼容。</li><li>业务代码零侵入，代码无须改造。</li><li>解耦应用程序的重试、超时、监控、追踪和服务发现；</li><li>实施便利：在mesh部署完成后，应用仅需退回原始的直接调用模式即可使用mesh带来的收益。</li></ul></li><li><p>如果用一句话来解释什么是 Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP/IP， 负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这 一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间 的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交 给 Service Mesh 就可以了。</p></li><li><p>微服务更像是一个服务之间的生态，专注于服务治理等方面，而服务网格更专注于服务之间的通信，以及和 DevOps 更好的结合。</p></li><li><p>优点主要有几点：</p><ul><li>应用内部不必再嵌入复杂的微服务Client：应用不再涉及框架相关的服务发现等功能，每个接口仅需配置一个本地地址进行调用，不必知道集群的情况。</li><li>语言无关：由于不需嵌入语言特定的Client，使用标准协议通信的双方均可由任意语言编写， 即使是外采的二进制系统，也可以简单的嵌入集群中。</li><li>大量减少应用间连接数，数据库连接数：同一主机的调用方所涉及的连接可以被Proxy连接复用，因此应用间连接数可大幅减少，同时也避免避免微服务带来的数据库连接数爆炸问题。</li><li>提升通信加密的效率：可以将通信加密统一放置于由高运行性能语言编写的Proxy上，而非由运行效率较低的应用来进行。</li><li>调用过程的集中诊断：由于请求均通过Proxy进行，可以便利的进行统计并收集日志、报文等。</li><li>运维控制的统一认证和调度：由于服务发现和调用路由放置在了独立的系统中，运维可以完全掌控调用的过程，包括设置调用的路径，调用权限等。</li><li>容器友好：service mesh框架同K8S等编排系统集成度较高，可无缝协同运行。</li><li>实施便利：mesh部署完成后，应用仅需退回原始的直接调用模式即可使用mesh带来的收益。</li></ul></li></ul><h4 id="第三章-TSF-Service-Mesh架构"><a href="#第三章-TSF-Service-Mesh架构" class="headerlink" title="第三章 TSF Service Mesh架构"></a>第三章 TSF Service Mesh架构</h4><h5 id="3-1-TSF-Mesh简介"><a href="#3-1-TSF-Mesh简介" class="headerlink" title="3.1 TSF Mesh简介"></a>3.1 TSF Mesh简介</h5><ul><li>TSF Mesh是腾讯云TSF团队遵循Service Mesh设计理念，基于CNCF云原生开源软件Istio/envoy进行构建的一款服务框架产品。</li><li>TSF Mesh与开源ServiceMesh相比具有如下优势：<ul><li>与k8s解耦，能同时支持虚拟机及容器服务进行部署及互通；</li><li>与SpringCloud应用可无缝对接互通;</li><li>支持API级别的服务治理;</li><li>支持基于本地配置及远程配置的服务定义及自动注册。</li></ul></li><li>TSF Service Mesh (以下简称为 TSF Mesh) 是一个基础设施层，用于处理服务间的通信。TSF Mesh 是由一系列轻量级网络代理组成，这些代理（又称 sidecar），与应用程序部署在一起， 而应用程序不感知 sidecar 的存在。</li><li>TSF Mesh 是处于 TCP / IP 之上的一个抽象层。TCP 解决了网络端点键字节传输问题，TSF Mesh 解决服务节点间请求的路由问题。</li><li>TSF Mesh 具有如下优势：<ul><li>多编程语言应用兼容；</li><li>业务代码零侵入，代码无须改造。</li></ul></li><li>CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），口号是坚持和整合开源技术来编排容器作为微服务架构的一部分 ，其作为致力于云原生应用推广和普及的一支重要力量。</li><li>Istio主要由Envoy、Pilot、Mixer三部分组成<ul><li>Envoy：以sidecar的形式和应用程序运行与同一个pod中，通过修改iptables来代理应用程序的所有出入流量</li><li>Pilot：接受系统管理员发出的指令或者规则，遥控所有Envoy的行为</li><li>Mixer：从Envoy处获取流量属性，根据自定义的属性匹配规则进行流量处理，如：流量限制、 日志记录等</li></ul></li></ul><h5 id="3-2-TSF-Mesh架构"><a href="#3-2-TSF-Mesh架构" class="headerlink" title="3.2 TSF Mesh架构"></a>3.2 TSF Mesh架构</h5><ul><li>TSF Mesh整体架构：</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130105736218.png" alt="image-20211130105736218"></p><ul><li>TSF Mesh的整体架构如上图；</li><li>TSF Mesh组网架构从逻辑上划分为控制面和数据面两大部分<ul><li>控制面主要提供配置及控制指令支撑sidecar的正常运行</li><li>数据面主要是提供通信代理（sidecar）来进行透明的服务调用，支撑正常的业务流程</li></ul></li></ul><h6 id="3-2-1-基本实现原理"><a href="#3-2-1-基本实现原理" class="headerlink" title="3.2.1 基本实现原理"></a>3.2.1 基本实现原理</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130110158397.png" alt="image-20211130110158397"></p><ul><li>控制面，数据面架构如上图；</li><li>控制面组件<ul><li>api-server：提供mesh的对外REST API入口，通过API可以进行mesh的功能配置管理</li><li>pilot：mesh调度控制中心，提供服务注册信息、以及服务配置下发，以控制数据面组件的功能</li><li>mixer：mesh策略控制及采集分析中心，提供访问策略控制的能力</li></ul></li><li>数据面组件 (sidecar)<ul><li>pilot-agent：负责环境的初始化及清理，envoy/mesh-dns的生命周期管理</li><li>envoy：数据面，通信代理，提供服务与服务之间RPC通信的能力</li><li>mesh-dns：提供mesh的组件及业务服务的本地域名解析的能力</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130110747167.png" alt="image-20211130110747167"></p><ul><li>实现原理如下：<ul><li>Proxy，Pilot-agent组件在虚拟机创建或者容器创建的时候已经安装好了，应用（如上图中的 ServiceA ，ServiceB）部署到虚拟机/容器时，Pilot-agent会根据应用中的服务描述文件自动进行服务注册，最终通过Pilot把服务与配置注册到Consul 服务注册中心。</li><li>Proxy使用envoy原生的健康上报能力把节点健康信息上报到Pilot中；同时提供服务发现功能； Proxy通过修改iptables代理了应用（如上ServiceA，ServiceB）的所有出入流量。</li><li>如上图ServiceA要访问ServiceB是通过服务名称访问，其中就涉及到Mesh-dns（数据面组件， 提供mesh的组件及业务服务的本地域名解析的能力），首先访问会经过的Mesh-dns组件进行解析，解析完对应的服务名称以后就可以找到对应的服务节点进行访问。</li><li>APIServer对接Consul，负责配置的CURD，屏蔽底层配置中心，对外提供简单的REST接口；</li></ul></li></ul><h6 id="3-2-2-服务寻址"><a href="#3-2-2-服务寻址" class="headerlink" title="3.2.2 服务寻址"></a>3.2.2 服务寻址</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130111859206.png" alt="image-20211130111859206"></p><ul><li>Mesh-dns解析如上图：<ul><li>应用（app）发起的请求通过iptables重定向到mesh-dns，mesh-dns解析服务名后就可以找到对应的服务节点；</li><li>如果不是服务名访问的方式会升级到其它非服务名DNS服务器解析，从而兼容服务名访问与非服务名访问方式；</li><li>mesh-dns 通过 inotify 监听 /etc/resolv.conf，可以随时获取环境中 dns 配置的更改。</li></ul></li></ul><h4 id="第四章-TSF接入Service-Mesh应用"><a href="#第四章-TSF接入Service-Mesh应用" class="headerlink" title="第四章 TSF接入Service Mesh应用"></a>第四章 TSF接入Service Mesh应用</h4><h5 id="4-1-基本实现原理"><a href="#4-1-基本实现原理" class="headerlink" title="4.1 基本实现原理"></a>4.1 基本实现原理</h5><ul><li><p>TSF Mesh实现原理：</p><ul><li>TSF Mesh 可以代理使用云服务器或者容器部署的应用。</li><li>Sidecar 和服务运行在同一个 Pod 中，与 Pod 共享网络。</li><li> Sidecar 与服务的关系如下：</li><li>Sidecar 代理服务向注册中心注册服务相关信息，以便其他服务发现自身。</li><li>Sidecar 作为 Pod 内服务的 HTTP 代理，可以自动发现其他服务。</li></ul></li><li><p>TSF Mesh的基本实现原理参照3.2内容。</p></li></ul><h5 id="4-2-TSF-Mesh使用场景"><a href="#4-2-TSF-Mesh使用场景" class="headerlink" title="4.2 TSF Mesh使用场景"></a>4.2 TSF Mesh使用场景</h5><ul><li>TSF Mesh 主要有三种使用场景：<ol><li>仅服务消费者作为 Mesh 应用部署。</li><li>仅服务提供者作为 Mesh 应用部署。</li><li>服务消费者和服务提供者均作为 Mesh 应用部署</li></ol></li></ul><h6 id="4-2-1-TSF-Mesh使用场景1"><a href="#4-2-1-TSF-Mesh使用场景1" class="headerlink" title="4.2.1 TSF Mesh使用场景1"></a>4.2.1 TSF Mesh使用场景1</h6><ul><li><p>仅服务消费者作为 Mesh 应用部署</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130113943384.png" alt="image-20211130113943384"></p></li><li><p>服务提供者使用 TSF-Spring Cloud 框架实现，注册到服务注册中心；</p></li><li><p>服务消费者作为 Mesh 应用部署，由 Sidecar 注册到服务注册中心。</p></li></ul><h6 id="4-2-2-TSF-Mesh使用场景2"><a href="#4-2-2-TSF-Mesh使用场景2" class="headerlink" title="4.2.2 TSF Mesh使用场景2"></a>4.2.2 TSF Mesh使用场景2</h6><ul><li><p>仅服务提供者作为 Mesh 应用部署</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130114154373.png" alt="image-20211130114154373"></p></li><li><p>服务提供者作为 Mesh 应用部署，由 Sidecar 注册到服务注册中心；</p></li><li><p>服务消费者使用 TSF-Spring Cloud 框架实现，注册到服务注册中心。</p></li></ul><h6 id="4-2-3-TSF-Mesh使用场景3"><a href="#4-2-3-TSF-Mesh使用场景3" class="headerlink" title="4.2.3 TSF Mesh使用场景3"></a>4.2.3 TSF Mesh使用场景3</h6><ul><li><p>服务消费者和服务提供者均作为 Mesh 应用部署</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130114304350.png" alt="image-20211130114304350"></p></li><li><p>服务提供者作为 Mesh 应用部署，由 Sidecar 注册到服务注册中心；</p></li><li><p>服务消费者作为 Mesh 应用部署，由 Sidecar 注册到服务注册中心。</p></li></ul><h5 id="4-3-TSF-Mesh应用接入"><a href="#4-3-TSF-Mesh应用接入" class="headerlink" title="4.3 TSF Mesh应用接入"></a>4.3 TSF Mesh应用接入</h5><ul><li><p>Demo示例说明</p></li><li><p>Demo for Python 提供了 3 个 Python 应用及 Dockerfile：</p><ul><li>user</li><li>shop</li><li>promotion</li></ul></li><li><p>3个应用之间的调用关系是：user =&gt; shop =&gt; promotion</p></li><li><p>虚拟机demo下载地址：</p><p><a href="https://main.qcloudimg.com/raw/cfc64e09c79e05581275ad6baaa1b20c/tsf_python_vm">https://main.qcloudimg.com/raw/cfc64e09c79e05581275ad6baaa1b20c/tsf_python_vm</a>_ demo-1108.zip</p></li><li><p>容器部署demo下载地址：</p><p><a href="https://main.qcloudimg.com/raw/449b92688fabd8903e1486f1d00577be/tsf_python_doc">https://main.qcloudimg.com/raw/449b92688fabd8903e1486f1d00577be/tsf_python_doc</a> ker_demo-1115.zip</p></li><li><p>开发说明：</p><ul><li><p>以 Python 应用说明如何改造来接入 TSF。Python 服务代码本身不需要修改，只需要修改服务间调用的 host。</p></li><li><p>Mesh 应用接入步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130115005183.png" alt="image-20211130115005183"></p></li></ul></li><li><p>Demo工程详细概述：</p><p><a href="https://cloud.tencent.com/document/product/649/30436">https://cloud.tencent.com/document/product/649/30436</a></p></li><li><p>下面以 Python 应用为例说明如何改造代码来接入 TSF。Python 服务代码本身不需要修改，只需要修改服务间调用的 host。</p><ul><li><p> 将原来的 IP:Port 替换为服务名。</p></li><li><p>端口使用 80 或者 443。</p></li><li><p>其他代码不做修改。</p></li></ul></li></ul><h6 id="4-3-1-开发说明"><a href="#4-3-1-开发说明" class="headerlink" title="4.3.1 开发说明"></a>4.3.1 开发说明</h6><ul><li><p>步骤一：</p><ul><li>开发Python应用（以虚拟机 tsf_python_vm_demo项目为例）：<ul><li>userService.py 和 common.py：Python 应用程序</li></ul></li></ul></li><li><p>步骤二：</p><ul><li><p>修改应用中IP:Port访问方式为服务名访问<img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130145504240.png" alt="image-20211130145504240"></p></li><li><p>此处把ip地址访问改为服务名访问以后，后续所有的访问服务方式的调用都会被Sidecar代理拦截， 拦截后会先经过mesh-dns进行本地域名解析（此处名称就是服务的名称，也可以理解为就是本地域名)，最终就可以找到对应的服务节点。</p></li><li><p>其中第一行sidecarPort = 80；这里的sidecarPort 只是命名而已，应用在改造之前只是Python 应用程序，无需任何跟Mesh相关的开发。</p></li><li><p>虚拟机demo下载地址：</p><p><a href="https://main.qcloudimg.com/raw/cfc64e09c79e05581275ad6baaa1b20c/tsf_python_vm">https://main.qcloudimg.com/raw/cfc64e09c79e05581275ad6baaa1b20c/tsf_python_vm</a>_ demo-1108.zip</p></li></ul></li></ul><h6 id="4-3-2-开发说明-虚拟机篇"><a href="#4-3-2-开发说明-虚拟机篇" class="headerlink" title="4.3.2 开发说明 - 虚拟机篇"></a>4.3.2 开发说明 - 虚拟机篇</h6><ul><li><p>步骤三：</p><ul><li><p>添加Mesh应用相应脚本（虚拟机部署方式）</p><ul><li><p>start.sh：启动脚本，示例：如图一。<img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130145927804.png" alt="image-20211130145927804"></p></li><li><p>stop.sh：停止脚本，示例：如图二。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130150007640.png" alt="image-20211130150007640"></p></li><li><p>cmdline：检查进程是否存活的文件， 示例：如图三</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130150048127.png" alt="image-20211130150048127"></p></li><li><p>spec.yml：服务描述文件。</p></li><li><p>apis 目录：存放 API 定义的目录。</p></li></ul></li><li><p>此处start.sh；stop.sh脚本只是用来启动应用；应用部署后，启动的时候就会自动调用start.sh脚本，停止的时候就会调用stop.sh脚本。</p></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/30436">https://cloud.tencent.com/document/product/649/30436</a></p></li><li><p>具体脚本内容见demo中脚本</p></li><li><p>虚拟机工程目录，以 tsf_python_vm_demo 中的 userService 为例说明虚拟机应用工程目录：</p><ul><li><p>userService.py 和 common.py：Python 应用程序</p></li><li><p>start.sh：启动脚本。</p></li><li><p>stop.sh：停止脚本。</p></li><li><p>cmdline：检查进程是否存活的文件。</p></li><li><p>spec.yml：服务描述文件，具体解释请参考 Mesh 开发使用指引。</p></li><li><p>apis 目录：存放 API 定义的目录， 具体解释请参考 Mesh 开发使用指引。</p></li></ul></li></ul></li></ul><h6 id="4-3-3-开发说明-–-容器应用篇"><a href="#4-3-3-开发说明-–-容器应用篇" class="headerlink" title="4.3.3 开发说明 – 容器应用篇"></a>4.3.3 开发说明 – 容器应用篇</h6><ul><li><p>步骤三：</p><ul><li><p>添加Mesh应用相应脚本（容器部署方式）</p></li><li><p>spec.yml：服务描述文件。</p></li><li><p>apis 目录：存放 API 定义的目录。</p></li><li><p>start.sh：在启动脚本中创建 /opt/tsf/app_config/ 目录，然后将 spec.yml 文件和 apis 目 录拷贝到 /opt/tsf/app_config/ 中。</p></li><li><p>start.sh ：目录中 start.sh 脚本来启动 Python 应用。</p></li><li><p>Dockerfile：打包生成镜像文件</p></li><li><p>start.sh注意事项：您需要在容器启动后通过用户程序的启动脚本（start.sh）拷贝目录，不可以在 Dockerfile 中提前拷贝;</p></li><li><p>如下是start.sh示例代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">! /bin/bash</span><br>mkdir -p /opt/tsf/app_config/apis<br>cp /root/app/userService/spec.yaml /opt/tsf/app_config/<br>cp -r /root/app/userService/apis /opt/tsf/app_config/<br>cd /root/app/userService/<br>python ./userService.py 80 1&gt;./logs/user.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li></ul></li><li><p>容器部署demo下载地址：</p><p><a href="https://main.qcloudimg.com/raw/449b92688fabd8903e1486f1d00577be/tsf_python_doc">https://main.qcloudimg.com/raw/449b92688fabd8903e1486f1d00577be/tsf_python_doc</a> ker_demo-1115.zip</p></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/30436">https://cloud.tencent.com/document/product/649/30436</a></p></li><li><p>容器应用工程目录，以 tsf_python_docker_demo 中的 demo-mesh-user 为例说明容器应用工 程目录。</p><ul><li>Dockerfile：使用 userService 目录中 start.sh 脚本来启动 Python 应用。</li><li>userService目录：基本结构和 tsf_python_vm_demo中 userService 目录类似，除了没有 stop.sh 和 cmdline 文件。</li><li>start.sh：在启动脚本中创建 /opt/tsf/app_config/ 目录，然后将 spec.yml 文件和 apis 目录拷贝到 /opt/tsf/app_config/ 中。</li></ul></li></ul><h6 id="4-3-4-开发说明（续）"><a href="#4-3-4-开发说明（续）" class="headerlink" title="4.3.4 开发说明（续）"></a>4.3.4 开发说明（续）</h6><ul><li><p>步骤四：</p><ul><li>前面的改造是为普通应用转变为Mesh应用提供必要的脚本以及配置信息；</li><li>部署应用到TSF以后，Mesh的所有底层操作由平台完成，只需要部署成功就可以把普通应用转变为Mesh应用:</li></ul></li><li><p>虚拟机部署:</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130150935619.png" alt="image-20211130150935619"></p></li><li><p>容器部署:</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130151007567.png" alt="image-20211130151007567"></p></li><li><p>注意此处是改造原有应用，然后添加对应脚本，为应用转变为TSF Mesh应用提供必要的脚本以及配置信息；应用部署到TSF以后Mesh的所有底层操作都有平台完成，只要完成部署成功以后， 应用就已经转变为Mesh应用。</p></li><li><p>具体部署操作将在下一部分内容介绍；</p></li><li><p>官网文档：</p><ul><li><p>容器部署：<a href="https://cloud.tencent.com/document/product/649/17930">https://cloud.tencent.com/document/product/649/17930</a></p></li><li><p>虚拟机部署： <a href="https://cloud.tencent.com/document/product/649/18787">https://cloud.tencent.com/document/product/649/18787</a></p></li></ul></li></ul><h6 id="4-3-5-服务定义和注册"><a href="#4-3-5-服务定义和注册" class="headerlink" title="4.3.5 服务定义和注册"></a>4.3.5 服务定义和注册</h6><ul><li><p>在应用程序所在目录中设置创建 spec.yml 文件，该文件用于描述服务信息</p><ul><li><p>sidecar 制定了服务名、端口号和健康检查URL</p></li><li><p>sidecar 根据服务描述文件将服务注册到注册中心</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Application</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">services:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">user</span> <span class="hljs-comment"># service name</span><br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8091</span><br><span class="hljs-attr">protocol:</span> <span class="hljs-string">http</span><br><span class="hljs-attr">healthCheck:</span><br><span class="hljs-attr">path:</span> <span class="hljs-string">/health</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>TSF Mesh应用可以通过sidecar实现服务注册与发现，这里就需要用到spec.yml配置文件，应用部署启动的时候同时会自动启动Sidecar，在spec.yml配置文件中就定义了服务的相关信息，如服务名，端口，健康检查url等，通过在spec.yml配置的服务名称，端口，Sidecar会自动把服务注册到TSF的服务注册中心，同时也会通过Sidecar代理应用的出入站流量。</p></li></ul><h5 id="4-4-Mesh-应用-API-定义和上报"><a href="#4-4-Mesh-应用-API-定义和上报" class="headerlink" title="4.4 Mesh 应用-API 定义和上报"></a>4.4 Mesh 应用-API 定义和上报</h5><ul><li><p>API 定义文件（如 user.yml)</p><ul><li><p>API 定义文件放在 apis 目录下</p></li><li><p>文件名规则： &lt;服务名&gt;.yml</p></li><li><p>符合 openapi 3.0 规范</p></li><li><p>sidecar 根据api 定义上报到配置中心</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">info:</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">user</span> <span class="hljs-string">service</span><br><span class="hljs-attr">paths:</span><br><span class="hljs-string">/api/v6/user/create:</span><br><span class="hljs-attr">get:</span><br><span class="hljs-attr">responses:</span><br><span class="hljs-attr">&#x27;200&#x27;:</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">OK</span><br><span class="hljs-attr">&#x27;401&#x27;:</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">Unauthorized</span><br><span class="hljs-attr">&#x27;402&#x27;:</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">Forbidden</span><br><span class="hljs-attr">&#x27;403&#x27;:</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">Not</span> <span class="hljs-string">Found</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>TSF 支持 Mesh 应用 API 上报功能。在应用程序所在目录中创建 apis 目录，用来放置服务的 API 定义。一个服务对应一个 yaml 文件，文件名就是服务名，如 petstore 服务对应的配置是 petstore.yaml。API 遵循 OPENAPI 3.0 规范 。user.yml 的 API 定义如上述代码所示：</p></li><li><p>官网文档：<a href="https://cloud.tencent.com/document/product/649/19049%EF%BC%88%E5%8F%82%E8%80%83%E5%85%B6%E4%B8%AD%E7%9A%84API">https://cloud.tencent.com/document/product/649/19049（参考其中的API</a> 定义和上报）</p></li><li><p>添加API配置文件后，在TSF的服务详情界面可以显示api列表。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211130151701522.png" alt="image-20211130151701522"></p></li><li><p>在定义了API配置文件后，框架会自动将接口注册到服务注册中心，实现接口级别的路由、鉴权和限流。</p></li></ul><h5 id="4-5-Mesh-应用-服务治理功能"><a href="#4-5-Mesh-应用-服务治理功能" class="headerlink" title="4.5 Mesh 应用-服务治理功能"></a>4.5 Mesh 应用-服务治理功能</h5><ul><li><p>Mesh 应用支持服务限流、服务鉴权、服务路由功能，无须额外依赖 SDK</p></li><li><p>Mesh 支持通过 HTTP Header 设置自定义标签</p><ul><li><p>以 Python 应用为例说明如何设置自定义标签，如下代码：（其中第三行代码： custom-key是自定义标签的名称，custom-value是自定义标签的值）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests<br><span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>headers = &#123;<span class="hljs-string">&#x27;custom-key&#x27;</span>: <span class="hljs-string">&#x27;custom-value&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.get(url, headers=headers)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>具体操作步骤会在TSF服务治理中介绍，这里大家先了解概念即可</p></li></ul><h5 id="4-6-Mesh-应用-采集日志"><a href="#4-6-Mesh-应用-采集日志" class="headerlink" title="4.6 Mesh 应用-采集日志"></a>4.6 Mesh 应用-采集日志</h5><ul><li>创建日志配置项时，选择日志格式为“无解析规则”，会使用日志采集时 间作为日志检索时的时间参数</li><li>官网文档：<a href="https://cloud.tencent.com/document/product/649/18196">https://cloud.tencent.com/document/product/649/18196</a></li><li>具体操作步骤会在TSF的日志管理功能中详细介绍。</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>Service Mesh的应用场景有哪些？</p><p>相对于Spring Cloud框架，Service Mesh有哪些独特的优势？</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、TSF与Spring cloud的集成</title>
    <link href="/2021/11/19/%E5%9B%9B%E3%80%81TSF%E4%B8%8ESpring-cloud%E7%9A%84%E9%9B%86%E6%88%90/"/>
    <url>/2021/11/19/%E5%9B%9B%E3%80%81TSF%E4%B8%8ESpring-cloud%E7%9A%84%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="四、TSF与Spring-cloud的集成"><a href="#四、TSF与Spring-cloud的集成" class="headerlink" title="四、TSF与Spring cloud的集成"></a>四、TSF与Spring cloud的集成</h3><p>本章主要为大家介绍了微服务，Spring Cloud，TSF概念以及功能；到目前为止我们已经掌握了Spring Cloud应用的基本开发，在前面的内容中也介绍了TSF是拥抱Spring Cloud微服务框架的，那TSF是如何跟SpirngCloud进行集成的呢？</p><p>实际上使用TSF集成SpirngCloud应用是非常简单的，接下来我会一步步为大家介绍TSF跟Spring Cloud集成。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以：</p><ul><li>了解YAML格式</li><li>掌握本地TSF服务的注册与发现</li><li>掌握TSF接入Spring Cloud的应用</li><li>掌握TSF接入Dubbo的应用 </li></ul><h4 id="第一章-YAML与FatJar简介"><a href="#第一章-YAML与FatJar简介" class="headerlink" title="第一章 YAML与FatJar简介"></a>第一章 YAML与FatJar简介</h4><p>在正式介绍TSF跟Sprig Cloud应用集成之前，先简单介绍YAML和FatJar；在Spring Boot 应用程序中我们已经简单使用过了yaml配置文件，在后面使用TSF都会大量运用到，所以这些必须先掌握。</p><h5 id="1-1-YAML概述"><a href="#1-1-YAML概述" class="headerlink" title="1.1 YAML概述"></a>1.1 YAML概述</h5><ul><li><p>YAML概念：专门用来写配置文件的语言。</p></li><li><p>YAML 的基本语法规则如下： </p><ul><li><strong>使用缩进表示层级关系</strong></li><li>缩进时不允许使用Tab键，<strong>只允许使用空格</strong></li><li><strong>缩进的空格数目不重要，只要相同层级的元素左侧对齐即</strong></li><li>大小写敏感</li></ul></li><li><p><strong>YAML 支持3种数据结构</strong>：</p><ul><li>对象：键值对的集合，又称为映射（mapping）/哈希（hashes）/字典（dictionary）。</li><li>数组：一组按次序排列的值，又称为序列（sequence）/ 列表（list）。</li><li>纯量（scalars）：单个的、不可再分的值</li></ul></li><li><p>在YAML之前使用的是xml，properties文件作为项目的配置文件；特别是早期使用Spring （如ssh框架，ssm框架）都大量使用了xml作为配置文件，目前使用Spring Cloud是同时支持properties和yaml配置文件的；</p></li><li><p>YAML和XML 相比，YAML 具有以下的优势，YAML类似于XML的数据描述语言，语法比XML简单很多，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务</p><ul><li>可读性好</li><li>和脚本语言的交互性好</li><li>使用实现语言的数据类型</li><li>可以基于流来处理</li><li>表达能力强，扩展性好</li><li>XML 解析效率比较低，不过支持自定义的数据类型</li></ul></li><li><p>JSON 的语法其实是YAML 的子集，大部分的JSON 文件都可以被YAML 的剖析器剖析。虽然大部分的数据分层形式也可以使用类似JSON 的格式，不过YAML 并不建议这样使用，除非这样编写能让文件可读性增加，更重要的是，YAML 的许多扩展在JSON 是找不到的，如：进阶资料形态、关系锚点、字串不需要引号、映射资料形态会储存键值的顺序等。</p></li><li><p>与properties文件对比：</p><ul><li>yaml在于其拥有天然的树状结构，：</li><li>在properties文件中是以”.”进行分割的，在yml中是用”:”进行分割; </li><li>yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值；</li><li>注意在yml中缩进一定<strong>不能使用TAB</strong>，否则会报很奇怪的错误；每个k的冒号后面一定都要加一个空格；</li></ul></li></ul><h6 id="1-1-1-YAML文件示例"><a href="#1-1-1-YAML文件示例" class="headerlink" title="1.1.1 YAML文件示例"></a>1.1.1 YAML文件示例</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119101752539.png" alt="image-20211119101752539"></p><ul><li><p>通过上面的示例可以很清晰的看出yaml文件存储的是键值对的形式，其结构非常清晰，天然的树状结构。</p></li><li><p>使用yaml千万要注意“：”后面一定要加空格（“ ”）。</p></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119101908296.png" alt="image-20211119101908296"></p><ul><li><p>如果字符串之中包含空格或特殊字符，需要放在引号之中。str: ‘内容: 字符串’</p></li><li><p>单引号和双引号都可以使用，双引号不会对特殊字符转义。</p><ul><li>s1: ‘内容\n字符串’ # 会对\n 字符转义</li><li>s2: “内容\n字符串” # 不会对\n 字符转义</li></ul></li><li><p>多行字符串可以使用| 保留换行符，也可以使用&gt; 折叠换行</p><ul><li>this: |</li><li>  Foo</li><li>  Bar</li><li>that: &gt;</li><li>  Foo</li><li>  Bar</li></ul></li></ul><h5 id="1-2-FatJar概述"><a href="#1-2-FatJar概述" class="headerlink" title="1.2 FatJar概述"></a>1.2 FatJar概述</h5><p>FatJar是一种可执行的Jar 包(Executable Jar)，FatJar和普通的Jar 不同在于它包含了依赖的Jar 包。</p><ul><li><p>FatJar打包介绍</p><ol><li><p>在工程的pom.xml 文件中添加插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在工程的主目录下执行maven命令:mvnclean package，在target 目录下找到打包好的FatJar文件。</p></li></ol></li><li><p>FatJar又称作uber-Jar，是包含所有依赖的Jar 包，是一个包含所有项目类文件和资源以及所有依赖关系的jar包。有不同的方法可以达到这样的效果：</p></li><li><p>优势1：依赖关系的jar被复制到主jar中，然后使用特殊的类加载器（onejar）加载</p></li><li><p>优势2：依赖关系的jar被提取到主jar层次结构的顶部（maven-assembly-plugin与它的jar-with-dependencies程序集，maven-shade-plugin和shade目标）</p></li></ul><h4 id="第二章-搭建本地-服务器TSF开发环境"><a href="#第二章-搭建本地-服务器TSF开发环境" class="headerlink" title="第二章 搭建本地/服务器TSF开发环境"></a>第二章 搭建本地/服务器TSF开发环境</h4><h5 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1 安装JDK"></a>2.1 安装JDK</h5><ul><li><p>确保开发环境已经安装了JDK：</p><ol><li><p>下载JDK：</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p></li><li><p>设置JAVA_HOME 环境变量，并指向您机器上的Java 安装目录</p></li><li><p>验证JDK环境：命令java -version</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119115407938.png" alt="image-20211119115407938"></p></li></ol></li><li><p>这里我们使用的是JDK1.8版本</p></li><li><p>在命令窗口使用java –version命令后，如果能出现jdk的版本信息则环境正常</p></li><li><p>具体的JDK按照步骤比较简单，这里就不重复说明了,具体的操作可以参考：<a href="https://cloud.tencent.com/document/product/649/20231#1.-.E5.AE.89.E8.A3.85-java%E3%80%82">https://cloud.tencent.com/document/product/649/20231#1.-.E5.AE.89.E8.A3.85-java。</a></p></li></ul><h5 id="2-2-安装Maven"><a href="#2-2-安装Maven" class="headerlink" title="2.2 安装Maven"></a>2.2 安装Maven</h5><ul><li><p>在执行安装脚本之前，需要确定已经安装了Maven和设置了环境变量。</p></li><li><p>下载Maven：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p></li><li><p>解压并设置环境变量：以Windows为例</p><p>新建系统变量MAVEN_HOME  变量值：E:\Maven\apache-maven-3.3.9</p><p>编辑系统变量Path         添加变量值：;%MAVEN_HOME%\bin</p></li><li><p>验证Maven环境：命令mvn–version</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119115725016.png" alt="image-20211119115725016"></p></li><li><p>目前新版的ide开发工具已经集成了maven，eclipse oxygen版已经集成了maven环境</p></li></ul><h5 id="2-3-安装TSF-SDK"><a href="#2-3-安装TSF-SDK" class="headerlink" title="2.3 安装TSF SDK"></a>2.3 安装TSF SDK</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119115842757.png" alt="image-20211119115842757"></p><ul><li><p>如图，TSF的sdk安装步骤分为4步；前面2个步骤为环境准备，环境的安装步骤在2.1，2.2中有介绍.</p></li><li><p><strong>步骤一：</strong></p><ul><li>JDK安装见2.1章节内容</li></ul></li><li><p><strong>步骤二：</strong></p><ul><li>Maven安装见2.2章节内容</li><li>Maven 配置腾讯云TSF 私服地址（使用下载的setting.xml 替换原本的配置文件）</li><li>setting.xml 样例文件下载地址：</li></ul><p>​       <a href="https://main.qcloudimg.com/raw/0e3c73b64c4ec64ae9b16d1a347db462/settings.xml">https://main.qcloudimg.com/raw/0e3c73b64c4ec64ae9b16d1a347db462/settings.xml</a></p><ul><li><p>可参考官方文档说明：</p><p><a href="https://cloud.tencent.com/document/product/649/20231">https://cloud.tencent.com/document/product/649/20231</a></p></li><li><p>setting.xml是maven的配置文件，一般在~/.m2/settings.xml 中，可以在maven的安装目录下的conf文件夹中找到，可以用此处下载的setting样例文件替换原本的setting.xml配置文件</p></li><li><p>配置TSF私服地址主要是为了能够通过maven获取TSF的SDK代码</p></li><li><p>如果替换原有的setting配置文件，本地注意备份</p></li></ul></li><li><p><strong>步骤三：</strong></p><ul><li>获取TSF的Demo工程</li><li>Demo工程的下载地址：</li></ul><p>​       <a href="https://main.qcloudimg.com/raw/082d94a76b7c0a34feb909c130b72179/tsf-demo-simple-1120.zip">https://main.qcloudimg.com/raw/082d94a76b7c0a34feb909c130b72179/tsf-demo-simple-1120.zip</a></p><ul><li><p>TSF官网Demo工程如下：</p><ul><li>|-consumer-demo</li><li>|-provider-demo</li><li>|-pom.xml</li></ul></li><li><p>可参考官方文档说明：</p><p><a href="https://cloud.tencent.com/document/product/649/20261">https://cloud.tencent.com/document/product/649/20261</a></p></li><li><p>获取TSF官网提供的Demo工程，如果有版本更新，只需要更新demo项目根目录下的pom.xml文件，修改TSF的依赖版本。更新日志参考<a href="https://cloud.tencent.com/document/product/649/20230">https://cloud.tencent.com/document/product/649/20230</a></p></li><li><p><strong>步骤四：</strong></p><ul><li><p>在Demo 工程中，pom.xml 所在目录执行mvn clean package 即可下载TSF SDK</p></li><li><p>执行完成后，显示build success 表示SDK安装成功。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120135246895.png" alt="image-20211120135246895"></p></li></ul></li><li><p>详情可参考官网的TSF SDK安装：<a href="https://cloud.tencent.com/document/product/649/20231">https://cloud.tencent.com/document/product/649/20231</a></p></li></ul><h6 id="2-3-1-TSF-SDK官方文档地址："><a href="#2-3-1-TSF-SDK官方文档地址：" class="headerlink" title="2.3.1 TSF SDK官方文档地址："></a>2.3.1 TSF SDK官方文档地址：</h6><p><a href="https://cloud.tencent.com/document/product/649/20231">https://cloud.tencent.com/document/product/649/20231</a></p></li></ul><h4 id="第三章-Spring-Cloud应用迁移到TSF"><a href="#第三章-Spring-Cloud应用迁移到TSF" class="headerlink" title="第三章 Spring Cloud应用迁移到TSF"></a>第三章 Spring Cloud应用迁移到TSF</h4><p>在前面我们主要介绍了yaml配置文件，fatjar，以及TSF的sdk安装，到目前为止，TSF开发的基本环境都已经准备好了，接下来我们先看一下如何在本地使用Spring Cloud应用和TSF进行集成测试。</p><h5 id="3-1-Spring-Cloud-集成TSF本地开发测试"><a href="#3-1-Spring-Cloud-集成TSF本地开发测试" class="headerlink" title="3.1 Spring Cloud 集成TSF本地开发测试"></a>3.1 Spring Cloud 集成TSF本地开发测试</h5><ul><li><p>Spring Cloud 集成TSF本地开发测试步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120135516783.png" alt="image-20211120135516783"></p></li><li><p>我们都知道TSF提供了服务发现与注册，如果要在本地进行SpirngCloud与TSF集成测试，我们需要先在本地安装启动轻量级服务注册中心（consul）；对于Spring cloud应用TSF提供consul作为服务注册中心；这也是我们的第一个步骤：创建轻量级服务注册中心</p></li></ul><h6 id="3-1-1-创建轻量级服务注册中心"><a href="#3-1-1-创建轻量级服务注册中心" class="headerlink" title="3.1.1 创建轻量级服务注册中心"></a>3.1.1 创建轻量级服务注册中心</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120135714144.png" alt="image-20211120135714144"></p><ul><li><p>TSF中使用Consul作为服务注册中心而不是SpirngCloud中的Eureka；如上是Eureka与Consul对比；Eureka 2.x已停止更新。</p></li><li><p><strong>创建轻量级服务注册中心：</strong></p><ul><li>轻量级服务注册中心给开发者提供在开发、调试、测试过程中的服务发现、注册和查询功能。</li><li>本地开发调试时，需要使用轻量级注册中心，轻量级注册中心包含了TSF 服务注册发现服务端的轻量版。</li><li>如果不涉及到多个微服务联调场景，可以通过本地机器启动一个Consul 作为轻量服务注册中心。<ul><li>单机调试支持Windows 和Linux / macOS 操作系统。</li><li>确保以下机器端口是空闲的：8300, 8301, 8302, 8500, 8600。</li></ul></li><li>Consul下载地址：<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a> </li><li>也可以是用brew下载consul： brew install consul<ul><li><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120140805807.png" alt="image-20211120140805807"></li></ul></li></ul></li><li><p>consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。</p></li><li><p>服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。</p></li><li><p><strong>启动Consul，命令：</strong></p><ul><li><p>Windows 操作系统：.\consul.exe agent -dev</p></li><li><p>Linux / macOS 操作系统：./consul agent -dev</p><ul><li><p>我是使用brew下载的：所以我得启动命令是/opt/homebrew/opt/consul/bin/consul agent -dev</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120140926786.png" alt="image-20211120140926786"></p></li></ul></li></ul></li><li><p>通过浏览器查看服务注册中心页面：<a href="http://127.0.0.1:8500/">http://127.0.0.1:8500</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211120140951139.png" alt="image-20211120140951139"></p></li><li><p>如果访问<a href="http://127.0.0.1:8500/">http://127.0.0.1:8500</a> 能出现如上图结果，表示我们的服务注册中心启动成功</p></li><li><p>多微服务联调环境的轻量服务注册中心：在多个微服务联调场景下，可以找一台可以被微服务访问的机器来部署轻量服务注册中心。目前本场景下仅支持Linux 系统的Consul</p></li><li><p>详情参考：<a href="https://cloud.tencent.com/document/product/649/16618">https://cloud.tencent.com/document/product/649/16618</a></p></li></ul><h6 id="3-1-2-创建服务提供者（本地开发应用）"><a href="#3-1-2-创建服务提供者（本地开发应用）" class="headerlink" title="3.1.2 创建服务提供者（本地开发应用）"></a>3.1.2 创建服务提供者（本地开发应用）</h6><p>创建 tsf-demo 工程，文件结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|- consumer-demo</span><br><span class="hljs-string">|- provider-demo</span><br><span class="hljs-string">|- pom.xml</span><br></code></pre></td></tr></table></figure><p>其中<code>pom.xml</code>文件参考 <a href="https://cloud.tencent.com/document/product/649/20261">Demo 工程概述</a> 中的<code>pom.xml</code>内容。</p><ul><li><p>服务提供者创建步骤：</p><ol><li><p>创建一个Spring Cloud 工程，命名为provider-demo(结构如下)</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211122141111326.png" alt="image-20211122141111326"></p></li><li><p>修改pom 依赖，引入TSF依赖（完整的pom依赖）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tsf-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>provider-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>provider-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>开启服务注册发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 使用Feign微服务调用时请启用</span><br><span class="hljs-meta">@EnableTsf</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ProviderApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供echo 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo/&#123;string&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String string)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改application.yml配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18081</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">provider-demo</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>具体操作步骤参考官方文档：</p><p><a href="https://cloud.tencent.com/document/product/649/16617">https://cloud.tencent.com/document/product/649/16617</a></p></li><li><p>服务提供者开发操作步骤跟之前演示的Spring Cloud应用程序服务提供者开发步骤一致，这里区别在与引入了TSF相关依赖</p></li><li><p>这里的yml配置文件就是我们前面讲的YAML配置文件</p></li></ul><h6 id="3-1-3-创建服务消费者-本地开发应用"><a href="#3-1-3-创建服务消费者-本地开发应用" class="headerlink" title="3.1.3 创建服务消费者(本地开发应用)"></a>3.1.3 创建服务消费者(本地开发应用)</h6><ul><li><p>服务消费者创建步骤：</p><ol><li><p>创建一个Spring Cloud 工程，命名为consumer-demo</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211122144008373.png" alt="image-20211122144008373"></p></li><li><p>修改pom 依赖，引入TSF依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tsf-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>     <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <br> <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>     <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>     <br></code></pre></td></tr></table></figure></li><li><p>开启服务注册发现，与服务提供者provider-demo 相比，还需要添加两项配置才能使用RestTemplate、AsyncRestTemplate、FeignClient 这三个客户端</p><ul><li>添加<code>@LoadBalanced</code>注解将<code>RestTemplate</code>与<code>AsyncRestTemplate</code>与服务发现结合。</li><li>使用<code>@EnableFeignClients</code>注解激活<code>FeignClients</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.tsf.annotation.EnableTsf;<br><span class="hljs-keyword">import</span> org.springframework.web.client.AsyncRestTemplate;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 使用 Feign 微服务调用时请启用</span><br><span class="hljs-meta">@EnableTsf</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncRestTemplate <span class="hljs-title">asyncRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncRestTemplate();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置调用信息</p><ul><li><p>在使用<code>EchoService</code>的<code>FeignClient</code>之前，还需要完善它的配置。配置服务名以及方法对应的 HTTP 请求，服务名为<code>provider-demo</code>工程中配置的服务名<code>provider-demo</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><br><span class="hljs-meta">@FeignClient(name = &quot;provider-demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EchoService</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function">String <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;str&quot;)</span> String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建Controller</p><ul><li>创建一个<code>Controller</code>供调用测试。</li><li><code>/echo-rest/*</code>验证通过 RestTemplate 去调用服务提供者。</li><li><code>/echo-async-rest/*</code>验证通过 AsyncRestTemplate 去调用服务提供者。</li><li><code>/echo-feign/*</code>验证通过 FeignClient 去调用服务提供者。</li></ul><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;<br><span class="hljs-keyword">import</span> org.springframework.util.concurrent.ListenableFuture;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.client.AsyncRestTemplate;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AsyncRestTemplate asyncRestTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span>  EchoService echoService;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo-rest/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://provider-demo/echo/&quot;</span> + str, String.class);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo-async-rest/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">asyncRest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = asyncRestTemplate.<br>                getForEntity(<span class="hljs-string">&quot;http://provider-demo/echo/&quot;</span>+str, String.class);<br>        <span class="hljs-keyword">return</span> future.get().getBody();<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo-feign/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">feign</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> echoService.echo(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改application.yml配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18083</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer-demo</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>具体操作步骤参考官方文档：</p><p><a href="https://cloud.tencent.com/document/product/649/16617">https://cloud.tencent.com/document/product/649/16617</a></p></li><li><p>服务消费者开发操作步骤跟之前演示的Spring Cloud应用程序的消费者开发步骤一致，这里区别在与引入了TSF相关依赖</p></li></ul><h6 id="3-1-4-本地开发调试"><a href="#3-1-4-本地开发调试" class="headerlink" title="3.1.4 本地开发调试"></a>3.1.4 本地开发调试</h6><ul><li><p>启动轻量级注册中心，在终端执行以下命令（就是在你安装consul的目录： 执行consul agent -dev命令）：</p><p>/opt/homebrew/opt/consul/bin/consul agent -dev</p></li><li><p>启动应用：本地启动应用的两种方式：</p><ol><li>IDE 中启动<ul><li>通过VM options 配置启动参数-Dtsf_consul_ip=127.0.0.1 -Dtsf_consul_port=8500 ；指明了服务注册中心的ip以及端口；</li><li>如果使用了分布式配置功能的模块，还需要设置-Dtsf_application_id=a -Dtsf_group_id=b，取值可为任意值</li></ul></li><li>FatJar启动<ul><li>打包好fatjar后通过java命令启动：（示例如下）</li><li>java -Dtsf_consul_ip=127.0.0.1 -Dtsf_consul_port=8500 -jar provider-demo-0.0.1-SNAPSHOT.jar</li></ul></li></ol><ul><li>此处注意在部署到TSF以后是不需要加如上参数，在TSF平台中已经把注册中心的ip以及端口放到了环境变量中</li></ul></li><li><p>启动后访问：</p><p><a href="http://localhost:8500可以在consul注册中心发现服务提供者和服务消费者">http://localhost:8500可以在consul注册中心发现服务提供者和服务消费者</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211122150349238.png" alt="image-20211122150349238"></p></li><li><p>访问服务消费者，分别进行调用，观察调用结果（这里以本地演示）</p><ul><li><p><a href="http://localhost:18083/echo-rest/echo-test![image-20211122150749832](https://gitee.com/divemaven/git-project/raw/master/image-20211122150749832.png)">http://localhost:18083/echo-rest/echo-test![image-20211122150749832](https://gitee.com/divemaven/git-project/raw/master/image-20211122150749832.png)</a></p></li><li><p><a href="http://localhost:18083/echo-async-rest/echo-async-rest">http://localhost:18083/echo-async-rest/echo-async-rest</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211122150903689.png" alt="image-20211122150903689"></p></li><li><p><a href="http://localhost:18083/echo-feign/feign">http://localhost:18083/echo-feign/feign</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211122151008702.png" alt="image-20211122151008702"></p></li></ul></li></ul><p>详细步骤参考官网文档：<a href="https://cloud.tencent.com/document/product/649/16617%EF%BC%9B%E5%AE%9E%E9%99%85%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%AD%A5%E9%AA%A4%E8%B7%9F%E5%89%8D%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84Spring">https://cloud.tencent.com/document/product/649/16617；实际上基本操作，访问步骤跟前面开发的Spring</a> Cloud应用程序一致</p><h5 id="3-2-Spring-Cloud-旧应用迁移到TSF"><a href="#3-2-Spring-Cloud-旧应用迁移到TSF" class="headerlink" title="3.2 Spring Cloud 旧应用迁移到TSF"></a>3.2 Spring Cloud 旧应用迁移到TSF</h5><ul><li><p>Spring Cloud 旧应用迁移到TSF：</p><ul><li><p>Spring Cloud应用如果原本使用的是Eureka 服务注册中心，要迁移到TSF，首先就需要把注册中心从Eureka迁移至consul注册中心；</p></li><li><p>迁移到TSF步骤如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211123133215861.png" alt="image-20211123133215861"></p></li></ul></li><li><p>Spring Cloud开发的应用使用的是Eureka作为服务注册中心，那如何将Eureka服务注册中心迁移至TSF呢？实际上从Eureka迁移到TSF是把注册中心从eureka迁移到TSF提供的consul注册中心，所以基本步骤是添加TSF，consul对应的依赖包，然后修改应用启动类中的Eureka启动注解为consul的服务发现注解</p></li><li><p>在工程根目录的pom.xml 中增加spring-cloud-tsf-dependencies 的parent。</p></li><li><p>在单个Spring Cloud 应用的pom.xml 中，将spring-cloud-starter-eureka 替换成spring-cloud-starter-consul-discovery。</p></li></ul><h6 id="3-2-1-添加parent配置"><a href="#3-2-1-添加parent配置" class="headerlink" title="3.2.1 添加parent配置"></a>3.2.1 添加parent配置</h6><ul><li><p>步骤一：</p><ul><li><p>pom.xml中根节点下添加parent配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.23.0-Greenwich-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>这里的项目代码以SpirngCloud内容介绍中的案例为基础。</p></li><li><p>首先添加TSF的SDK作为parent</p></li></ul></li></ul><h6 id="3-2-2-添加tsf-starte依赖"><a href="#3-2-2-添加tsf-starte依赖" class="headerlink" title="3.2.2 添加tsf-starte依赖"></a>3.2.2 添加tsf-starte依赖</h6><ul><li><p>步骤二：</p><ul><li><p>pom.xml中替换eureka的依赖为consul:</p><ul><li><p>替换前：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- springboot 1.5.11对应的springcloud依赖管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>替换后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>完整的POM文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.23.0-Greenwich-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-tsf-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h6 id="3-2-3-添加注解"><a href="#3-2-3-添加注解" class="headerlink" title="3.2.3 添加注解"></a>3.2.3 添加注解</h6><ul><li><p>步骤三：</p><ul><li><p>替换eureka启动注解为TSF注解:</p></li><li><p>以eureka-provider为例，只需要在启动类中替换@EnableEurekaClient注解为@EnableDiscoveryClient注解即可</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211123141925675.png" alt="image-20211123141925675"></p></li></ul></li><li><p>@EnableDiscoveryClient表明开启consul的服务发现，由于在之前的项目我们已经加上了@EnableDiscoveryClient注解，所以此次在原项目基础上只需要去掉@EnableEurekaClient即可。</p></li><li><p>@EnableDiscoveryClient是由spring Cloud提供的注解，支持eureka，consul，zookkeeper注册中心。</p></li><li><p>完成这些操作以后，就可以完成Eureka迁移到TSF中。从前面的步骤也可以看出来，整个迁移过程是非常简单的。</p></li><li><p>TSF 中的相关注解：</p><ul><li>注解：**@EnableTsfAuth**<ul><li>TSF 提供了两种类型的鉴权能力，一种根据调用方服务名，一种根据调用方设置的tag。在管控端进行配置鉴权。</li><li>其实原理是一样的，服务名作为一种特殊的key的tag。在服务调用时，客户端传输tag，服务端根据鉴权规则进行判断</li><li>其中标签将会在后面的内容介绍，这里大家先了解即可</li></ul></li><li><strong>注解：@EnableTsfRoute</strong><ul><li>启用TSF的路由功能</li></ul></li><li><strong>注解：@EnableTsfRateLimit启动</strong><ul><li>使用管控端写入到consul配置，服务端拉取配置信息，进行流控(令牌桶)。</li></ul></li></ul></li></ul><p>3.2.4 启动测试</p><ul><li><p>​    启动eureka-provider</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211123155315102.png" alt="image-20211123155315102"></p></li></ul><p>3.2.5 异常检查以及部署</p><ul><li>TSF 中部署应用<ul><li>将打包好的FatJar程序包上传到TSF 控制台进行部署操作，不需要额外配置。</li></ul></li><li>通过TSF 平台部署改造后的应用，如发现应用无法启动，说明没有正确依赖TSF 相关依赖，可参考Demo 工程中pom.xml 文件。</li><li>从前面的步骤来看，Spring Cloud应用迁移至TSF实际上是非常简单的，只需要在原应用的基础上添加TSF相关依赖，注解，然后再通过TSF控制台部署应用即可。</li><li>部署步骤暂时不做演示，TSF控制台部署应用会在后续的TSF平台管理能力中介绍，这里大家可以结合前面讲到的TSF的概念关系内容思考一下。</li></ul><h4 id="第四章-Dubbo应用迁移到TSF"><a href="#第四章-Dubbo应用迁移到TSF" class="headerlink" title="第四章 Dubbo应用迁移到TSF"></a>第四章 Dubbo应用迁移到TSF</h4><p>前面在介绍TSF的时候，有讲到TSF时拥抱微服务开源框架的，支持Spring Cloud应用，Dubbo应用，ServcieMesh应用。上一章节中已经介绍了Spring Cloud应用程序迁移至TSF后，接下来看一下Dubbo应用如何迁移到TSF。</p><h5 id="4-1-什么是Dubbo？"><a href="#4-1-什么是Dubbo？" class="headerlink" title="4.1 什么是Dubbo？"></a>4.1 什么是Dubbo？</h5><p>Dubbo是阿里巴巴公司开源的一个高性能，优秀的服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211123175729836.png" alt="image-20211123175729836"></p><ul><li><p>高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：</p><ol><li>面向接口的远程方法调用</li><li>智能容错和负载均衡</li><li>服务自动注册和发现</li></ol></li><li><p>采用全Spring 配置方式，透明化接入应用，只需用Spring 加载Dubbo的配置即可，可以Spring框架无缝集成。</p></li></ul><h5 id="4-2-Dubbo协议应用迁移到TSF"><a href="#4-2-Dubbo协议应用迁移到TSF" class="headerlink" title="4.2 Dubbo协议应用迁移到TSF"></a>4.2 Dubbo协议应用迁移到TSF</h5><ul><li><p>Dubbo 应用接入TSF开发步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211123180046691.png" alt="image-20211123180046691"></p></li><li><p>如上图是Dubbo迁移到TSF的开发步骤，此处步骤基于Dubbo官方案例Demo。可参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p></li></ul><h6 id="4-2-1-从Dubbo迁移到TSF"><a href="#4-2-1-从Dubbo迁移到TSF" class="headerlink" title="4.2.1 从Dubbo迁移到TSF"></a>4.2.1 从Dubbo迁移到TSF</h6><ul><li><p>安装依赖:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Terminal">mvn install:install-file -Dfile=dubbo-registry-consul-1.1.4-SNAPSHOT.jar <br>-DpomFile=dubbo-registry-consul-1.1.4-SNAPSHOT.pom<br></code></pre></td></tr></table></figure></li><li><p>依赖包直接下载地址：</p><p><a href="https://main.qcloudimg.com/raw/d075de11daa5d1427346e19880cd5492/dubbo-registry-consul-1.1.4-SNAPSHOT.zip">https://main.qcloudimg.com/raw/d075de11daa5d1427346e19880cd5492/dubbo-registry-consul-1.1.4-SNAPSHOT.zip</a></p></li><li><p>注册中心配置：</p><ul><li>把&lt;dubbo:registry address=”multicast://224.5.6.7:1234”/&gt;替换为&lt;dubbo:registry address=”consul://注册中心地址：端口”/&gt;</li></ul></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tencent.tsf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-registry-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--修改为对应的版本号--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.4-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打包Fatjar</p><ul><li>可以通过maven-shade-plugin 来构建一个包含所有依赖的jar 包（FatJar）。执行命令mvn clean  package</li></ul></li><li><p>Dubbo应用接入TSF官网文档：</p><p><a href="https://cloud.tencent.com/document/product/649/13947">https://cloud.tencent.com/document/product/649/13947</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、TSF微服务平台介绍</title>
    <link href="/2021/11/18/%E4%B8%89%E3%80%81TSF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/11/18/%E4%B8%89%E3%80%81TSF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="三、TSF微服务平台介绍"><a href="#三、TSF微服务平台介绍" class="headerlink" title="三、TSF微服务平台介绍"></a>三、TSF微服务平台介绍</h3><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以：</p><ul><li>了解TSF相关概念与功能</li><li>掌握TSF的优势</li><li>了解TSF的应用场景</li></ul><h4 id="第一章-TSF概念和功能"><a href="#第一章-TSF概念和功能" class="headerlink" title="第一章 TSF概念和功能"></a>第一章 TSF概念和功能</h4><p>在第一章节中我们主要为大家介绍TSF的概念以及功能。</p><h5 id="1-1-什么是TSF"><a href="#1-1-什么是TSF" class="headerlink" title="1.1 什么是TSF"></a>1.1 什么是TSF</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118195702184.png" alt="image-20211118195702184"></p><ul><li><strong>在正式介绍TSF之前我们先来看一下微服务给开发和运维带来的困难：</strong><ul><li>运维复杂</li><li>代码改造复杂</li><li>架构复杂度高</li><li>定位问题困难</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118195805191.png" alt="image-20211118195805191"></p><ul><li>虽然使用微服务架构给我们的开发工作带来了很多便捷，但是同时也带来了很多困难，比如：原来只有一个war 包，现在可能被拆成了几十个，甚至几百个微服务，势必会给我们的运维带来一定的困难，那这些问题需要怎么去解决呢？答案就是：腾讯分布式微服务平台TSF。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118195855363.png" alt="image-20211118195855363"></p><ul><li>微服务带来的代码改困难，异构语言改造复杂。</li></ul><ul><li><p><strong>腾讯微服务平台TSF (Tencent Service Framework) 是一个围绕应用和微服务的PaaS 平台。</strong></p><ul><li>提供服务全生命周期管理能力和数据化运营支持。</li><li>提供多维度应用、服务、机器的监控数据，助力服务性能优化。</li><li>拥抱Spring Cloud 、Service Mesh 微服务框架。</li><li>让企业轻松构建大型分布式系统。</li></ul></li><li><p>接下来正式介绍TSF到底是什么。</p></li><li><p>**IaaS(Infrastructure-as-a-Service)**：基础设施即服务。消费者通过Internet可以从完善的计算机基础设施获得服务。例如：租用虚拟机。提供IaaS层功能的厂商有亚马逊的AWS，阿里云、腾讯云、华为云、百度云等。</p></li><li><p>**PaaS(Platform-as-a-Service)**：平台即服务。PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户，因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。例如：软件的个性化定制开发。提供PaaS功能的云计算厂商有亚马逊，腾讯云，windows Azure，Google，RedHat的openshift等。</p></li><li><p>**SaaS(Software-as-a-Service)**：软件即服务。它是一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。提供SaaS功能的厂商有腾讯云，google，微软等。</p></li><li><p>举个简单的例子：我们以披萨作比喻，如果自己做披萨，那披萨皮，酱料，烤箱等全部需要自己准备，这样是非常麻烦的，那使用了laaS以后呢，我们只需要买现成的披萨皮，配料就可以了，如果使用PaaS那就相当于叫披萨外卖，只需要准备餐桌吃就可以了，如果使用SaaS就相当于直接去披萨店吃就可以了，什么都不需要准备（当然还是的准备钱的了）。</p></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118204446407.png" alt="image-20211118204446407"></p><ul><li>介绍TSF的平台目标，核心用户，核心特征</li><li>TSF平台的目标是<strong>帮助用户快速构建轻量级应用，提供微服务治理，一站式运维管控功能</strong></li><li>从平台的目标我们也可以看出来，<strong>TSF的核心用户是业务的设计者，开发，运维人员</strong>。</li><li><strong>核心特征是微服务驱动云化</strong>，这也跟TSF的定义，围绕着应用与微服务是一致的。</li></ul><h5 id="1-2-TSF的功能"><a href="#1-2-TSF的功能" class="headerlink" title="1.2 TSF的功能"></a>1.2 TSF的功能</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118204637421.png" alt="image-20211118204637421"></p><ul><li><p>通过CICD全流程一站式解决方案打通开发到运维的各个环节，拥抱开源的微服务框架，提供服务治理，数据化运营功能，同时打通腾讯云中间件产品，帮助企业轻松构建大型分布式系统。</p></li><li><p><strong>服务注册发现：</strong></p><ul><li>TSF 服务注册发现包括三个角色，<strong>服务提供者，服务调用者和服务注册中心</strong>。服务提供者和服务调用者将地址信息注册到服务注册中心，并从服务注册中心获取所有注册服务的实例列表。当用户使用Spring Cloud 框架时，TSF 使用Consul 作为服务注册中心。服务提供者和消费者使用Spring Cloud Consul 组件来实现与Consul 服务注册中心集群的通信。</li><li>TSF 也提供兼容Dubbo 框架的应用注册到Consul 服务注册中心。</li><li>TSF 支持Service Mesh 框架，支持不同框架、不同语言间服务相同调用，解决多语言异构问题。</li></ul></li><li><p><strong>分布式配置管理：</strong></p><ul><li>用户可以<strong>通过控制台进行分布式配置管理，实时更新线上配置内容，实时发布</strong>，并选择在应用内部或整个环境上进行发布。</li></ul></li><li><p><strong>数据化运营：</strong></p><ul><li>监控包括<strong>应用监控</strong>，应用监控的指标包括应用的QPS, 请求时间和请求出错率等。</li><li><strong>分布式调用链分析</strong>包括调用链查询和调用链详情。用户可以根据时间范围和服务名等条件来查询一组调用链。调用链详情显示了请求经过每个服务的层次关系和耗时情况等信息。</li><li><strong>TSF 提供日志分析能力</strong>，自动获取用户的业务日志并支持在TSF 控制台上进行日志查看、日志检索，支持日志关键词告警功能，并提供日志与调用链联动排查线上问题</li></ul></li><li><p><strong>应用生命周期管理：</strong></p><ul><li>TSF 提供从创建应用到运行应用的全程管理，功能包括<strong>创建、删除、部署、回滚、扩容、下线、启动和停止应用</strong>。TSF 提供应用分组来实现应用的版本控制功能。同时，在TSF 控制台上可以设置自定义JVM 参数。TSF 将每次操作记录下来，用户可以在应用的变更记录页面中查看和搜索变更记录。    </li></ul></li><li><p><strong>细粒度服务治理：</strong></p><ul><li>TSF 提供API 级别的服务治理能力。支持控制台上进行<strong>配置服务路由、服务限流、服务鉴权规则</strong>。在TSF 控制台上，用户可以通过<strong>配置、权重标签</strong>的形式进行细粒度的流量控制，<strong>实现灰度发布、就近路由、部分账号内测、流量限制、访问权限控制等</strong>功能。</li></ul></li><li><p><strong>分布式事务：</strong></p><ul><li>TSF 集成了分布式事务能力，支持TCC 模式分布式事务管理功能。对于跨数据库、跨服务的分布式场景，用户可以在控制台上查看事务运行情况并进行超时事务处理。保证事务的一致性</li></ul></li><li><p><strong>打通中间件产品：</strong></p><ul><li>TSF 可以与腾讯云多款成熟中间件产品打通，包括腾讯云API Gateway、消息队列CMQ 、CKafka 等。腾讯云微服务API Gateway 可以建立路径到微服务ID 的映射方式，同时提供负载均衡、熔断等能力。</li></ul></li></ul><h5 id="1-3-TSF整体架构"><a href="#1-3-TSF整体架构" class="headerlink" title="1.3 TSF整体架构"></a>1.3 TSF整体架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118205308100.png" alt="image-20211118205308100"></p><ul><li>上图是TSF的整体架构图，简述TSF基本架构，同时打通了腾讯云中间件组件。</li></ul><h5 id="1-4-利用TSF打造企业技术中台"><a href="#1-4-利用TSF打造企业技术中台" class="headerlink" title="1.4 利用TSF打造企业技术中台"></a>1.4 利用TSF打造企业技术中台</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118205410123.png" alt="image-20211118205410123"></p><ul><li>在前面我们介绍了软件架构的演变过程，由单体架构到soa面向服务架构，再到微服务架构，基于微服务架构我们把各个业务系统的相同功能抽取出来，<strong>把抽取的公用功能进行统一维护与处理，所有的其它业务系统都可以公用这些公共服务，这些公共的微服务也被称之为中台</strong>。</li><li>中台这个概念早期是由美军的作战体系演化而来的，技术上所说的“中台”主要是指<strong>学习这种高效、灵活和强大的指挥作战体系</strong>。电商经过十几年的发展，组织已经庞大而复杂，业务不断细化拆分，也导致野蛮发展的系统越来越不可维护，开发和改造效率极低，也有很多新业务不得不重复造轮子，所以中台的<strong>目标是为了解决效率问题，同时降低创新成本</strong>。所谓的业务中台就是：<strong>通过制定标准和机制，把不确定的业务规则和流程通过工业化和市场化的手段确定下来，以减少人与人之间的沟通成本，同时还能最大程度地提升协作效率</strong>。</li><li><strong>中台的目标：减少沟通成本，提升协作效率。</strong></li><li><strong>中台的实现手段：制定标准和规范。</strong></li><li><strong>原则：集中管控，分布式执行。</strong></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118205858006.png" alt="image-20211118205858006"></p><ul><li>通过TSF打造技术中台，提供公用功能，让企业只需要关心业务。</li></ul><h5 id="1-5-TSF用户面板"><a href="#1-5-TSF用户面板" class="headerlink" title="1.5 TSF用户面板"></a>1.5 TSF用户面板</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118205939757.png" alt="image-20211118205939757"></p><ul><li>资源中心：可以在资源中心<strong>配置集群，命名空间，部署组</strong>。</li><li>应用中心：可以实现<strong>应用管理，服务治理，配置管理，事务管理</strong>功能。<ul><li>服务治理<ul><li>服务鉴权：处理微服务之间相互访问的权限问题</li><li>服务限流：主要是保护<strong>服务节点或者数据节点</strong>，<strong>防止瞬时流量过大使服务和数据崩溃，造成服务不可用</strong>。当资源成为瓶颈时，服务框架需要对请求做限流，启动流控保护机制。</li><li>服务路由：用户在使用TSF 运行自己的业务时，由于业务的复杂程度，常常需要部署数目庞大的服务运行在现网环境中。这些服务运行在属性不同的实例上、部署在不同的地域中，用户经常需要选择符合自己特定要求的属性来选择服务的提供者，对服务间流量的分配起到掌控的作用。</li><li>查询api列表：可以查询当前微服务应用下的服务列表</li></ul></li></ul></li><li>配置管理：为了解决分布式环境下多台服务实例的配置统一管理问题，TSF 提供了具备分布式配置功能</li><li>事务管理：TSF 分布式事务服务（TSF Distributed Transaction Service, TDTS）是一款高性能、高可靠的分布式事务中间件，旨在解决分布式环境下的事务一致性问题。一个完整的业务往往涉及到多个子业务，随着业务数增加，系统逐渐演变为分布式系统，进而带来了数据一致性的问题。</li><li>运维中心<ul><li>日志服务：为用户提供一站式日志服务，从日志采集、日志存储到日志内容搜索，帮助用户轻松定位业务问题。</li><li>日志报警：日志告警功能允许您通过配置业务日志中的关键词，设置关键词出现频率的告警。您需要在TSF控制台上配置需要告警的关键词和监控对象，并在云监控界面上配置告警通知人。</li><li>服务依赖拓扑查询：TSF平台提供了用户查询服务间互相依赖的拓扑图查询功能</li><li>弹性伸缩：是根据用户的业务需求和策略，经济地自动调整弹性计算资源的管理服务。弹性伸缩不仅适合业务量不断波动的应用程序，同时也适合业务量稳定的应用程序。</li></ul></li><li>仓库中心：提供docker应用的镜像管理，软件应用的仓库管理，服务编排功能</li></ul><h4 id="第二章-TSF产品优势"><a href="#第二章-TSF产品优势" class="headerlink" title="第二章 TSF产品优势"></a>第二章 TSF产品优势</h4><h5 id="2-1-TSF产品优势"><a href="#2-1-TSF产品优势" class="headerlink" title="2.1 TSF产品优势"></a>2.1 TSF产品优势</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211119093732078.png" alt="image-20211119093732078"></p><ul><li>这里主要是通过对比的方式介绍TSF的功能优势，通过对比自行搭建服务治理平台跟TSF在相同项的做法，成本比较，把TSF的优势突显出来。</li></ul><p><strong>微服务TSF平台为企业，重点提供自治的中台能力、缩短迭代周期和保障7*24小时高可靠运</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211033056.png" alt="image-20211118211033056"></p><ul><li>从架构演变的过程体现微服务架构TSF平台的优势</li></ul><h6 id="2-1-1-高度自治的中台能力"><a href="#2-1-1-高度自治的中台能力" class="headerlink" title="2.1.1 高度自治的中台能力"></a>2.1.1 高度自治的中台能力</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211158008.png" alt="image-20211118211158008"></p><ul><li>高度自治的中台能力：<ol><li>基于业务领域设计需求，逐渐在使用中清晰化功能</li><li>业务变化，最小粒度基于接口招标，人力外包</li><li>开放的系统架构下，代码复用能力强，企业具备自主开发能力，更新迭代速度块，不停服的进行更新</li><li>人力外包灵活选择，质优价廉</li></ol></li></ul><h6 id="2-1-2-缩短迭代周期"><a href="#2-1-2-缩短迭代周期" class="headerlink" title="2.1.2 缩短迭代周期"></a>2.1.2 缩短迭代周期</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211456054.png" alt="image-20211118211456054"></p><ul><li>结合腾讯开发测试组件，自动化开发测试部署流程中重复的工作量，把传统开发过程中的手动步骤自动化，大量节省时间，缩短迭代周期</li></ul><h6 id="2-1-3-保障应用7-24小时高可靠运行"><a href="#2-1-3-保障应用7-24小时高可靠运行" class="headerlink" title="2.1.3 保障应用7*24小时高可靠运行"></a>2.1.3 保障应用7*24小时高可靠运行</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211544133.png" alt="image-20211118211544133"></p><ul><li>在发布部署过程中基于部署组维度进行服务路由，完成不停服的灰度发布，同时可以实时更新配置，不需要重启应用，可靠的保证服务的高可用</li></ul><h6 id="2-1-4-开源微服务技术完美兼容"><a href="#2-1-4-开源微服务技术完美兼容" class="headerlink" title="2.1.4 开源微服务技术完美兼容"></a>2.1.4 开源微服务技术完美兼容</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211632649.png" alt="image-20211118211632649"></p><ul><li>完美的整合开源微服务框架技术，拥抱Spring Cloud ，Dubbo，Service Mesh应用；同时支持虚拟机，容器应用。</li></ul><h6 id="2-1-5-供跨语言，跨物理资源的通道"><a href="#2-1-5-供跨语言，跨物理资源的通道" class="headerlink" title="2.1.5 供跨语言，跨物理资源的通道"></a>2.1.5 供跨语言，跨物理资源的通道</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211734034.png" alt="image-20211118211734034"></p><ul><li>供跨语言，跨物理资源的通道，打通spring cloud和service mesh 互访</li></ul><h6 id="2-1-6-微服务中的定位问题"><a href="#2-1-6-微服务中的定位问题" class="headerlink" title="2.1.6 微服务中的定位问题"></a>2.1.6 微服务中的定位问题</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211829287.png" alt="image-20211118211829287"></p><ul><li>微服务中的问题定位随着微服务数量的上升困难也随之上升。</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118211923188.png" alt="image-20211118211923188"></p><ul><li>TSF提供专业的跟踪排障流水线，快速定位问题</li></ul><h6 id="2-1-7-持续做各行业的技术发动机"><a href="#2-1-7-持续做各行业的技术发动机" class="headerlink" title="2.1.7 持续做各行业的技术发动机"></a>2.1.7 持续做各行业的技术发动机</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118212006814.png" alt="image-20211118212006814"></p><h4 id="第三章-TSF的应用场景"><a href="#第三章-TSF的应用场景" class="headerlink" title="第三章 TSF的应用场景"></a>第三章 TSF的应用场景</h4><h5 id="3-1-TSF的应用场景"><a href="#3-1-TSF的应用场景" class="headerlink" title="3.1 TSF的应用场景"></a>3.1 TSF的应用场景</h5><p>TSF的三大典型的应用场景。</p><ul><li>场景1：构建分布式服务系统</li><li>场景2：应用的发布与管理</li><li>场景3：可视化数据运营</li></ul><h6 id="3-1-1-场景1：构建分布式服务系统"><a href="#3-1-1-场景1：构建分布式服务系统" class="headerlink" title="3.1.1 场景1：构建分布式服务系统"></a>3.1.1 场景1：构建分布式服务系统</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118212202312.png" alt="image-20211118212202312"></p><ul><li>单体应用转变为分布式系统后，实现系统间的可靠调用是关键问题之一，涉及到路由管理，序列化协议等技术细节。</li><li>TSF 提供了RESTful 调用方式和自研的高性能RPC 框架，能够构建高可用、高性能的分布式系统，TSF 系统地考虑了分布式服务发现、路由管理、安全、负载均衡等细节问题。同时TSF 将在未来打通消息队列、API Gateway 等服务，满足用户多样化的需求。</li></ul><h6 id="3-1-2-场景2：应用的发布与管理"><a href="#3-1-2-场景2：应用的发布与管理" class="headerlink" title="3.1.2 场景2：应用的发布与管理"></a>3.1.2 场景2：应用的发布与管理</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118212330840.png" alt="image-20211118212330840"></p><ul><li>相对于传统的应用发布需要运维人员登录到每一台服务器进行发布和部署，TSF 针对分布式系统的应用发布和管理，提供了简单易用的可视化控制台。用户通过控制台可以发布应用，包括创建、部署、启动应用，也支持查看应用的部署状态。除此之外，用户可以通过控制台管理应用，包括回滚应用、扩容、缩容和删除应用。</li></ul><h6 id="3-1-3-场景3：可视化数据运营"><a href="#3-1-3-场景3：可视化数据运营" class="headerlink" title="3.1.3 场景3：可视化数据运营"></a>3.1.3 场景3：可视化数据运营</h6><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118212432583.png" alt="image-20211118212432583"></p><ul><li>通过对日志埋点的收集和分析，可以得到一次请求在各个服务间的调用链关系，有助于梳理应用的请求入口与服务的调用来源、依赖关系。当遇到请求耗时较长的情况，可以通过调用链分析调用瓶颈，快速定位异常。</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li>TSF具备的功能有哪些？<ol><li>提供完善的微服务治理能力</li><li>提供一站式的应用生命周期管理，灵活的资源管理调配能力</li><li>全面的数据化运营能力</li><li>分布式配置</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人建站博客框架Hexo设置优化胎教级教程</title>
    <link href="/2021/11/11/%E4%B8%AA%E4%BA%BA%E5%BB%BA%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6Hexo%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E8%83%8E%E6%95%99%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2021/11/11/%E4%B8%AA%E4%BA%BA%E5%BB%BA%E7%AB%99%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6Hexo%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E8%83%8E%E6%95%99%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ul><li>系统：win10</li><li>需要的软件：node.js 、 git、gitbook、PicGo、Typora、Snipaste</li><li>网站： github、gitee</li></ul><h4 id="二、安装Hexo博客框架建站（本地）"><a href="#二、安装Hexo博客框架建站（本地）" class="headerlink" title="二、安装Hexo博客框架建站（本地）"></a>二、安装Hexo博客框架建站（本地）</h4><h5 id="2-1、安装前提"><a href="#2-1、安装前提" class="headerlink" title="2.1、安装前提"></a>2.1、安装前提</h5><h6 id="2-1-1、安装node-js"><a href="#2-1-1、安装node-js" class="headerlink" title="2.1.1、安装node.js"></a>2.1.1、安装node.js</h6><p>菜鸟教程详细安装步骤：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><h6 id="2-1-2、安装git"><a href="#2-1-2、安装git" class="headerlink" title="2.1.2、安装git"></a>2.1.2、安装git</h6><p>菜鸟教程详细安装步骤：<a href="https://www.runoob.com/git/git-install-setup.html">https://www.runoob.com/git/git-install-setup.html</a></p><h5 id="2-2、安装Hexo"><a href="#2-2、安装Hexo" class="headerlink" title="2.2、安装Hexo"></a>2.2、安装Hexo</h5><p>在本地磁盘创建一个文件夹用来存储博客，我这边是在D盘创建了MyBlog的文件夹。</p><p>进入MyBlog文件夹，右键选择Git Bash Here。在命令行工具输入以下命令安装hexo。<img src="https://gitee.com/divemaven/git-project/raw/master/202109261634217.png" alt="image-20210926163420085"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install hexo-cli -g//全局安装命令<br></code></pre></td></tr></table></figure><h5 id="2-3、建站"><a href="#2-3、建站" class="headerlink" title="2.3、建站"></a>2.3、建站</h5><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo init//对MyBlog文件夹进行初始化<br>npm install//安装项目依赖<br>hexo server     //本地服务器打开项目，查看博客<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261655658.png" alt="image-20210926165558592"></p><p><strong>登录 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果，如果打开网站之后可以看到以下页面说明你已经完成了建站的基本操作。</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261657458.png" alt="image-20210926165719163"></p><p><strong>新建完成后，指定文件夹的目录如下：</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;hexo generate&quot;</span>,<br>    <span class="hljs-attr">&quot;clean&quot;</span>: <span class="hljs-string">&quot;hexo clean&quot;</span>,<br>    <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;hexo deploy&quot;</span>,<br>    <span class="hljs-attr">&quot;server&quot;</span>: <span class="hljs-string">&quot;hexo server&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;5.4.0&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^4.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;hexo-theme-landscape&quot;</span>: <span class="hljs-string">&quot;^0.0.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>scaffolds</strong></p><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong></p><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong></p><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h4 id="三、将博客部署到-Github-Pages-上（线上）"><a href="#三、将博客部署到-Github-Pages-上（线上）" class="headerlink" title="三、将博客部署到 Github Pages 上（线上）"></a>三、将博客部署到 Github Pages 上（线上）</h4><h5 id="3-1、注册github"><a href="#3-1、注册github" class="headerlink" title="3.1、注册github"></a>3.1、注册github</h5><p>github官网：<a href="https://github.com/">https://github.com/</a></p><h5 id="3-2、创建项目代码库"><a href="#3-2、创建项目代码库" class="headerlink" title="3.2、创建项目代码库"></a>3.2、创建项目代码库</h5><p><strong>注意名称一定是<code>your_username.github.io</code>这样的格式。</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261729392.png" alt="image-20210926172949213"></p><h5 id="3-3、-配置-SSH-密钥"><a href="#3-3、-配置-SSH-密钥" class="headerlink" title="3.3、 配置 SSH 密钥"></a>3.3、 配置 SSH 密钥</h5><p>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，</p><h6 id="3-3-1、-使用Git生成-SSH-密钥"><a href="#3-3-1、-使用Git生成-SSH-密钥" class="headerlink" title="3.3.1、 使用Git生成 SSH 密钥"></a>3.3.1、 使用Git生成 SSH 密钥</h6><p>在存放博客资料的文件夹（D\MyBlog）右键选择 Git Bash Here 输入以下命令生成SSH密钥：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ssh-keygen -t rsa -C &quot;your email@example.com&quot;     //你注册github的邮箱地址<br></code></pre></td></tr></table></figure><p> <img src="https://gitee.com/divemaven/git-project/raw/master/202109261748673.png" alt="image-20210926174827595"></p><p>运行以下命令，将公钥的内容复制到系统粘贴板上</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clip &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>或者使用Git GUI here查看SSH key</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261800725.png" alt="image-20210926180011638"></p><h6 id="3-3-2、-Github-配置SSH-密钥"><a href="#3-3-2、-Github-配置SSH-密钥" class="headerlink" title="3.3.2、 Github 配置SSH 密钥"></a>3.3.2、 Github 配置SSH 密钥</h6><p>登陆 GitHub，进入 Settings；点击 SSH and GPG Keys； 选择 New SSH key：粘贴密钥：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261755187.png" alt="image-20210926175547005"></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109261803881.png" alt="image-20210926180317770"></p><h6 id="3-3-3-、测试"><a href="#3-3-3-、测试" class="headerlink" title="3.3.3 、测试"></a>3.3.3 、<strong>测试</strong></h6><p>输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ssh -T git@github.com <br></code></pre></td></tr></table></figure><p>注意：<a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>不要做任何更改！执行命令后显示successfully，表明连接成功。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110151454584.png" alt="image-20211015145353488"></p><h6 id="3-3-4、配置-Git-个人信息"><a href="#3-3-4、配置-Git-个人信息" class="headerlink" title="3.3.4、配置 Git 个人信息"></a>3.3.4、配置 Git 个人信息</h6><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">git config --global user.name &quot;keepdive&quot; //你注册github用户名<br>git config --global user.email  &quot;xxxx@gmail.com&quot;//填写你的github注册邮箱<br><br></code></pre></td></tr></table></figure><h5 id="3-4、修改-config-yml配置文件"><a href="#3-4、修改-config-yml配置文件" class="headerlink" title="3.4、修改_config.yml配置文件"></a>3.4、修改_config.yml配置文件</h5><p>登录Github查看你的仓库地址。选择你之前创建的仓库，拷贝仓库地址。需要在_config.yml文件中配置仓库地址。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271016056.png" alt="image-20210927101634951"></p><p>打开你创建的 MyBlog、 文件夹（如：D\Myblog），右键用记事本（Notepad++或者VS code等都可以）打开该文件夹下的 _config.yml 配置文件。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109270948989.png" alt="image-20210927094837919"></p><p>按下图修改 _config.yml 文件并保存。注意yml格式的文件在标签后面要加个空格。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109270955179.png" alt="image-20210927095506129"></p><h5 id="3-5、部署博客到GitHub"><a href="#3-5、部署博客到GitHub" class="headerlink" title="3.5、部署博客到GitHub"></a>3.5、部署博客到GitHub</h5><p>安装github一键部署插件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install hexo-deployer-git --save  //安装部署插件<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109270943867.png" alt="image-20210927094311809"></p><p>在你博客的存储位置（D:\MyBlog）文件夹下分别执行以下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMD">hexo clean//清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>hexo g -d   //生成静态文件后立即部署网站<br></code></pre></td></tr></table></figure><p> 出现以下信息说明部署成功。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271120535.png" alt="image-20210927112007493"></p><p><strong>访问博客</strong></p><p>到目前为止，我们的线上博客就成功搭建了，其他人也能够访问我们的博客。</p><p>你的博客地址：https://你的用户名.github.io，比如我的是：<a href="https://keepdive.github.io/">https://keepdive.github.io</a> ,欢迎大家访问交流学习。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271049411.png" alt="image-20210927104943089"></p><h4 id="四、个性化博客"><a href="#四、个性化博客" class="headerlink" title="四、个性化博客"></a>四、个性化博客</h4><h5 id="4-1、为博客更换自己喜欢的主题"><a href="#4-1、为博客更换自己喜欢的主题" class="headerlink" title="4.1、为博客更换自己喜欢的主题"></a>4.1、为博客更换自己喜欢的主题</h5><p>博客也搭建好了，但是！！！默认的主题并不喜欢怎么办？现在，我们就来为自己的博客更换自己喜欢的主题</p><p><a href="https://hexo.io/themes/">点击此处</a>进入 Hexo 官网的主题专栏，我们可以看见有许多的主题供我们选择。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271059191.png" alt="image-20210927105901880"></p><p>我这里选择的是fluid主题，比较简洁。所以以此为例：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271059154.png" alt="image-20210927105955010"></p><p>选择之后会跳转到主题的<a href="https://github.com/fluid-dev/hexo-theme-fluid">GitHub仓库</a>。我们要做的就是获取主题的clone地址，把主题克隆到本地文件夹。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271112818.png" alt="image-20210927111225619"></p><p>打开 MyBlog文件夹下的 themes 目录（如：D:\MyBlog\themes），右键 Git Bash Here，输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">git clone https://github.com/fluid-dev/hexo-theme-fluid.git hexo-theme-fluid   //克隆主题到本地<br></code></pre></td></tr></table></figure><p>下载完成后即可在 themes 目录下生成 hexo-theme-fluid 文件夹。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271130478.png" alt="image-20210927113022426"></p><p>然后退回到D:\MyBlog文件夹，修改_config.yml文件。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109270948989.png" alt="image-20210927094837919"></p><p>修改标题、语言和主题。</p><p>找到关键字 title， 修改参数为KeepDive（修改成你想改的名字）。</p><p>找到关键字 language， 修改参数为zh-CN。</p><p>找到关键字 theme， 修改参数为hexo-theme-fluid。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271141503.png" alt="image-20210927114106448"></p><p>返回D:\MyBlog目录，右键 Git Bash Here ，输入以下命令开始本地部署主题：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMD">hexo g  //生成静态文件。<br>hexo s//启动服务器。默认情况下，访问网址为： http://localhost:<span class="hljs-number">4000</span>/。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271147408.png" alt="image-20210927114734339"></p><p>此时打开浏览器，访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可看见我们的主题已经更换了，如果感觉效果满意，我们就可以把它部署到Github上了。部署到GitHub可能会有延迟，先在本地看一下。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271148834.png" alt="image-20210927114809490"></p><p>部署到GitHub上，打开地址<a href="https://keepdive.github.io/">KeepDive.github.io</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271426029.png" alt="image-20210927142615813"></p><p>此时访问自己的博客即可看见更换后的主题，</p><p>但我们仍然需要对主题的相关配置进行修改，比如网站标题，图标等等，</p><p>Hexo 中有两份主要的配置文件，名称都是 _config.yml ，它们均是用于站点配置使用的。</p><p>其中，一份位于站点根目录下（比如我的：D:\MyBlog\_config.yml），主要包含 Hexo 本身整站的配置；</p><p>另一份位于主题目录下（比如我的：D:\MyBlog\themes\hexo-theme-fluid\_config.yml），</p><p>这份配置由主题作者提供，主要用于配置主题相关的选项，一般 _config.yml 文件里都有相关注释，按需修改即可。</p><p>更多关于主题配置，请查看<a href="https://hexo.fluid-dev.com/docs/guide/">fluit主题配置指南</a>。</p><h5 id="4-2、为博客配置自定义域名"><a href="#4-2、为博客配置自定义域名" class="headerlink" title="4.2、为博客配置自定义域名"></a>4.2、为博客配置自定义域名</h5><h6 id="4-2-1、购买域名"><a href="#4-2-1、购买域名" class="headerlink" title="4.2.1、购买域名"></a>4.2.1、购买域名</h6><p>首先去域名注册商，像阿里云或者腾讯云之类的域名注册商处，注册域名，新客一般都有优惠，</p><p>例如像腾讯云的，目前新客户域名只要1元<a href="https://cloud.tencent.com/act/domainsales?from=dnspodqcloud">腾讯云域名</a>。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271449627.png" alt="image-20210927144655429"></p><h6 id="4-2-2、域名解析"><a href="#4-2-2、域名解析" class="headerlink" title="4.2.2、域名解析"></a>4.2.2、域名解析</h6><p>购买域名后要做域名解析，这里以腾讯云为例。<a href="!%5B%5D(https://gitee.com/divemaven/git-project/raw/master/202109271449627.png)">登录DNS解析控制台</a>,如果实在不懂含义，<strong>主机类型</strong>和<strong>记录类型</strong>就照抄，但是记录值，得填你自己的域名，就是你部署博客之后，在浏览器输入域名可以正常访问的域名，不用带http。</p><p>注意：这里的解析时间是600秒，所以需要10分钟之后才会生效，请耐心等待一下。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271455864.png" alt="image-20210927145513663"></p><h6 id="4-2-3、去GitHub的仓库配置自定义域名"><a href="#4-2-3、去GitHub的仓库配置自定义域名" class="headerlink" title="4.2.3、去GitHub的仓库配置自定义域名"></a>4.2.3、去GitHub的仓库配置自定义域名</h6><p>按下图操作配置。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271504259.png" alt="image-20210927150411080"></p><p>保存成功后的样子。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271507798.png" alt="image-20210927150747644"></p><h6 id="4-2-4、解决自定义域名，每次发版都需要重新配置的问题。"><a href="#4-2-4、解决自定义域名，每次发版都需要重新配置的问题。" class="headerlink" title="4.2.4、解决自定义域名，每次发版都需要重新配置的问题。"></a>4.2.4、解决自定义域名，每次发版都需要重新配置的问题。</h6><p>截止目前，自定义域名是配好了。</p><p><strong>但是有个问题</strong>：</p><p>hexo 每次发布后需要手动在 github page 的 setting 里重新设置自定义域名。</p><p><strong>解决方法：</strong></p><p>在博客目录下的source文件夹（D:\MyBlog\source）新增一个CNAME文件就可以了。在CNAME新增内容，把你在GitHub Pages配好的那个域名填进去。例如我的就是把blog.keepdive.com填进去。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271516954.png" alt="image-20210927151613870"></p><p>执行以下命令，重新部署博客到GitHub Pages.</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMD">hexo clean//清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>hexo g -d   //生成静态文件后立即部署网站<br></code></pre></td></tr></table></figure><p><strong>使用自定义域名访问博客</strong></p><p>在浏览器输入自定义域名，访问博客。比如我的是：<a href="https://blog.keepdive.com/">https://blog.keepdive.com/</a> ,欢迎大家访问交流学习。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271526051.png" alt="image-20210927152601729"></p><h5 id="4-3、为博客配置图床（gitee）"><a href="#4-3、为博客配置图床（gitee）" class="headerlink" title="4.3、为博客配置图床（gitee）"></a>4.3、为博客配置图床（gitee）</h5><h6 id="4-3-1、注册gitee"><a href="#4-3-1、注册gitee" class="headerlink" title="4.3.1、注册gitee"></a>4.3.1、注册gitee</h6><p>gitee官网：<a href="https://gitee.com/">https://gitee.com/</a></p><p>为什么不推荐GitHub呢？</p><p>因为通过GitHub搭建的图床，虽然能正常上传，但是在markdown中无法正常加载图片，不太适合我们作为写作的图床，也可能有对应的解决方案，只是我不知道而已。主要原因是它存储的那台服务器，在国内被墙了，无法解析。</p><p>gitee和github本质上是一样的，都是创建仓库，用来保存数据。</p><h6 id="4-3-2、创建图床仓库"><a href="#4-3-2、创建图床仓库" class="headerlink" title="4.3.2、创建图床仓库"></a>4.3.2、创建图床仓库</h6><p>进入gitee首页后，点击+号创建图床仓库。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271614015.png" alt="image-20210927161422839"><br>出现如下图的界面，项目才创建完成了，一定要注意哦！</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271616887.png" alt="image-20210927161650725"></p><h6 id="4-3-3、设置私人令牌"><a href="#4-3-3、设置私人令牌" class="headerlink" title="4.3.3、设置私人令牌"></a>4.3.3、设置私人令牌</h6><p>按下图中的步骤操作</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271627653.png" alt="image-20210927162702485"></p><p><strong>得到私人令牌（Token）</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271629014.png" alt="image-20210927162948945"></p><p>到此，码云图床相关的配置已经设置完成，记住私人令牌，<strong>请务必保存好此私人令牌，关闭之后，将不会再显示，也无法查看</strong>。</p><h6 id="4-3-4、下载和配置PicGo图床"><a href="#4-3-4、下载和配置PicGo图床" class="headerlink" title="4.3.4、下载和配置PicGo图床"></a>4.3.4、下载和配置PicGo图床</h6><p>一款功能非常强大的图床的工具，支持<code>SM.MS</code>、<code>腾讯COS</code>、<code>GitHub图床</code>、<code>七牛云图床</code>、<code>Imgur图床</code>、<code>阿里云OSS</code>、<code>又拍云图床</code>、<code>gitee</code>等多种图床平台；</p><p>PicGo默认使用的是SMMS图床：<a href="https://sm.ms/">https://sm.ms/</a> ；如果你没有配置好上面的github图床或者gitee图床，且图片也并不那么重要且可以公开，也可以直接使用默认的SMMS图床来管理图片即可。</p><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p><strong>特点</strong></p><p>要说特点，PicGO<strong>最大的特点是，可以和Typora结合使用</strong>，配置好关联之后，Typora写文章时，如果需要穿插图片，只需要将图片复制粘贴到Typora的编辑区域，就自动通过PicGo上传到指定图床，得到外网能访问的URL并展示；如果没有网络的情况下，也能通过PicGo暂存在本地，等有网络的时候，再次进行上传即可。关联配置后面会专门讲解。</p><p><strong>PicGo配置gitee图床</strong></p><p>安装插件</p><p>默认情况下PicGo是不支持gitee的，所以需要第三方插件来支持。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271635246.png" alt="image-20210927163531159"></p><p><strong>配置gitee图床地址及私人令牌</strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271642078.png" alt="image-20210927164218993"></p><h6 id="4-3-5、Typora关联PicGo"><a href="#4-3-5、Typora关联PicGo" class="headerlink" title="4.3.5、Typora关联PicGo"></a>4.3.5、Typora关联PicGo</h6><p><strong>安装Typora</strong></p><p>Markdown教程及Typora安装：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p><p><strong>安装Snipaste</strong></p><p>Snipaste官网：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></p><p><strong>配置Typora</strong></p><p>按以下步骤配置Typora</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271704100.png" alt="image-20210927170418947"></p><p>如果提示成功，说明关联就已经正常了</p><p><strong>整体测试</strong></p><p>经过上面的一系列配置之后，就可以使用Markdown开始写文章了；图片这些，截图粘贴之后，就自动通过PicGo上传到了远端图床，效果如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271707248.png" alt="image-20210927170752183"></p><p>至此，我们就可以专心写文章了，再也不用花精力去处理图片，排版这些琐碎、耗时的工作。</p><h5 id="4-4、为博客配置gitbook"><a href="#4-4、为博客配置gitbook" class="headerlink" title="4.4、为博客配置gitbook"></a>4.4、为博客配置gitbook</h5><h6 id="4-4-1、什么是gitbook？"><a href="#4-4-1、什么是gitbook？" class="headerlink" title="4.4.1、什么是gitbook？"></a>4.4.1、什么是gitbook？</h6><p><strong>GitBook 是一个基于 <a href="https://baike.baidu.com/item/Node.js">Node.js</a> 的命令行工具，可使用 <a href="https://baike.baidu.com/item/Github">Github</a>/<a href="https://baike.baidu.com/item/Git/12647237">Git</a> 和 <a href="https://baike.baidu.com/item/Markdown">Markdown</a>（或AsciiDoc） 来制作精美的电子书，GitBook 并非关于 Git 的教程。</strong></p><p><strong>GitBook支持输出多种文档格式：</strong></p><ul><li><p>静态站点：GitBook默认输出该种格式，生成的静态站点可直接托管搭载Github Pages服务上；</p></li><li><p><a href="https://baike.baidu.com/item/PDF">PDF</a>：需要安装gitbook-pdf依赖；</p></li><li><p><a href="https://baike.baidu.com/item/eBook">eBook</a>：需要安装ebook-convert；</p></li><li><p>单<a href="https://baike.baidu.com/item/HTML">HTML</a>网页：支持将内容输出为单页的HTML，不过一般用在将<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6%E6%A0%BC%E5%BC%8F/5219840">电子书格式</a>转换为PDF或eBook的中间过程；</p></li><li><p><a href="https://baike.baidu.com/item/JSON">JSON</a>：一般用于电子书的调试或元数据提取。</p></li></ul><p>使用GitBook制作电子书，必备两个文件：<em><strong>README.md</strong></em>和<em><strong>SUMMARY.md</strong></em></p><h6 id="4-4-2、安装gitbook"><a href="#4-4-2、安装gitbook" class="headerlink" title="4.4.2、安装gitbook"></a>4.4.2、安装gitbook</h6><p><strong>要求</strong></p><p>安装 GitBook 简单明了。您的系统只需要满足以下两个要求：</p><ul><li>NodeJS（推荐v4.0.0及以上）</li><li>Windows、Linux、Unix 或 Mac OS X</li></ul><p><strong>使用 NPM 安装</strong></p><p>安装 GitBook 的最佳方式是通过<strong>NPM</strong>。在终端提示符下，只需运行以下命令即可安装 GitBook</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">npm install gitbook-cli -g<br></code></pre></td></tr></table></figure><p>安装完成之后，你可以使用下面的命令来检验是否安装成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">gitbook -V<br></code></pre></td></tr></table></figure><p><strong>问题</strong></p><p>1、一直卡在Installing GitBook 3.2.3的页面。</p><p>2、出现安装gitbook报错，提示cb.apply is not a function。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110151625069.png" alt="image-20211015162504007"></p><p><strong>原因</strong></p><p>1、由于安装过程默认使用国外镜像导致。</p><p>2、cb.apply is not a function，主要是gitbook-cli<code>引用了</code>旧版的graceful-fs。Node.JS版本过高。</p><p><strong>解决方法</strong></p><p>1、执行以下命令，设置镜像源为淘宝。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">npm config <span class="hljs-built_in">set</span> registry=http://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>执行以下命令，查看是否修改成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">npm config get registry<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110151649028.png" alt="image-20211015164939983"></p><p>2、node.js版本降级,<strong>下载NVM for Windows</strong>.(切记 nvm的安装路径 ：不要有汉字，不要有空格。不，应该要有良好的习惯那就是)</p><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110191514832.png" alt="image-20211019151424752"></p><p>3、安装完成后，使用nvm下载低版本的nodejs。我这里下的是10.23.1版本。执行以下命令安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CDM">nvm install 10.23.1<br></code></pre></td></tr></table></figure><p>4、执行以下命令，切换nodejs版本。（<strong>使用管理员权限，不然会报错。</strong>）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> use <span class="hljs-number">10</span>.<span class="hljs-number">23</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110191517672.png" alt="image-20211019151742623"></p><p>再次执行<code>gitbook -V</code>，显示版本正常。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">gitbook -V<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202110191544509.png" alt="image-20211019154447453"></p><h6 id="4-4-3、创建一本电子书"><a href="#4-4-3、创建一本电子书" class="headerlink" title="4.4.3、创建一本电子书"></a>4.4.3、创建一本电子书</h6><p><strong>GitBook 准备工作做好之后，我们进入一个你要写书的目录，输入如下命令。</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">gitbook init<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111021428683.png" alt="image-20211102142820562"></p><p>可以看到他会创建 README.md 和 SUMMARY.md 这两个文件，README.md 应该不陌生，就是说明文档，而 SUMMARY.md 其实就是书的章节目录。</p><p>接下来，我们输入 <code>gitbook serve</code> 命令，然后在浏览器地址栏中输入 <code>http://localhost:4000</code> 便可预览书籍。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111021431042.png" alt="image-20211102143133969"></p><p>运行该命令后会在书籍的文件夹中生成一个 <code>_book</code> 文件夹, 里面的内容即为生成的 html 文件，我们可以使用下面命令来生成网页而不开启服务器。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">gitbook build<br></code></pre></td></tr></table></figure><h6 id="4-4-4、目录结构"><a href="#4-4-4、目录结构" class="headerlink" title="4.4.4、目录结构"></a>4.4.4、目录结构</h6><p>GitBook 基本的目录结构如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby">.<br>├── book.json<br>├── README.md<br>├── SUMMARY.md<br>├── chapter-<span class="hljs-number">1</span>/<br><span class="hljs-params">|   ├── README.md</span><br><span class="hljs-params">|</span>   └── something.md<br>└── chapter-<span class="hljs-number">2</span>/<br>    ├── README.md<br>    └── something.md<br></code></pre></td></tr></table></figure><p>下面我们主要来讲讲 book.json 和 SUMMARY.md 文件。</p><h6 id="book-json"><a href="#book-json" class="headerlink" title="book.json"></a>book.json</h6><p>该文件主要用来存放配置信息，我先放出我的配置文件。</p><h4 id="五、问题解答"><a href="#五、问题解答" class="headerlink" title="五、问题解答"></a>五、问题解答</h4><p>配置过程中，有任何问题都可以添加我微信交流，我帮你解决。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202109271723195.png" alt="image-20210927172320125"></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA开发环境配置</title>
    <link href="/2021/11/09/IDEA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/11/09/IDEA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA开发环境基本配置"><a href="#IDEA开发环境基本配置" class="headerlink" title="IDEA开发环境基本配置"></a>IDEA开发环境基本配置</h3><h4 id="IDEA介绍"><a href="#IDEA介绍" class="headerlink" title="IDEA介绍"></a>IDEA介绍</h4><p>IntelliJ IDEA（简称 IDEA），是 Java 语言开发的集成环境，IDEA 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具（Git、SVN、GitHub 等）、JUnit、CVS 整合、代码分析和创新的 GUI 设计等方面的功能都值得称道。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以：</p><ul><li>掌握IDEA字体设置</li><li>掌握IDEA编码设置</li><li>掌握IDEA配置Maven</li><li>掌握IDEA配置JDK</li><li>选择合适的IDEA插件提升开发效率</li><li>开启IDEA之旅</li></ul><h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><ul><li>IDEA版本：IntelliJ IDEA 2021.2.1(UItimate Edition)</li><li>JDK：1.8</li><li>Maven：3.3.9</li></ul><h4 id="一、字体设置"><a href="#一、字体设置" class="headerlink" title="一、字体设置"></a>一、字体设置</h4><p><strong>字体和字体大小根据个人喜好选择。</strong></p><h5 id="1-1-界面字体设置"><a href="#1-1-界面字体设置" class="headerlink" title="1.1 界面字体设置"></a>1.1 界面字体设置</h5><p>File -&gt; Settings -&gt; Appearance &amp; Behavior -&gt; Appearance</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091155800.png" alt="image-20211109115525655"></p><h5 id="1-2-程序字体设置"><a href="#1-2-程序字体设置" class="headerlink" title="1.2 程序字体设置"></a>1.2 程序字体设置</h5><p>File -&gt; Settings -&gt;Editor  -&gt; Font</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091201305.png" alt="image-20211109120139120"></p><h4 id="二、编码设置"><a href="#二、编码设置" class="headerlink" title="二、编码设置"></a>二、编码设置</h4><p><strong>任何开发统一编码都是第一步，为了解决中文编码，这里统一设为UTF-8。</strong></p><h5 id="2-1-全局编码设置"><a href="#2-1-全局编码设置" class="headerlink" title="2.1 全局编码设置"></a>2.1 全局编码设置</h5><p>File -&gt; Settings -&gt; Editor  -&gt; File Encodings</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091209495.png" alt="image-20211109120943329"></p><h5 id="2-2-文件编码设置"><a href="#2-2-文件编码设置" class="headerlink" title="2.2 文件编码设置"></a>2.2 文件编码设置</h5><p>打开需要设置编码的文件</p><p>在右下角进行设置</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091213298.png" alt="image-20211109121329236"></p><h4 id="三、JDK设置"><a href="#三、JDK设置" class="headerlink" title="三、JDK设置"></a>三、JDK设置</h4><p>File -&gt;Project Structure -&gt; Project Settings -&gt; Project</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091507073.png" alt="image-20211109150744909"></p><h4 id="四、Maven设置"><a href="#四、Maven设置" class="headerlink" title="四、Maven设置"></a>四、Maven设置</h4><p>File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091504134.png" alt="image-20211109150446946"></p><h4 id="五、插件安装"><a href="#五、插件安装" class="headerlink" title="五、插件安装"></a>五、插件安装</h4><p>所有插件都是在 File -&gt; Settings -&gt; plugins里进行搜索安装。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091533761.png" alt="image-20211109153332583"></p><h5 id="5-1-Alibaba-Java-Coding-Guidelines"><a href="#5-1-Alibaba-Java-Coding-Guidelines" class="headerlink" title="5.1 Alibaba Java Coding Guidelines"></a>5.1 <strong>Alibaba Java Coding Guidelines</strong></h5><p>阿里巴巴的编码规约检查插件</p><p>检查你的编码习惯，让你更规范</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091536017.png" alt="image-20211109153624892"></p><h5 id="5-2-Codota"><a href="#5-2-Codota" class="headerlink" title="5.2 Codota"></a>5.2 <strong>Codota</strong></h5><p>代码提示工具，扫描你的代码后，根据你的敲击完美提示</p><p>Codota基于数百万个开源Java程序和您的上下文来完成代码行，从而帮助您以更少的错误更快地进行编码。</p><p>网站 <a href="https://www.codota.com/">https://www.codota.com/</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091537550.png" alt="image-20211109153731383"></p><h5 id="5-3-RESTfultoolkit"><a href="#5-3-RESTfultoolkit" class="headerlink" title="5.3 RESTfultoolkit"></a>5.3 <strong>RESTfultoolkit</strong></h5><p>一套 RESTful 服务开发辅助工具集。</p><ol><li>根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li><li>提供了一个 Services tree 的显示窗口;</li><li>一个简单的 http 请求工具;</li><li>在请求方法上添加了有用功能: 复制生成 URL;,复制方法参数…</li><li>其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。</li></ol><p>支持 Spring 体系 (Spring MVC / Spring Boot)</p><p>支持 JAX-RS</p><p>支持 Java 和 Kotlin 语言。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091546827.png" alt="image-20211109154606698"></p><h5 id="5-4-GenerateAllSetter"><a href="#5-4-GenerateAllSetter" class="headerlink" title="5.4 GenerateAllSetter"></a>5.4 <strong>GenerateAllSetter</strong></h5><p>快速生成get set</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091548315.png" alt="image-20211109154800176"></p><h5 id="5-5-MyBatisCodeHelperPro-收费"><a href="#5-5-MyBatisCodeHelperPro-收费" class="headerlink" title="5.5  MyBatisCodeHelperPro(收费)"></a>5.5  MyBatisCodeHelperPro(收费)</h5><p>最好的Mybatis代码提示，完整支持Mybatis动态sql代码提示，代码检测，写sql几乎所有地方都有代码提示</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091556570.png" alt="image-20211109155629419"></p><h5 id="5-6-Json-Parser"><a href="#5-6-Json-Parser" class="headerlink" title="5.6 **Json Parser **"></a>5.6 **Json Parser **</h5><p>厌倦了打开浏览器来格式化和验证JSON？为什么不安装JSON Parser并在具有脱机支持的IDE内进行呢？JSON Parser是用于验证和格式化JSON字符串的轻量级插件。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091558358.png" alt="image-20211109155855221"></p><h5 id="5-7-MyBatis-Log-Free-免费版"><a href="#5-7-MyBatis-Log-Free-免费版" class="headerlink" title="5.7 MyBatis Log  Free(免费版)"></a>5.7 <strong>MyBatis Log  Free</strong>(免费版)</h5><p>根据执行sql 替换掉 ？显示完整 sql, 直接复制粘贴到数据库就可以执行</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091559718.png" alt="image-20211109155955581"></p><h5 id="5-8-Translation"><a href="#5-8-Translation" class="headerlink" title="5.8 Translation"></a>5.8 <strong>Translation</strong></h5><p>翻译插件，灰常牛逼。翻译中文，给接口起名字就不用费劲啦！</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091602209.png" alt="image-20211109160234067"></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、Spring Cloud基础入门</title>
    <link href="/2021/11/08/%E4%BA%8C%E3%80%81Spring-Cloud%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/08/%E4%BA%8C%E3%80%81Spring-Cloud%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="二、Spring-Cloud基础入门"><a href="#二、Spring-Cloud基础入门" class="headerlink" title="二、Spring Cloud基础入门"></a>二、Spring Cloud基础入门</h3><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以: </p><ul><li>了解Spring Boot概念和Spring Cloud概念 </li><li>掌握Spring Boot和Spring Cloud的区别 </li><li>了解Spring Cloud常用组件 </li><li>学会开发一个Spring Cloud程序 </li><li>了解服务间的通信方式</li></ul><h4 id="第一章-Spring-Boot的介绍"><a href="#第一章-Spring-Boot的介绍" class="headerlink" title="第一章  Spring Boot的介绍"></a>第一章  Spring Boot的介绍</h4><p>在明白了微服务是什么的基础上，我们接下来看一下到底什么是Spring Boot? Spring Boot跟微服务又有些什么联系？让我们带着这些问题进入Spring Boot的内容学习。</p><h5 id="1-1-什么是Spring-Boot"><a href="#1-1-什么是Spring-Boot" class="headerlink" title="1.1 什么是Spring Boot"></a>1.1 什么是Spring Boot</h5><ul><li><p>开发团队：是由Pivotal团队提供的全新框架。</p></li><li><p>设计目标：简化新Spring应用的初始搭建以及开发过程。</p><ul><li><p>Spring Boot框架使用了特定的方式来进行配置，使开发人员不再需要定义样板化的配置。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081719032.png" alt="image-20211108171933988"></p></li><li><p>简单来说：Spring Boot整合了许多优秀的框架，不需要用户手动的去写一堆xml配置 ，再进行配置。</p></li></ul></li><li><p> 首先我们看一下什么是Spring Boot。</p></li><li><p>Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p></li><li><p>Spring Boot相当于Java开发中使用的Maven。</p></li><li><p><strong>Spring Boot的四个核心：</strong></p><ol><li><strong>自动配置</strong></li><li> <strong>起步依赖</strong></li><li> <strong>命令行界面</strong></li><li> <strong>Actuator监控</strong></li></ol></li><li><p>Spring Boot将很多魔法带入了Spring应用程序的开发之中，其中最重要的是以下四个核心。</p><ul><li><p><strong>自动配置</strong>：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置，对于开发人员还需要添加相应jar包，不再需要复杂的xml配置就可以实现功能。</p></li><li><p><strong>起步依赖</strong>：告诉Spring Boot需要什么功能，它就能引入需要的库。开发人员不再需要把依赖一个个添加进来，只需要添加对应的starter包依赖就可以解决复杂的依赖问题。</p></li><li><p><strong>命令行界面</strong>：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建，可以在命令行界面快速构建应用。</p></li><li><p><strong>Actuator监控</strong>：让你能够深入运行中的Spring Boot应用程序，一探究竟。添加actuator依赖后，通过在actuator包中预定义好的url，可以很快速的获取应用的运行信息，比如通过 “/autoconfig”可以查看自动配置的使用情况，“/health” 查看应用健康指标，“/env” 查看所有环境变量。</p></li></ul></li></ul><h5 id="1-2-开发第一个Spring-Boot应用程序"><a href="#1-2-开发第一个Spring-Boot应用程序" class="headerlink" title="1.2 开发第一个Spring Boot应用程序"></a>1.2 开发第一个Spring Boot应用程序</h5><ul><li><p>开发的基本流程和步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081729025.png" alt="image-20211108172952981"></p></li><li><p>接下来我将带领大家开发第一个Spring Boot的应用程序</p></li></ul><h6 id="1-2-1-环境准备"><a href="#1-2-1-环境准备" class="headerlink" title="1.2.1 环境准备"></a>1.2.1 环境准备</h6><ul><li><p>环境准备：</p><ul><li><p>JDK1.8</p></li><li><p> Maven版本：3.3.9</p></li><li><p>修改setting配置为国内下载镜像</p></li><li><p>Maven编码过程中需要下载依赖，需要网络环境</p></li><li><p>Eclipse或者IDEA</p><ul><li>字符集编码：UTF-8</li></ul></li></ul></li><li><p>在真正开发Spring Boot项目之前我们要确保我们的环境是一致，以免中途发生一些意想不到的问题；</p><ul><li>首先我们是用的是jdk1.8版本，使用Eclipse或者IDEA作为开发工具（我们演示的使用采用 Eclipse Oxygen 作为开发工具），目前新版的开发工具中已经集成了Maven，我们只需要修 改Maven的Setting配置文件（主要是修改本地仓库位置，国内下载镜像）。</li><li>默认情况下Maven的下载地址为国外的站点，依赖包的下载非常缓慢。当然由于要下载相关的依赖包，所以需要有网络环境</li><li>使用Eclipse或者IDEA时建议大家把编码都改为UTF-8，以避免一些乱码问题。</li></ul></li></ul><h6 id="1-2-2创建Maven工程并添加依赖"><a href="#1-2-2创建Maven工程并添加依赖" class="headerlink" title="1.2.2创建Maven工程并添加依赖"></a>1.2.2创建Maven工程并添加依赖</h6><ul><li>步骤一：<ul><li>使用IDEA创建Maven项目工程<ul><li><p>file -&gt; new -&gt; project -&gt; Maven</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091641559.png" alt="image-20211109164143370"></p></li><li><p>详细信息<img src="https://gitee.com/divemaven/git-project/raw/master/202111091643315.png" alt="image-20211109164356217"></p></li></ul></li></ul></li></ul><ul><li>项目创建成功后结构如下图，图中的最后一个文件pom.xml就是maven的核心配置文件，后面我们大量的依赖配置都需要在这个配置文件中进行。<img src="https://gitee.com/divemaven/git-project/raw/master/202111091647471.png" alt="image-20211109164751372"></li></ul><ul><li><p>步骤二：</p><ul><li><p>修改项目根目录下的pom.xml配置文件，添加SpringBoot依赖</p></li><li><p>在pom.xml配置文件中的dependencies节点下添加依赖，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>在pom.xml配置文件中添加Spring Boot的依赖，这里我们统一Spring Boot的依赖版本为 1.5.11.RLEASE。</p></li></ul><h6 id="1-2-3-开发主程序（启动类）"><a href="#1-2-3-开发主程序（启动类）" class="headerlink" title="1.2.3 开发主程序（启动类）"></a>1.2.3 开发主程序（启动类）</h6><ul><li><p>步骤三：</p><ul><li>开发主程序：<ul><li>在src/main/java中新建包com.test</li><li>在com.test包中新建类FirstDemoApplication</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091759215.png" alt="image-20211109175944160"></p></li><li><p>在src/main/java中新建包，com.test（这里包的名字大家可以随便建，能识别即可）；</p></li><li><p>编写主程序：</p><ul><li><p>编写FirstDemoApplication 类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstDemoApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(FirstDemoApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>开发程序的启动类FirstDemoApplication ；此类主要用于Spring Boot应用程序的启动，程序的入口就是这里了；在运行FirstDemoApplication 类时会进入main方法的调用，然后再main方法中启动了SpringApplication；</p></li><li><p>此处注意一定要添加@SpringBootApplication注解</p></li><li><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstDemoApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(FirstDemoApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h6 id="1-2-4-开发Controller"><a href="#1-2-4-开发Controller" class="headerlink" title="1.2.4 开发Controller"></a>1.2.4 开发Controller</h6><ul><li><p>步骤四：</p><ul><li><p>在FirstDemoApplication 类项目包下新建HelloController类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>开发Controller程序，用于实现业务方法。</p></li><li><p> 详细代码如下：</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="1-2-5-启动主程序"><a href="#1-2-5-启动主程序" class="headerlink" title="1.2.5  启动主程序"></a>1.2.5  启动主程序</h6><ul><li><p>步骤五：</p><ul><li><p>运行FirstDemoApplication 类，控制台打印如下内容表示启动成功</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091838730.png" alt="image-20211109183820550"></p></li></ul></li><li><p>运行FirstDemoApplication 类；在IDEA中使用鼠标右键-》RUN ‘FirstDemoApplication ’就可以 启动SpringBoot应用程序。这里的基本配置，以及启动方法在后面会大量用到，所以大家一定要掌握。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091841057.png" alt="image-20211109184142951"></p></li></ul><h6 id="1-2-6-浏览器访问测试"><a href="#1-2-6-浏览器访问测试" class="headerlink" title="1.2.6 浏览器访问测试"></a>1.2.6 浏览器访问测试</h6><ul><li><p>步骤六：</p><ul><li><p>在浏览器中输入<a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 就可以看到我们写的第一个Spring Boot应用内容。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091843364.png" alt="image-20211109184341321"></p></li></ul></li></ul><h6 id="1-2-7-项目完整结构"><a href="#1-2-7-项目完整结构" class="headerlink" title="1.2.7  项目完整结构"></a>1.2.7  项目完整结构</h6><ul><li><p>项目完整截图如下：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111091845246.png" alt="image-20211109184510193"></p></li><li><p>项目的完整结构如上图，Spring Boot项目的创建跟普通maven项目创建是一致的，然后添加 Spring Boot依赖，启动类，业务Controller就完成了我们第一个Spring Boot项目的创建。步骤很简单，大家一定要掌握。</p></li></ul><h5 id="1-3-Spring-Boot的示例"><a href="#1-3-Spring-Boot的示例" class="headerlink" title="1.3 Spring Boot的示例"></a>1.3 Spring Boot的示例</h5><ul><li><p>接收客户端参数</p></li><li><p>Spring Boot配置文件</p></li><li><p>FirstDemo项目如何接收前端传递的参数呢？</p></li><li><p>我们都知道tomcat默认的端口是8080，如果我们8080端口被占用了，我们如何修改Spring  Boot项目的端口呢？</p></li><li><p>接下来我将以上面2个案例为大家解决参数接收，自动重启，配置文件中修改端口问题。</p></li><li><p>注意后面的2个案例都是以FirstDemo作为基础</p></li></ul><h6 id="1-3-1-接收客户端参数"><a href="#1-3-1-接收客户端参数" class="headerlink" title="1.3.1 接收客户端参数"></a>1.3.1 接收客户端参数</h6><ul><li>接收客户端参数：<ul><li>在FirstDemo项目中的HelloController类中新增一个处理前端参数的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果需要接受浏览器传递的参数，在使用Spring Boot项目我们很容易就可以解决这个问题；</p><ul><li>路径传参，如上面代码我们使用的是路径传参数，其中“{name}”就是参数；在 @RequestMapping中定义访问路径以及参数后，我们需要方法参数中添加 “@PathVariable String name”，这里注意“@PathVariable String name”中的name要 跟“@RequestMapping(“/hello/{name}”)”中的name一致。</li></ul></li><li><p>上面的代码演示了从浏览器接收参数并回显到浏览器界面。</p></li><li><p>浏览器访问测试：</p><ul><li>在浏览器中访问 <a href="http://localhost:8080/hello/keepdive%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:8080/hello/keepdive，显示如下图：</a></li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101100206.png" alt="image-20211110110025158"></p><ul><li>上面<a href="http://localhost:8080/hello/keepdive%E9%93%BE%E6%8E%A5%E4%B8%AD%E2%80%9Ckeepdive%E2%80%9D%E5%B0%B1%E6%98%AF%E5%8F%82%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E4%BA%86">http://localhost:8080/hello/keepdive链接中“keepdive”就是参数，所以在浏览器显示了</a> “hello keepdive”        </li></ul><h6 id="1-3-2-Spring-Boot配置文件"><a href="#1-3-2-Spring-Boot配置文件" class="headerlink" title="1.3.2  Spring Boot配置文件"></a>1.3.2  Spring Boot配置文件</h6><ul><li><p>SpringBoot配置文件默认可以放到以下目录中，可以实现自动读取：</p><ul><li><p>项目的resources目录下</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101117483.png" alt="image-20211110111709413"></p></li></ul></li><li><p>在介绍修改应用端口之前，我们先看一下Spring Boot应用的配置文件应该放在哪里？如上图位置。</p></li><li><p>如果tomcat默认的8080端口被占用，我们只需要在上面的任意一个配置文件中添加 “server.port: 要修改的端口号” 就可以修改Spring Boot应用的启动端口，当然这里也支持 properties配置文件，不过我们建议统一都使用yaml文件作为配置文件，其中yaml的具体语法可以参考腾讯云的<strong>YAML 格式介绍</strong>文档： <a href="https://cloud.tencent.com/document/product/649/17925%EF%BC%9B">https://cloud.tencent.com/document/product/649/17925；</a></p></li><li><p>如果要修改启动端口，我们只需要在上述配置路径下任意一个 application.yml配置文件中添加配置代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs YML"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure></li><li><p>添加配置代码后，重启应用，就可以通过8000端口访问应用了。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101124218.png" alt="image-20211110112404165"></p></li></ul><h4 id="第二章-Spring-Cloud的介绍"><a href="#第二章-Spring-Cloud的介绍" class="headerlink" title="第二章  Spring Cloud的介绍"></a>第二章  Spring Cloud的介绍</h4><p>在掌握了Spring Boot的基本使用后，接下来我们进入Spring Cloud的内容学习；</p><p>什么是Spring  Cloud？</p><p>Spring Boot和Spring Cloud又有什么关系呢？</p><p>带着这些问题我们继续Spring Cloud的内容学习。</p><h5 id="2-1-什么是Spring-Cloud"><a href="#2-1-什么是Spring-Cloud" class="headerlink" title="2.1  什么是Spring Cloud"></a>2.1  什么是Spring Cloud</h5><ul><li><p>什么是Spring Cloud？</p><ul><li>Spring Cloud是基于Spring Boot实现微服务的框架，包含多个子项目的整体方案。</li><li>与其他微服务框架的最明显区别是只能使用Java语言。</li></ul></li><li><p><strong>Spring Cloud的核心</strong>：</p><ul><li><p>服务的注册与发现</p><ul><li><p>服务提供者：是指服务的被调用方</p></li><li><p>服务消费者：是指服务的调用方</p></li></ul></li></ul></li><li><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）</p></li><li><p>Spring Cloud是基于Spring Boot 提供的一套微服务解决方案</p></li><li><p>Spring Cloud除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。</p></li><li><p>Spring CLoud利用Spring Boot的开发便利性巧妙的简化了分布式系统基础设施的开发，Spring  Cloud为开发人员提供了快速构建分布式系统的一些工具。</p></li><li><p><strong>Spring Cloud的核心是服务注册与发现</strong>，后面我们在使用整套Spring Cloud的功能时，都需要先把开发好的服务注册到服务注册中心。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101133316.png" alt="image-20211110113346246"></p></li><li><p>上图中就是Spring Cloud的基本组件架构图，从上图我们也可以看出来，Spring Cloud包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等。它们都可以用SpringBoot的开发风格做到一键启动和部署。</p></li></ul><h5 id="2-2-Spring-Boot和Spring-Cloud的区别"><a href="#2-2-Spring-Boot和Spring-Cloud的区别" class="headerlink" title="2.2  Spring Boot和Spring Cloud的区别"></a>2.2  Spring Boot和Spring Cloud的区别</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101134519.png" alt="image-20211110113448465"></p><p>上图是Spring官网的关于Spring Boot的介绍图，在了解了Spirng Cloud的基本概念后我们再看这幅图，相信通过这幅图大家应该能明白Spirng Boot和Spring Cloud的基本区别了。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101137419.png" alt="image-20211110113702359"></p><ul><li><p>Spring boot 是 Spring 的一套快速配置脚手架，可以基于spring boot 快速开发单个微服务； Spring Cloud是一个基于Spring Boot实现的云应用开发工具；</p></li><li><p>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；</p></li><li><p>Spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置， Spring Cloud很大的一部分是基于Spring boot来实现。</p></li><li><p>Spring boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring boot， 属于依赖的关系。</p></li></ul><h5 id="2-3-Spring-Cloud的常用组件"><a href="#2-3-Spring-Cloud的常用组件" class="headerlink" title="2.3  Spring Cloud的常用组件"></a>2.3  Spring Cloud的常用组件</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101141230.png" alt="image-20211110114127171"></p><ul><li><p>在介绍Spring Cloud 常用组价之前，首先要介绍一下Netflix ，Netflix 是一个很伟大的公司，在 Spring Cloud项目中占着重要的作用，Netflix公司提供了包括Eureka、Hystrix、Zuul、 Archaius等在内的很多组件，在微服务架构中至关重要，Spring在Netflix的基础上，封装了一系列的组件，命名为：Spring Cloud Eureka、Spring Cloud Hystrix、Spring Cloud Zuul等， 下边对各个组件进行分别介绍：</p><ul><li><strong>Spring Cloud Eureka</strong><ul><li>服务注册中心,可以把开发的接口注册到Eureka服务注册中心，所有服务间调用都通过服务的形式访问，并不通过http直连。构成Eureka体系的包括：<strong>服务注册中心、服务提供者、 服务消费者</strong>。</li></ul></li><li><strong>Spring Cloud Ribbon</strong><ul><li>Spring Cloud Eureka描述了服务如何进行注册，注册到哪里，服务消费者如何获取服务生产者的服务信息，但是Eureka只是维护了服务生产者、注册中心、服务消费者三者之间的关系，<strong>真正的服务消费者调用服务生产者提供的数据是通过Spring Cloud Ribbon 来实现的。</strong></li></ul></li><li><strong>Spring Cloud Feign</strong><ul><li>如果使用过Ribbon调用服务的话，就可以感受到使用Ribbon的方式还是有一些复杂，因 此Spring Cloud Feign应运而生。<strong>Spring Cloud Feign 是一个声明web服务客户端</strong>，这使得编写Web服务客户端更容易，使用Feign只需要创建一个接口并对它进行注解。 Spring  Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。<strong>简单的可以理解为： Spring Cloud Feign 的出现使得Eureka和Ribbon的使用更为简单。</strong></li></ul></li><li> <strong>Spring Cloud Hystrix</strong></li><li>断路器，保险丝；例如：当有一个服务出现了故障，而服务的调用方不知道服务出现故障， 若此时调用放的请求不断的增加，最后就会等待出现故障的依赖方相应形成任务的积压， 最终导致自身服务的瘫痪。Spring Cloud Hystrix正是为了解决这种情况的，<strong>防止对某一故障服务持续进行访问</strong>。</li><li><strong>Spring Cloud Config</strong><ul><li>对于微服务还不是很多的时候，各种服务的配置管理起来还相对简单，但是当成百上千的微服务节点起来的时候，服务配置的管理变得会复杂起来。分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。</li><li>配置服务的内存中（即本地），也支持放在远程Git仓库中。在Cpring Cloud Config 组件中，分两个角色，一是Config Server，二是Config Client。<strong>Config Server用于配置属性的存储</strong>，存储的位置可以为Git仓库、SVN仓库、本地文件等，<strong>Config Client用于服务属性的读取</strong>。</li></ul></li><li><strong>Spring Cloud Zuul</strong><ul><li>zuul 是netflix开源的一个API Gateway 服务器, <strong>本质上是一个web servlet应用</strong>。Zuul 在云平台上提供动态<strong>路由，监控，弹性，安全等</strong>边缘服务的框架。<strong>Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门</strong>。</li></ul></li><li><strong>Spring Cloud Bus</strong><ul><li>我们如果要去更新所有微服务的配置，在不重启的情况下去更新配置，只能依靠spring  cloud config了，但是，是我们要一个服务一个服务的发送post请求，这其实还是非常麻烦的。<strong>但是通过Bus消息总线，只需要在SpringCloud Config Server端发出refresh，就可以触发所有微服务更新了。</strong></li></ul></li></ul></li></ul><h6 id="2-3-1-Spring-Cloud-Eureka"><a href="#2-3-1-Spring-Cloud-Eureka" class="headerlink" title="2.3.1  Spring Cloud Eureka"></a>2.3.1  Spring Cloud Eureka</h6><ul><li><p>什么是Spring Cloud Eureka？</p><ul><li>一个基于rest服务的服务治理组件。</li><li>实现了云端负载均衡和中间层服务器的故障转移。</li><li>由两个组件组成<ul><li>Eureka服务器</li><li>Eureka客户端</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101151996.png" alt="image-20211110115103901"></p></li><li><p>Spring Cloud Eureka：</p><ul><li>一个基于rest服务的服务治理组件。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服 务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮 询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它 提供基于流量、资源利用率以及出错状态的加权负载均衡。</li></ul></li><li><p>上图中描述了：</p><ol><li><p>三台Eureka服务注册中心构成的服务注册中心的主从复制集群；</p></li><li><p>然后服务提供者向注册中心进行注册、续约、下线服务等；</p></li><li><p>服务消费者向Eureka注册中心拉去服务列表并维护在本地（这也是客户端发现模式的机制体现！）；</p></li><li><p>然后服务消费者根据从Eureka服务注册中心获取的服务列表选取一个服务提供者进行消费服务。</p></li></ol></li></ul><h6 id="2-3-2-Spring-Cloud-Ribbon"><a href="#2-3-2-Spring-Cloud-Ribbon" class="headerlink" title="2.3.2  Spring Cloud Ribbon"></a>2.3.2  Spring Cloud Ribbon</h6><ul><li><p>什么是Spring Cloud Ribbon？</p><ul><li>Spring Cloud Ribbon 是一个<strong>基于Http和TCP的客服端负载均衡工具</strong>，它是基于 Netflix Ribbon实现的。</li><li>不需要独立部署，几乎存在于每个微服务的基础设施中</li><li><strong>主要提供客户端的软件负载均衡算法，因为负载均衡是对系统的高可用、网络压力的缓解和处理能力扩容的重要手段之一</strong>。</li></ul></li><li><p>在2.3.1中提到了服务消费者是将服务从注册中心获取服务生产者的服务列表并维护在本地的，这种客户端发现模式的方式是服务消费者选择合适的节点进行访问服务生产者提供的数据，这种选择合适节点的过程就是Spring Cloud Ribbon完成的。</p></li><li><p>完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组 件。下面是用到的一些负载均衡策略：</p><ul><li>简单轮询负载均衡</li><li>加权响应时间负载均衡</li><li>区域感知轮询负载均衡</li><li>随机负载均衡</li></ul></li></ul><h6 id="2-3-3-Spring-Cloud-Feign"><a href="#2-3-3-Spring-Cloud-Feign" class="headerlink" title="2.3.3  Spring Cloud Feign"></a>2.3.3  Spring Cloud Feign</h6><ul><li>什么是Spring Cloud Feign？<ul><li><strong>Spring Cloud Feign 是一个声明web服务客户端，这使得编写Web服务客户端更容易 。</strong></li><li>完全代理HTTP请求，只需要像调用方法一样调用它就可以完成服务请求。</li><li>Spring Cloud Feign 的出现使得Eureka和Ribbon的使用更为简单</li></ul></li><li>Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。Feign 提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。</li><li>而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关 处理。<strong>Feign整合了Ribbon和Hystrix</strong>(关于Hystrix我们后面再讲)，<strong>可以让我们不再需要显式地使用这两个组件</strong>。</li></ul><h6 id="2-3-4-Spring-Cloud-Hystrix"><a href="#2-3-4-Spring-Cloud-Hystrix" class="headerlink" title="2.3.4  Spring Cloud Hystrix"></a>2.3.4  Spring Cloud Hystrix</h6><ul><li>什么是Spring Cloud Hystrix？<ul><li><strong>容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</strong><ul><li>也被称之为断路器，Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一 个、或多个依赖同时出现问题时保证系统依然可用。</li></ul></li></ul></li><li>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li><li>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此 故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时 （或者不返回）的请求，以保持系统的响应时间。</li></ul><h6 id="2-3-5-Spring-Cloud-Config"><a href="#2-3-5-Spring-Cloud-Config" class="headerlink" title="2.3.5  Spring Cloud Config"></a>2.3.5  Spring Cloud Config</h6><ul><li><p>什么是Spring Cloud Config？</p><ul><li>Spring Cloud Config是分布式配置中心，可以让你把配置放到远程服务器，目前支持<strong>本地存储、Git以及Subversion</strong>。</li><li>在Spring Cloud Config 组件中，分两个角色：<ul><li>Config Server：用于配置属性的存储，存储的位置可以为Git仓库、SVN仓库、本地文件等</li><li>Config Client：用于服务属性的读取。</li></ul></li></ul></li><li><p>对于微服务还不是很多的时候，各种服务的配置管理起来还相对简单，但是当成百上千的微服务节点起来的时候，服务配置的管理变得会复杂起来。</p></li><li><p>在分布式系统中，每一个功能模块都能拆分成一个独立的服务，一次请求的完成，可能会调用很多个服务协调来完成，为了方便服务配置文件统一管理，更易于部署、维护，所以就需要分布式配置中心组件了，在spring cloud中，有分布式配置中心组件spring cloud config，它支持配置文件放在在配置服务的内存中，也支持放在远程Git仓库里。引入spring cloud config后，我们的外部配置文件就可以集中放置在一个git仓库里，再新建一个config server，用来管理所有的配置文件，维护的时候需要更改配置时，只需要在本地更改后，推送到远程仓库，所有的服务实例都可以通过config server来获取配置文件，这时每个服务实例就相当于配置服务的客户端config client,为了保证系统的稳定，配置服务端config server可以进行集群部署，即使某一个实例，因为某种原因不能提供服务，也还有其他的实例保证服务的继续提供服务。</p></li><li><p>Spring Cloud Config 组件的二个角色：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101205892.png" alt="image-20211110120519832"></p></li><li><p>在Spring Cloud Config 组件中，分两个角色，一是Config Server，二是Config Client。如上图所示。</p></li></ul><h6 id="2-3-6-Spring-Cloud-Zuul"><a href="#2-3-6-Spring-Cloud-Zuul" class="headerlink" title="2.3.6  Spring Cloud Zuul"></a>2.3.6  Spring Cloud Zuul</h6><ul><li>什么是Spring Cloud Zuul ？<ul><li><strong>Spring Cloud Zuul是服务网关，边缘服务工具</strong>；</li><li>提供服务路由、均衡负载功能之外，它还具备了权限控制等功能；</li><li>为微服务架构提供了前门保护的作用；</li><li><strong>将权限控制这些较重的非业务逻辑内容迁移到服务路由层面</strong>，使得服务集群主体能够具备更高的可复用性和可测试性；</li></ul></li><li>Zuul 是 Netflix 开源的微服务网关，Spring Cloud 对 Zuul 进行了整合和增强。在 SpringCloud 体系中，<strong>Zuul 担任着网关的角色，对发送到服务端的请求进行一些预处理，比如 安全验证、动态路由、负载分配等</strong>。</li><li><strong>Zuul 的核心是 Filters</strong>，根据执行时期分为以下几类：<ul><li>PRE：这种过滤器在请求被路由之前调用</li><li>ROUTING：这种过滤器将请求路由到微服务</li><li>POST：这种过滤器在路由到微服务以后执行</li><li>ERROR：在其他阶段发生错误时执行该过滤器</li></ul></li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101209103.png" alt="image-20211110120917045"></p><ul><li>如上图所示，Zuul 相当于是设备和 Web 网站后端所有请求的前门。</li></ul><h6 id="2-3-7-Spring-Cloud-Bus"><a href="#2-3-7-Spring-Cloud-Bus" class="headerlink" title="2.3.7  Spring Cloud Bus"></a>2.3.7  Spring Cloud Bus</h6><ul><li><p>什么是Spring Cloud Bus ？</p><ul><li><strong>Spring Cloud Bus 是事件、消息总线</strong>，<strong>用于在集群（例如，配置变化事件）中传播状态变化</strong>，可与Spring Cloud Config联合实现热部署。</li></ul></li><li><p>我们如果要去更新所有微服务的配置，在不重启的情况下去更新配置，只能依靠spring cloud  config了，但是，是我们要一个服务一个服务的发送post请求，这其实还是非常麻烦的。但是通 过Bus消息总线，只需要在SpringCloud Config Server端发出refresh，就可以触发所有微服务更新了。</p></li><li><p>Spring Cloud Bus官方意义：消息总线。</p></li><li><p>当然动态更新服务配置只是消息总线的一个用处，还有很多其他用处。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101211886.png" alt="image-20211110121104828"></p></li><li><p> 如上图就演示了联合Spring Cloud Config 动态更新服务配置。</p></li></ul><ol><li>提交代码触发post给客户端C发送bus/refresh</li><li>客户端C接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ol><h4 id="第三章-开发一个Spring-Cloud程序"><a href="#第三章-开发一个Spring-Cloud程序" class="headerlink" title="第三章  开发一个Spring Cloud程序"></a>第三章  开发一个Spring Cloud程序</h4><ul><li><p>在掌握了Spring Boot的基本使用，以及Spring Cloud的基本概念、组件后我们进行Spirng Cloud的代码编写，接下来我将一步步带领大家完成第一个Spring Cloud应用程序。</p></li><li><p>这里可以再回顾一下Spring Boot项目的创建，接下来的项目创建都会基于Spring Boot创建。</p></li></ul><h5 id="3-1-开发第一个Spring-Cloud程序"><a href="#3-1-开发第一个Spring-Cloud程序" class="headerlink" title="3.1  开发第一个Spring Cloud程序"></a>3.1  开发第一个Spring Cloud程序</h5><ul><li><p>开发第一个Spring Cloud应用程序(涉及服务注册中心）</p></li><li><p>包含以下步骤：</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101214110.png" alt="image-20211110121432065"></p></li><li><p>前面我们学习了Spring Cloud的常用组件，此处第一个Spirng Cloud应用程序，只涉及服务提供者，服务消费者，服务注册中心；服务消费者中会涉及到Ribbon的使用。</p></li><li><p> 环境准备：</p></li><li><p>JDK1.8</p></li><li><p>Maven版本：3.3.9</p><ul><li>修改setting配置为国内下载镜像</li><li>Maven编码过程中需要下载依赖，需要网络环境</li></ul></li><li><p>Eclipse或者IDEA</p><ul><li>字符集编码：UTF-8</li></ul></li><li><p>环境准备跟Spirng Boot项目一致。</p></li></ul><h6 id="3-1-1-开发eureka-server"><a href="#3-1-1-开发eureka-server" class="headerlink" title="3.1.1  开发eureka-server"></a>3.1.1  开发eureka-server</h6><ul><li><p><strong>创建eureka-server项目：</strong></p><ul><li><p>根据”开发第一个Spring Boot项目”创建eureka-server项目:</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101725262.png" alt="image-20211110172527172"></p></li><li><p>eureka-server项目的基本创建方式跟前面讲述的Spring Boot项目创建方式一致，这里就不重复了。</p></li></ul></li><li><p><strong>添加dependencyManagement定义：</strong></p><ul><li><p>在项目根目录下的pom.xml配置文件中添加dependencyManagement定义（放在 dependencies同级节点）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- springboot 1.5.11对应的springcloud依赖管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>这里添加dependencyManagement主要是为了统一定义Spring Cloud的版本信息，注意这里并没有实际引入依赖，只是在后面定义依赖的时候不需要申明版本信息了。</p></li><li><p><strong>添加eureka依赖：</strong></p><ul><li><p>在项目根目录下的pom.xml添加eureka的依赖配置信息，这里注意添加2个依赖：spring-cloud-starter-config和spring cloud-starter-eureka-server，注意位置要放在dependencies节点下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>在启动类，添加注解：</strong></p><ul><li><p>在启动类EurekaServerApplication上添加@EnableEurekaServer注解;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>启动类的创建方式跟Spring Boot应用程序是一样，实际上这里就是一个Spirng Boot应用程序；</p></li><li><p>注意一定要添加<font color='red'>@EnableEurekaServer注解，表明当前应用是一个eureka服务注册中心，后面 其它应用程序需要注册到此中心。</font></p></li></ul><ul><li><p><strong>添加eureka配置文件：</strong></p><ul><li><p>在resources目录下新建配置文件application.yml，并添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#表示是否将自己注册到Eureka Server，默认为true。</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#表示是否从Eureka Server获取注册信息，默认为true</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>server.port: 8000这里是把应用的启动端口改为了8000</p></li><li><p>eureka.client.register-with-eureka： fase：表示是否将自己注册到Eureka Server，默认为 true。</p></li><li><p>eureka.client.fetch-registry: false：表示是否从Eureka Server获取注册信息，默认为true</p></li><li><p>eureka.client.service-url.defaultZone: <a href="http://localhost:${server.port}/eureka/">http://localhost:${server.port}/eureka/</a> 这里是定义了 服务注册中心的地址，其中${server.port}就是前面定义的server.port: 8000配置，时间上这段配 置就是eureka.client.service-url.defaultZone: <a href="http://localhost:8000/eureka/%EF%BC%9B%E8%BF%99%E6%AE%B5%E9%85%8D%E7%BD%AE%E5%9C%A8%E5%85%B6">http://localhost:8000/eureka/；这段配置在其</a> 它应用程序的配置中都需要加上，指明了服务注册中心的地址。</p></li></ul></li></ul><ul><li><p><strong>浏览器访问测试：</strong></p><ul><li><p>运行EurekaServerApplication启动类，访问<a href="http://localhost:8000：">http://localhost:8000：</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101806261.png" alt="image-20211110180611062"></p></li><li><p>访问<a href="http://localhost:8000可以看到如上图结果；如果有服务注册到注册中心，可以在">http://localhost:8000可以看到如上图结果；如果有服务注册到注册中心，可以在</a> application下面看到对应的服务名称。</p></li></ul></li><li><p>eureka-server项目的完整pom文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- springboot 1.5.11对应的springcloud依赖管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="3-1-2-开发eureka-provider"><a href="#3-1-2-开发eureka-provider" class="headerlink" title="3.1.2  开发eureka-provider"></a>3.1.2  开发eureka-provider</h6><ul><li><p><strong>创建eureka-provider项目</strong></p><ul><li>根据Spring Boot项目创建方式创建eureka-provider项目</li></ul><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101821055.png" alt="image-20211110182142953"></p><ul><li>项目创建方式如eureka-server，这里是创建服务提供者，需要把当前服务提供者注册到上一小节中我们创建的eureka-server中。</li></ul></li><li><p><strong>添加dependencyManagement定义和eureka依赖：</strong></p><ul><li><p>eureka-provider项目完整依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- springboot 1.5.11对应的springcloud依赖管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>在启动类，添加注解</strong></p><ul><li><p>在启动类EurekaProviderApplication上添加@EnableEurekaClient， @EnableDiscoveryClient注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaProviderApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>启动类的创建跟eureka-server一致。</p></li><li><p><font color='red'>@EnableEurekaClient表明当前应用是一个eureka客户端程序</font></p></li><li><p><font color='red'>@EnableDiscoveryClient表明当前应用可以被eureka服务注册中心发现</font></p></li></ul><ul><li><p><strong>开发eureka-provider</strong></p><ul><li><p>在启动类EurekaProviderApplication相同包目录下新建 HelloController类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;provider: hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><font color='red'>@RestController表明当前Controller类的所有接口都是rest方式，直接返回数据，不返回视图（页面），方法上不需要再添加ResponseBody注解。</font></p></li></ul></li><li><p><strong>添加配置文件：</strong></p><ul><li><p>在resources目录下新建配置文件application.yml，并添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-provider</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8000/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>server.port: 8001表明应用的启动端口为8001</p></li><li><p>spring.application.name: eureka-provider 配置当前服务的名称为eureka-provider，启动成功后会在eureka的web服务页面显示出来</p></li><li><p>eureka.client.service-url.defaultZone: <a href="http://localhost:8000/eureka/%E8%A1%A8%E6%98%8E%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E4%B8%8A%E5%B0%8F%E8%8A%82%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%9A%84eureka-server%E7%9A%84%E5%9C%B0%E5%9D%80">http://localhost:8000/eureka/表明服务注册中心的地址，实际上就是我们上小节中创建的eureka-server的地址</a></p></li></ul></li></ul><ul><li><p><strong>启动eureka-provider项目</strong></p><ul><li><p>运行启动类EurekaProviderApplication，用浏览器访问<a href="http://localhost:8000/%EF%BC%9A">http://localhost:8000/：</a></p></li><li><p>eureka-provider会自动注册到enreka-server的服务注册中心</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111101838838.png" alt="image-20211110183820695"></p></li></ul></li><li><p>启动eureka-server，eureka-provider应用后访问<a href="http://localhost:8000/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%B3%A8%E6%84%8F%E6%AD%A4%E5%A4%84%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%89%80%E4%BB%A5%E7%AB%AF%E5%8F%A3%E6%98%AF8000%EF%BC%8C%E4%B8%8D%E6%98%AF8001%E3%80%82">http://localhost:8000/就可以看到已经注册的服务，注意此处访问的地址为服务注册中心的地址，所以端口是8000，不是8001。</a></p></li></ul><h6 id="3-1-3-开发eureka-consumer"><a href="#3-1-3-开发eureka-consumer" class="headerlink" title="3.1.3 开发eureka-consumer"></a><strong>3.1.3 开发eureka-consumer</strong></h6><p><strong>开发eureka-consumer项目：</strong></p><ul><li><p>根据前面第一个Spring Boot项目案例创建eureka-consumer项目</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118153215147.png" alt="image-20211118153215147"></p></li><li><p>跟eureka-server的项目创建方式一致</p></li></ul><ul><li><p><strong>添加dependencyManagement定义和eureka依赖</strong></p></li><li><p>eureka-consumer项目的完整依赖如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.keepdive<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.11.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- springboot 1.5.11对应的springcloud依赖管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>创建启动类：</strong></p><ul><li>在启动类EurekaConsumerApplication上添加注解，定义RestTemplate</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaConsumerApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function">RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里有些代码、注解和eureka-server不一致</li><li><font color='red'>@EnableDiscoveryClient @EnableEurekaClient注解一样跟eureka-provider一致，都是为了注册当前服务到eureka服务注册中心</font></li><li><font color='red'>getRrestTemplate是为了注入RestTemplate到spirng容器，这样其它类再使用就可以直接用注解的形式使用，在业务controller中会涉及到</font></li><li><font color='red'>@Bean   注入bean到spring容器</font></li><li><font color='red'>@LoadBalanced实现客户端负载均衡</font></li></ul></li></ul><ul><li><p><strong>添加业务Controller：</strong></p><ul><li>在启动类EurekaProviderApplication包路径下新建HelloConsumerController类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloConsumerController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/consumer/helle/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloConsumer</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://eureka-provider/hello&quot;</span> + name, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>消费者业务Controller，主要是为了消费eureka-provider应用中提供的服务</li><li>这里采用的是路径传参数，在前面的Spring Boot传参示例中有说明</li><li>这里业务controller的意思是，当客户端访问/consumer/hello/{name}这个连接时，会通过restTemplate访问<font color='red'>eureka-provider服务中hello接口，简单来说就是消费eureka-provider服务</font>。</li><li>@Autowired表示RestTemplate 为自动注入，bean的定义就是启动类中注入到了spring容器，所以这里可以通过spring容器自动注入。</li><li>resttemplate会在后面的服务通信方式中介绍</li></ul></li></ul><ul><li><p><strong>修改配置文件：</strong></p><ul><li><p>修改resources目录下配置文件application.yml，并添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8002</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-consumer</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8000/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>server.port: 8002 应用启动端口为8002</p></li><li><p>spring.application.name: eureka-consumer应用服务名称为：eureka-consumer</p></li><li><p>eureka.client.service-url.defaultZone: <a href="http://localhost:8000/eureka/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9C%B0%E5%9D%80">http://localhost:8000/eureka/注册中心地址</a></p></li></ul></li></ul><ul><li><p><strong>启动eureka-consumer应用</strong></p><ul><li><p>运行启动类EurekaConsumerApplication</p></li><li><p>浏览器访问服务注册中心：<a href="http://localhost:8000/%EF%BC%9B%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E5%88%B0%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E5%88%B0%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82%E5%9B%BE%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%9C%892%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E6%B3%A8%E5%86%8C%E5%88%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83![image-20211118173927978](https://gitee.com/divemaven/git-project/raw/master/image-20211118173927978.png)">http://localhost:8000/；可以查看到已经注册到服务中心的服务，如图：可以发现有2个服务已经注册到服务注册中心![image-20211118173927978](https://gitee.com/divemaven/git-project/raw/master/image-20211118173927978.png)</a></p></li><li><p>访问<a href="http://localhost:8002/consumer/hello/test%EF%BC%8C%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AFeureka-consumer%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84/hello%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8eureka-consumer%E7%9A%84hello%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9E%E9%99%85%E6%98%AF%E8%B0%83%E7%94%A8%E5%88%B0%E4%BA%86eureka-provider%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84hello%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AFprovider%EF%BC%9Ahello">http://localhost:8002/consumer/hello/test，访问的是eureka-consumer应用中的/hello接口，但是在eureka-consumer的hello接口中实际是调用到了eureka-provider应用中的hello接口，可以看到页面显示的内容是provider：hello</a> test</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118175601326.png" alt="image-20211118175601326"></p></li></ul></li></ul><h4 id="第四章-服务间通信方式"><a href="#第四章-服务间通信方式" class="headerlink" title="第四章 服务间通信方式"></a>第四章 服务间通信方式</h4><p>前面我们讲解了spirng Boot，Spring Cloud的基本概念以及使用，那在上一章节中我们还留下一个问题，我们eureka-consumer是如何访问到我们的eureka-provider的？在代码中我们其实看到了是采用RestTemplate的方式访问的，那除了RestTemplate的方式外是否还有其他方式呢？</p><h5 id="4-1-服务间通信方式"><a href="#4-1-服务间通信方式" class="headerlink" title="4.1 服务间通信方式"></a>4.1 服务间通信方式</h5><ul><li><p>Spring Cloud 与Spring Boot 都采用Restful API 形式进行通信。</p><ul><li><p>同步方式: RestTemplate</p></li><li><p>异步方式: AsyncRestTemplate</p></li><li><p>声明式服务调用方式: Feign</p></li></ul></li><li><p>首先我们看一下同步，异步的思想：</p></li><li><p><strong>同步</strong>：同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。</p></li><li><p>**异步(Async)**：将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应了。你可以关闭界面了。</p></li><li><p><strong>声明式服务调用方式</strong>：当我们通过RestTemplate调用其它服务的API时，所需要的参数须在请求的URL中进行拼接，如果参数少的话或许我们还可以忍受，一旦有多个参数的话，这时拼接请求字符串就会效率低下，并且显得好傻。那么有没有更好的解决方案呢？答案是确定的有，Netflix已经为我们提供了一个框架：Feign。Feign是一个声明式的Web Service客户端，<strong>它的目的就是让Web Service调用更加简单。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解</strong>，就可以定义好HTTP请求的参数、格式、地址等信息。<strong>而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。</strong></p></li></ul><h5 id="4-2-同步方式-RestTemplate"><a href="#4-2-同步方式-RestTemplate" class="headerlink" title="4.2 同步方式-RestTemplate"></a>4.2 同步方式-RestTemplate</h5><ul><li><p><strong>RestTemplate示例：</strong></p><ul><li><p><strong>在eureka-consumer项目的启动类EurekaConsumerApplication中注入RestTemplate到Spring容器中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function">RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意这里的代码还是基于eureka-consumer的案例，基于前面的代码做扩展，由于前面我们服务间通信就是采用的RestTemplate；所以这里不再重复操作截图，只贴代码。</p></li></ul><ul><li><p><strong>在HelloConsumerController中添加代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RestTemplate restTemplate;<br><br><span class="hljs-meta">@RequestMapping(&quot;/consumer/hello/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloConsumer</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;<br><span class="hljs-keyword">return</span>  restTemplate.getForObject(<span class="hljs-string">&quot;http://eureka-provider/hello/&quot;</span> + name, String.class);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如前面介绍eureka-consumer中HelloConsumerController类，这里代码跟前面一致。</p></li><li><p><strong>浏览器中访问：<a href="http://localhost:8002/consumer/hello/test">http://localhost:8002/consumer/hello/test</a></strong></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118175601326.png" alt="image-20211118175601326"></p></li><li><p>访问结果如eureka-consumer案例中一致，修改url中参数”<a href="http://localhost:8002/consumer/hello/%E5%8F%82%E6%95%B0%E2%80%9C%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%B9%9F%E4%B8%8D%E4%B8%80%E8%87%B4">http://localhost:8002/consumer/hello/参数“，结果也不一致</a>.</p></li></ul></li></ul><h5 id="4-3-异步方式-AsyncRestTemplate"><a href="#4-3-异步方式-AsyncRestTemplate" class="headerlink" title="4.3 异步方式-AsyncRestTemplate"></a>4.3 异步方式-AsyncRestTemplate</h5><ul><li><p><strong>AsyncRestTemplate示例：</strong></p><ul><li><strong>在eureka-consumer项目的启动类EurekaConsumerApplication中注入AsyncRestTemplate到Spring容器中</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function">AsyncRestTemplate <span class="hljs-title">asyncRestTemplate</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncRestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在启动类中注入AsyncRestTemplate 到spirng容器，作用跟RestTemplate一致，都是为了在Controller中可以自动注入使用</li><li>各个注解内容跟RestTemplate注入一致</li></ul><ul><li><p><strong>在HelloConsumerController类中添加方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>AsyncRestTemplate asyncRestTemplate;<br><br><span class="hljs-meta">@RequestMapping(&quot;consumer/async/hello/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">asyncRest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = asyncRestTemplate.getForEntity(<span class="hljs-string">&quot;http://eureka-provider/hello/&quot;</span> + name, String.class);<br>    <span class="hljs-keyword">return</span> future.get().getBody();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过@Autowired注入AsyncRestTemplate</p></li><li><p>然后再asyncRest接口中直接使用asyncRestTemplate.getForEntity(“<a href="http://eureka-provider/hello/&quot;">http://eureka-provider/hello/&quot;</a> + name, String.class)；如此就是通过异步的方式调用服务提供者</p></li><li><p>这里虽然是异步但是返回的内容还是同步的，其原因在于接口中返回代码“return future.get().getBody()”，其中用的是future.get()，这个方法会等待接口调用结束后再返回。</p></li><li><p>可以通过在returen中直接返回，然后注册异步执行的回调方法，演示异步效果</p></li></ul><ul><li><p><strong>浏览器中访问：</strong><a href="http://localhost:8002/consumer/async/hello/test">http://localhost:8002/consumer/async/hello/test</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118183638698.png" alt="image-20211118183638698">            </p></li><li><p><strong>服务消费者通过异步方式调用服务提供者过程</strong> </p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118183542509.png" alt="image-20211118183542509"></p></li><li><p>图中演示了服务消费者通过异步方式调用服务提供者过程，异步的方式可以直接返回响应，也可以等待异步调用结束后再返回数据，跟ajax的基本思路一致。可以在不阻塞程序的情况下进行调用，也可以使用阻塞模式等待数据返回。</p></li></ul></li></ul><h5 id="4-4-声明式服务调用方式-Feign"><a href="#4-4-声明式服务调用方式-Feign" class="headerlink" title="4.4 声明式服务调用方式-Feign"></a>4.4 声明式服务调用方式-Feign</h5><ul><li><p><strong>添加Feign依赖:</strong></p><ul><li><p>在eureka-consumer项目根目录下的pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加启动注解:</strong></p><ul><li><p>在EurekaConsumerApplication启动类上添加注解@EnableFeignClients</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118184303699.png" alt="image-20211118184303699"></p></li><li><p>启动类上需要添加@EnableFeignClients注解，表明当前应用启用feign客户端；前提是要添加依赖，不然启动失败</p></li></ul></li><li><p><strong>添加FeignClient:</strong></p><ul><li>在EurekaConsumerApplication启动类所在包下新建HelloClient接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;eureka-provider&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span>String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@FeignClient(name=”eureka-provider”) 注解声明feign客户端，这里“eureka-provider”和要访问的服务名称一致，实际上就是要调用的服务名称</li><li>@GetMapping(“/hello/{name}”)  这里的链接地址要和要访问的服务的详细地址一致</li><li>注意这里是一个接口，不是实现类，不需要实现，所以这通feign可以简化我们的服务调用</li><li>注意：<ul><li>public String sayHello(@PathVariable(“name”) String name);</li><li>上面代码里一定要写成@PathVariable(“name”)，不能写成@PathVariable</li></ul></li></ul></li></ul><ul><li><p><strong>添加访问入口:</strong></p><ul><li><p>在HelloConsumerController类中添加访问接口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>HelloClient helloClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;consumer/feign/hello/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">feign</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> helloClient.sayHello(name);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在HelloConsumerController添加服务访问入口</li><li>通过@Autowired自动注入我们上一步骤中定义的feign客户端：HelloClient </li><li>然后再在具体的feign方法中调用helloClient.sayHello(name);其效果跟我们采RestTemplate访问一致。</li></ul></li><li><p><strong>浏览器访问测试:</strong></p><ul><li><p>在浏览器中访问：<a href="http://localhost:8002/consumer/feign/hello/test">http://localhost:8002/consumer/feign/hello/test</a></p><p><img src="https://gitee.com/divemaven/git-project/raw/master/image-20211118191334638.png" alt="image-20211118191334638"></p></li><li><p>访问结果和RestTemplate一致</p></li></ul></li></ul></li></ul><h5 id="4-5-Restful-API设计规范"><a href="#4-5-Restful-API设计规范" class="headerlink" title="4.5 Restful API设计规范"></a>4.5 Restful API设计规范</h5><ul><li>Restful API设计规范：<ul><li>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如， GET /articles这个命令， GET是动词， /articles是宾语。</li><li>五种动词：<strong>GET（读取）、POST（新建）、PUT（更新）、PATCH（更新）、DELETE（删除）</strong>。</li><li>客户端的每一个请求，服务器都必须进行回应，包含HTTP状态码和数据。</li></ul></li><li>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。因此，<strong>必须有一种统一的机制，方便不同的前端设备与后端进行通信</strong>。这导致API构架的流行，甚至出现”APIFirst”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。</li><li>REST（Representational State Transfer）<strong>表述层状态转换</strong>，REST指的是一组架构约束条件和原则。如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力，更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深，<strong>但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。</strong></li><li>RFC 3986定义了通用的URI语法：</li><li>URI = scheme “://” authority  “/” path   [ “?” query ]  [ “#” fragment ]</li><li><strong>scheme</strong>: 指底层用的协议，如http、https、ftp</li><li><strong>host</strong>: 服务器的IP地址或者域名</li><li><strong>port</strong>: 端口，http中默认80</li><li><strong>path</strong>: 访问资源的路径，就是咱们各种web 框架中定义的route路由</li><li><strong>query</strong>: 为发送给服务器的参数</li><li><strong>fragment</strong>: 锚点，定位到页面的资源，锚点为资源id</li><li><strong>Eg</strong>:   http(s)://server.com/api-name/{version}/{domain}/{rest-convention}</li><li>这里，{version}代表api的版本信息。{domain}是一个你可以用来定义任何技术的区域(例如：安全-允许指定的用户可以访问这个区域。)或者业务上的区域(例如：同样的功能在同一个前缀之下。)。{rest-convention} 代表这个域(domain)下，约定的rest接口集合。</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li><strong>Spring Boot 跟Spring Cloud的区别是什么？</strong></li><li><strong>Spring Cloud服务组件之间的通信方式有哪些？</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、微服务介绍</title>
    <link href="/2021/11/08/%E4%B8%80%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/11/08/%E4%B8%80%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一、微服务介绍"><a href="#一、微服务介绍" class="headerlink" title="一、微服务介绍"></a>一、微服务介绍</h3><p>什么是微服务？把一个庞大的application<strong>拆</strong>成几个小的独立的服务，再把独立的服务<strong>串</strong>起来的一种架构设计。</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>通过本文的学习，您将可以:</p><ul><li>了解软件架构的演变过程 </li><li>了解传统软件架构的弊端</li><li>了解微服务的概念及常见架构</li></ul><h4 id="第一章-软件架构的演变过程"><a href="#第一章-软件架构的演变过程" class="headerlink" title="第一章 软件架构的演变过程"></a>第一章 软件架构的演变过程</h4><h5 id="1-1-传统的单体架构"><a href="#1-1-传统的单体架构" class="headerlink" title="1.1 传统的单体架构"></a>1.1 传统的单体架构</h5><ul><li>不同于微服务，传统的项目会包含很多功能，是一个大而全的“超级”工程。<ul><li>例如：以普通架构方式实现的电商平台包含：登录、权限、会员、商品库存、订单、 收藏、关注、购物车等功能的多个单一项目。随着项目业务越来越复杂、开发人员越 来越多，相应开发、编译、部署、技术扩展、水平扩展都会受到限制。<img src="https://gitee.com/divemaven/git-project/raw/master/202111081534330.png" alt="image-20211108153431273"></li></ul></li><li>单体架构是最简单的软件架构，常用于传统的应用软件开发以及传统Web应用。</li><li>传统Web应用，一般是将所有功能模块都打包(jar,war)在一个Web容器（JBoss、Tomcate）中 部署、运行。随着业务复杂度增加、技术团队规模扩大，在一个单体应用中维护代码，会降低开发效率。即使是处理一个小需求，也需要将所有机器上的应用全部部署一遍，增加了运维的复杂度。</li></ul><h5 id="1-2-基于SOA的软件架构"><a href="#1-2-基于SOA的软件架构" class="headerlink" title="1.2 基于SOA的软件架构"></a>1.2 基于SOA的软件架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081538726.png" alt="image-20211108153829683"></p><ul><li><p>SOA也叫面向服务的架构，从单体架构到SOA的演进，需要结合水平拆分以及垂直拆分。</p></li><li><p>SOA强调用统一的协议进行服务间的通信，服务间运行在彼此独立的硬件平台但是需通过统一的 协议接口相互协作，也即将应用系统服务化。</p><ul><li>举个易懂的例子，单体服务如果相当于一个快餐店，所有的服务员都是一样的，又要负责收银结算，又要负责做汉堡，又要负责端盘子，又要负责打扫，服务员之间不需要有交流，一个用户来了一个服务员从前到后负责到底。SOA相当于让服务员有职责分工，收银员负责收银， 厨师负责做汉堡，保洁阿姨负责打扫等等。所有服务员需要同一种语言交流，方便工作协调。</li></ul></li><li><p> SOA架构的特征</p></li><li><p>基于SOA服务思想进行功能的抽取(重复代码问题解决),以服务为中心来管理项目。</p></li><li><p>各个系统之间要进行调用,所以出现ESB来管理项目(可以使用各种技术实现： webservice，rpc等)。</p></li><li><p>ESB是作为系统与系统之间桥梁,很难进行统一管理。</p></li></ul><h5 id="1-3-基于微服务的系统架构"><a href="#1-3-基于微服务的系统架构" class="headerlink" title="1.3 基于微服务的系统架构"></a>1.3 基于微服务的系统架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081541492.png" alt="image-20211108154143453"></p><ul><li><p><strong>微服务的核心思路是拆分</strong>。单体项目的问题，通过把项目拆分成一个个小项目就可以解决。</p></li><li><p><strong>与SOA区别</strong>： </p><ul><li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，<strong>真正地实现服务自治</strong>； </li><li>SOA的思想进入到单个业务系统内部，<strong>实现真正的组件化</strong>。</li></ul></li><li><p>基于SOA面向服务架构演变出了微服务架构，微服务也是一种服务化，不过其和SOA架构的服务 化概念也是有区别的。可以从几个关键字来理解：</p><ul><li><p><strong>松耦合</strong>：每个微服务内部都可以使用DDD(领域驱动设计)的思想进行设计领域模型，服务间尽量减少同步的调用，多使用消息的方式让服务间的领域事件来进行解耦。</p></li><li><p><strong>轻量级协议</strong>：Dubbo是SOA的开源的标准实现之一，类似的还有像gRPC、Thrift等。微服务 更倾向于使用Restful风格的API，轻量级的协议可以很好得支持跨语言开发的服务，可能有的微服务用Java实现，有的用Go语言，有的用C++，但所有的语言都可以支持Http协议通信， 所有的开发人员都能理解Restful风格API的含义。</p></li><li><p><strong>高度自治和持续集成</strong>：从底层的角度来说，SOA更加倾向于基于虚拟机或者服务器的部署， 每个应用都部署在不同的机器上。微服务可以很好的和容器技术结合，目前Docker已经成为很多微服务实践的基础容器。如果某个微服务流量压力比其他微服务大，可以在不增加机器的情况。在一台机器上多分配一些该微服务的容器实例。</p></li><li><p>其实从架构的演进的角度来看，整体的演进都是朝着越来越轻量级，越来越灵活的应用方向。 甚至到近两年日渐成熟起来的<strong>Serverless（无服务）架构</strong>。从单体服务到分层的服务，再到面向服务、再到微服务甚至无服务。对于架构的挑战是越来越大的。</p></li></ul></li></ul><h4 id="第二章-微服务的概念和常见架构"><a href="#第二章-微服务的概念和常见架构" class="headerlink" title="第二章 微服务的概念和常见架构"></a>第二章 微服务的概念和常见架构</h4><p>接下来我们正式进入微服务的学习，我们先看看一下微服务到底是什么，以及微服务的常用架构有哪些？</p><h5 id="2-1-微服务的概念"><a href="#2-1-微服务的概念" class="headerlink" title="2.1 微服务的概念"></a>2.1 微服务的概念</h5><ul><li><p>什么是微服务？</p><ul><li><p>把一个庞大的application<strong>拆</strong>成几个小的独立的服务，再把独立的服务<strong>串</strong>起来的一种架构设计。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081613999.png" alt="image-20211108161316936"></p></li></ul></li><li><p>微服务架构描述了一种将软件应用程序设计为<strong>一组可独立部署的服务</strong>的特定方式。</p></li><li><p>虽然这种架构风格没有明确的定义，但在组织、业务能力上有一些共同的特征：<strong>自动化部署</strong>，<strong>端点智能化</strong>，<strong>语言和数据的去中心化控制</strong>。</p></li><li><p>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的 进程中，服务间通信采用轻量级通信机制(<strong>通常用HTTP资源API</strong>)。这些服务围绕业务能力构建并且可通过<strong>全自动部署机制独立部署</strong>。</p></li><li><p>比如12306买火车票，或者是网上购物：以前单体架构的感受是：高峰期人多的时候，页面刷不开，等刷开的时候，火车票都抢光了。网上购物也一样，浏览、选择、下订单了，结果因为支付失败，又需要全部重新来一遍。给人体验非常不好。为了提高体验，对单体架构进行扩容提升性能，只能购买昂贵的服务器，去支撑峰值流量，而绝大部分人都是在访问页面，后面的选择、（加入购物车）、下单、支付、每个环节的转换率都会使访问量降低，而单体架构的扩容是对所有功能进行整体扩容，造成大量浪费，如果采用微服务架构以后，可以针对浏览界面的服务做更多扩容，订单服务少量扩容，不再需要对所有功能进行整体扩容，<strong>所以把功能拆分微服务后，既能提升用户体验，又能实现节约硬件成本的作用</strong>。尤其适合现在互联网上的抢票、秒杀等会带来突发峰值流量的场景。因为结合具有资源弹性伸缩的已经成熟的云计算技术，微服务架构可以很好的满足这些场景需求。</p></li></ul><h5 id="2-2-微服务的特征"><a href="#2-2-微服务的特征" class="headerlink" title="2.2 微服务的特征"></a>2.2 微服务的特征</h5><ul><li>微服务的九大特征：<ol><li>服务组件化</li><li> 按业务组织团队</li><li>做产品的态度</li><li>智能端点和哑管道</li><li>去中心化治理</li><li>去中心化管理数据</li><li>基础设施自动化</li><li>容错设计</li><li>演进式设计</li></ol></li><li>在这里我们先简单了解微服务的九大特征，具体的将会在后续的章节的微服务拆分内容中进行讲解，大家在后续实践中也可以深入了解和应用。</li><li><strong>微服务的特征</strong><ol><li><strong>服务组件化：</strong> 在微服务架构中，需要我们对服务进行组件化分解，服务是一种进程外的组件，它通过HTTP等通信协议进行协作，而不是像传统组件那样镶入式的方式协同工作，每一 个服务都独立开发、部署、可以有效避免一个服务的修改引起整个系统的重新部署。</li><li><strong>按业务组织团队：</strong> 在实施微服务架构时，需要采用不同的团队分割方法。由于每一个服务 都是针对特定的业务的宽栈或者全栈实现的，主要负责数据的持久化存储，又要负责用户接口定义等各种跨专业领域的职能。因此面对大型项目的时候，对于微服务团队的拆分更加建议按业务线的方法进行拆分，一方面可以有效的减少服务内部修改所产生的内耗，另一方面，团队边界可以变得更为清晰。</li><li><strong>做产品的态度：</strong> 在微服务架构团队中，每个小团队都应该以做产品的方式，对其整个生命 周期负责，而不是像传统项目开发那样，交付给测试，运维为目标。</li><li><strong>智能端点和哑管道：</strong> 由于各个服务不在一个进程中，组件间的通信模式发生了改变，原本进程 内的方法调用变成了RPC方式的调用，会导致微服务之间产生烦琐的通信，使得系统表现更为糟 糕，所以我们需要更粗粒度的通信协议： 在微服务架构中，通常会使用以下两种服务调用方 法：<ul><li>使用<strong>HTTP的RESTful API</strong>或者轻量级的消息发送协议，实现消息传递与服务调用的触发。</li><li>通过在轻量级消息总线上传递消息，类似RabbitMQ等一些提供可靠异步交换的中间体。</li><li>在极度强调性能的情况下，还有可能会使用二进制的消息发送协议，例如protobuf</li></ul></li><li> <strong>去中心化治理：</strong> 在整个微服务架构，通过采用轻量级的契约定义接口，使得我们对服务本身的 具体技术平台不再那么敏感，这样整个微服务架构系统中的各个组件就能针对不同的业务特点选 择不同的技术平台。</li><li><strong>去中心化管理数据：</strong> 在实施微服务架构时，希望每一个服务自己来管理其数据库，这就是数据 管理的去中心化，虽然数据管理的去中心化让数据管理更加细致化，让数据存储和性能达到最优， 但是不同的数据库实例，<strong>数据一致性也成了微服务架构中亟待解决的问题之一</strong>，分布式事务本身实现的难度就非常大，所以在微服务架构中，我们更强调各服务之间进行”<strong>无事务</strong>“的调用，而对数据一致性，只要求<strong>数据在最后的处理状态是一致</strong>的即可。</li><li><strong>基础设施自动化</strong>： 在微服务架构中，务必从一开始就构建起”持续交付“平台来支撑整个实施过程；</li><li><strong>容错设计</strong>： 在微服务架构中，快速检测出故障源并尽可能地自动恢复服务是必须被设计考虑的， 通常我们都希望在每个服务中<strong>实现监控和日志记录</strong>的组件。比如：服务状态、断路器状态、吞吐量、网络延迟等关键数据的仪表盘等。</li><li><strong>演进式设计：</strong> 通过上面的几点特征，我们已经能够体会到，要实施一个完美的“微服务”架构， 需要考虑的设计与成本并不小，对于没有足够经验的团队来说，甚至要比单体应用要付出更多的代价。所以，很多情况下，架构师们都会以演进的方式进行系统的构建，在初期系统以单体系统的方式来设计和实施，一方面系统体量初期并不会很大，构建和维护成本都不高。另一方面，初期的核心业务在后期通常也不会发生巨大的改变。随着系统的发展或者业务的需要，架构师们会将一些<strong>经常变动</strong>或是有<strong>一定时间效应</strong>的内容进行“微服务”处理，并逐渐地将原来在单体系统中 多变的模块逐步拆分出来，<strong>而稳定不太变化的就形成了一个核心“微服务”存在于整个架构之中。</strong></li></ol></li><li> 如何理解智能端点和哑管道？</li><li>这玩意你要先理解智能端点和哑管道的反面是什么？就是SOA概念中专注服务治理的企业服务总线（简称ESB），<strong>ESB实质上就是一个管道</strong>，也就是应用A要访问服务B，A要先发数据给ESB， 然后ESB调用B，B产生的数据返给ESB，然后ESB再返给A，<strong>这样ESB不仅仅提供了路由的功能， 而且把自己做成了一个大型企业系统的中心</strong>，基于此，又发展附加了原本不属于管道的功能，比如服务B提供的是socket服务，但是应用A是使用http调用，这时ESB发展出了转换报文的功能， 甚至是服务B提供的是a,b,c三个数据，而应用A需要的是a，b，c拼接起来命名为d的数据，这也放在ESB中实现。这样就使得ESB实际上又承载了业务逻辑，<strong>使得原本复杂的系统通过服务治理把瓶颈和复杂度统统压到ESB一个中心点上去了</strong>，这跟微服务去中心化的思想截然相反。</li><li>所以ESB这一危险度（<strong>ESB完蛋，全部系统都受影响，另外要上系统，通常先要给ESB组看 一下，ESB需要一个额外的有执行力的团队去支撑</strong>）催生了微服务体系的智能端点和哑管道， 相对ESB而言，<strong>微服务体系的管道只提供路由或者负载均衡之类的，不承载业务逻辑</strong>，或者是MQ之类的异步消息中间件，管道根本不关心具体传送的数据，所以与其叫哑管道，不如叫非智能管道（实际上我都不知道为什么会翻成哑管道，难以理解），智能端点就是相对 ESB中的服务提供者只需要提供一种类型的服务，<strong>智能端点需要根据服务调用者的需求提供多种类型的服务以适应业务发展。</strong>也就是上述那些ESB所做的比如<strong>报文转换</strong>，比如<strong>数据转换</strong>等等统统是在服务提供端实现。</li></ul><h5 id="2-3-为什么使用微服务"><a href="#2-3-为什么使用微服务" class="headerlink" title="2.3 为什么使用微服务"></a>2.3 为什么使用微服务</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081642867.png" alt="image-20211108164244776"></p><ul><li>采用微服务架构模式，则可以解决单一架构模式带来的系统复杂性。<ul><li>相对于单体架构一旦需要变更非常麻烦，使用微服务以后，日日可变更，甚至可以实现自动化， 日日变更不头疼</li><li>采用微服务以后可以根据实时流量弹性伸缩，在流量高峰可以动态扩容，基于不同仓库数据， 可以实现实时更新，热生效</li><li>使用微服务以后开发人员的代码可以最大程度复用，减少工作量，让业务开发越来越快</li><li>基于微服务的Spring Cloud，Service Mesh可以进行跨语言，跨系统对话；减少了异构语言通信问题</li></ul></li></ul><h5 id="2-4-微服务的常见架构"><a href="#2-4-微服务的常见架构" class="headerlink" title="2.4 微服务的常见架构"></a>2.4 微服务的常见架构</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081653739.png" alt="image-20211108165344682"></p><ul><li><p><strong>Spring Cloud是基于Spring Boot的一整套实现微服务的框架，因此它只能采用Java语言</strong>，这是它与其他几个微服务框架的最明显区别。Spring Cloud是一个包含了很多子项目的整体方案，其中由Netflix开发后来又并入Spring Cloud的Spring Cloud Netflix是Spring Cloud微服务架构的核心项目，<strong>即可以简单地认为Spring Cloud微服务架构就是Spring Cloud Netflix</strong>，后面我们用 Spring Cloud时如果不特意声明，就是指Spring Cloud Netflix。</p></li><li><p>ZeroC IceGrid作为一种微服务架构，它基于RPC框架发展而来，具有良好的性能与分布式能力， 并具备微服务架构的如下明显特征：</p><ul><li>首先，微服务架构需要一个集中的服务注册中心，以及某种服务发现机制。</li><li>其次，微服务架构中的每个微服务通常会被部署为一个独立的进程，当无状态服务时，一般会由多个独立进程提供服务。</li><li>最后，一个好的微服务架构平台应该简化和方便应用部署。</li></ul></li><li><p>除了标准的基于RPC通信（以及类RPC的通信如Http Rest、SOAP等）的微服务架构，还有基于消息队列通信的微服务架构，这种架构下的微服务采用发送消息（Publish Message）与监听消息（Subscribe Message）的方式来实现彼此之间的交互。下图是这种微服务架构下各个组件之间的交互示意图，我们看到消息中间件是关键，它负责连通各个微服务与UI组件，担任了整个系统互联互通的重任。</p><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081659796.png" alt="image-20211108165953724"></p></li></ul><h5 id="2-5-微服务面临的挑战"><a href="#2-5-微服务面临的挑战" class="headerlink" title="2.5 微服务面临的挑战"></a>2.5 微服务面临的挑战</h5><p><img src="https://gitee.com/divemaven/git-project/raw/master/202111081700565.png" alt="image-20211108170033510"></p><ul><li>使用微服务面临的挑战：<ul><li>微服务应用作为分布式系统带来了复杂性。当应用是整体应用程序时，模块之间调用都在应用之内，即使进行分布式部署，依然在应用内调用。可是微服务是多个独立的服务，当进行模块调用的时候，分布式将会麻烦。</li><li> 多个独立数据库，事务的实现更具挑战性。</li><li>测试微服务变得复杂，当一个服务依赖另外一个服务时，测试时候需要另外一个服务的支持。</li><li>部署基于微服务的应用也很复杂，整体应用程序部署只需要部署在一组相同的服务器上，在这些服务前面加入传统的负载均衡器即可。独立服务的不是讲变得复杂，需要更高的自动化形式。</li></ul></li></ul><h4 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h4><p>本文主要讲述如下内容： </p><ul><li>软件架构的演变过程 </li><li>什么是微服务 </li><li>常见架构的微服务架构</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TSF</tag>
      
      <tag>Spring Boot</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
